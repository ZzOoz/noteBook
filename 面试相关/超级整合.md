































# @@HTML@@

## 行内元素有哪些？块级元素有哪些？空(void)元素有那些？行内元素和块级元素有什么区别？

行内元素有：`a b span img input select strong`

块级元素有：`div ul ol li dl dt dd h1 h2 h3 h4… p`

空元素：`<br> <hr> <img> <input> <link> <meta>`

行内元素不可以设置宽高，不独占一行

块级元素可以设置宽高，独占一行



# @@CSS@@



## 标准盒模型（content-box）和IE盒模型（border-box）的区别

W3C标准下padding、border所占的空间不在width、height范围内，而IE盒模型width包括content尺寸＋padding＋border的总和

用处：当使用布局时，可以使用border-box对padding进行更改，他的width会在内部更改而不会在外部更改（避免被撑开），如果使用margin的话可能会引起很多不必要的布局麻烦



## 如何将一个按钮始终在屏幕的底部？

```css
.btn{
	position：fixed;
	left:0;
	bottom:0;
	width:100%
}
```



## Css选择器优先级

**优先级：*内联样式 > ID选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 元素选择器 = 关系选择器 = 伪元素选择器 > 通配符选择器**

**!important的优先级是最高的**

## CSS常用选择器

```
通配符：*
ID选择器：#ID
类选择器：.class
元素选择器：p、a    等
后代选择器：p span、div a   等
伪类选择器：a:hover 等
属性选择器：input[type="text"]  等
```



## link和@import区别

**1.从属关系区别**

@import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。

**2.加载顺序区别**

加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。

**3.兼容性区别**

@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题



## 如何创建块级格式化上下文(block formatting context),`BFC`有什么用

非常感谢：https://www.jianshu.com/p/0fb2f90418c3

**什么是`BFC`**?

- `BFC`格式化上下文，它是一个独立的渲染区域，让处于 `BFC`内部的元素和外部的元素相互隔离，使内外元素的定位不会相互影响

**如何产生`BFC`**?

- `display: inline-block`
- `position: absolute/fixed`

**BFC作用**

- BFC最大的一个作用就是：在页面上有一个独立隔离容器，容器内的元素和容器外的元素布局不会相互影响



## CSS3动画（简单动画的实现，如旋转等）

- 依靠`CSS3`中提出的三个属性：`transition、transform、animation`
- `transition`：定义了元素在变化过程中是怎么样的，包含`transition-property、transition-duration、transition-timing-function、transition-delay`。
- `transform`：定义元素的变化结果，包含`rotate、scale、skew、translate`。
- `animation`：动画定义了动作的每一帧（`@keyframes`）有什么效果，包括`animation-name，animation-duration、animation-timing-function、animation-delay、animation-iteration-count、animation-direction`



## Css3伪类选择器before和after中添加图片

参考：https://www.cnblogs.com/qq976864507/p/11765513.html

```css
.box:before{
    content:"";
    background:url("doorImg2.png") no-repeat;
    background-size: 19px 24px;
    width:19px;
    height:24px;
    position:absolute;
    left:20px;
    top:25%;
}
```

​	**注意**：因为直接用content不能控制图片大小，所以把图片变成背景图片，然后用background-size就能控制图片大小了。这里width:30px;height:30px;也是必要的，不然图片也是不能显示出来，因为content为空就相当于没有宽度，背景图片是不能被渲染出来的。display：inline-block可以换成block，不过效果的话图片就会跑到下一行，但不能没有这个display样式。（我这里没有写也没有发现有什么问题）还有background-size不要不写，如果不明确background-size，但又保留了width和height，那图片只能显示其中的一部分



## box-shadow阴影详解

## 语法

box-shadow: *h-shadow v-shadow blur spread color* inset;

**注意：**boxShadow 属性把一个或多个下拉阴影添加到框上。该属性是一个用逗号分隔阴影的列表，每个阴影由 2-4 个长度值、一个可选的颜色值和一个可选的 inset 关键字来规定。省略长度的值是 0。

| 值         | 说明                                                         |
| :--------- | :----------------------------------------------------------- |
| *h-shadow* | 必需的。水平阴影的位置。允许负值                             |
| *v-shadow* | 必需的。垂直阴影的位置。允许负值                             |
| *blur*     | 可选。模糊距离                                               |
| *spread*   | 可选。阴影的大小                                             |
| *color*    | 可选。阴影的颜色。在[CSS颜色值](https://www.runoob.com/cssref/css_colors_legal.aspx)寻找颜色值的完整列表 |
| inset      | 可选。从外层的阴影（开始时）改变阴影内侧阴影                 |

# @@JavaScript@@

## 介绍一下 JS 的基本数据类型和引用类型

基本数据类型：String、Number、Boolean、null、undefined、Symbol

引用类型：Object、Function、Array、Date等

## call和apply的作用是什么？区别是什么？

call和apply的作用都是显式改变this指向、他们的区别是call第一个参数后面接收多个参数、apply接收一个数组

## window.onload和DOMCotentLoaded的区别

onLoad会等到DOM结构、图片、视频加载完成后执行；

DOMCotentLoaded会等到DOM结构加载完成后就立刻执行

## 渲染页面的过程

1. 用户输入url地址，浏览器根据域名寻找IP地址
2. 浏览器向服务器发送http请求，如果服务器段返回以301之类的重定向，浏览器根据相应头中的location再次发送请求
3. 服务器端接受请求，处理请求生成html代码，返回给浏览器，这时的html页面代码可能是经过压缩的
4. 浏览器接收服务器响应结果，如果有压缩则首先进行解压处理，紧接着就是页面解析渲染

　　解析渲染该过程主要分为以下步骤：

1. 解析HTML
2. 构建DOM树s
3. DOM树与CSS样式进行附着构造呈现树
4. 布局
5. 绘制

## 为何要把css文件放在head标签中?为何要把js文件放在body标签最后?

## 前端性能优化（加载更快、渲染更快）

1.让加载更快

​			1.1、减少资源体积：压缩代码（webpack打包压缩）

​			1.2、减少访问次数：合并代码（webpack打包）、SSR服务端渲染（减少ajax请求）、缓存

​			1.3、使用CDN

​	2.让渲染更快

​			2.1、CSS放在head中、js放在body最后

​			2.2、尽早执行js用DOMContentLoaded触发

​			2.3、懒加载

​			2.4、对DOM查询进行缓存、减少dom操作（合并到一起最后插入，使用文档片段）

​			2.5、节流防抖

## 闭包和自执行函数和自由变量

https://blog.csdn.net/weixin_42793426/article/details/81356337

https://www.cnblogs.com/libin-1/p/5955202.html

闭包：是可以访问另外一个作用域内部变量的函数

闭包常见的形式：作为函数返回和令函数作为参数传递

自由变量：一个变量在当前作用域没有被定义，但是被使用了会在**定义的地方向上级作用域**一层一层依次寻找，如果到全局作用域都没有被找到，会报undefined（注意是定义的地方）

自执行函数：自执行函数就是当它被定义出来，就会自动执行的函数。不需要调用，传参也很方便。

自执行函数有三种写法：

1. 　　( function ( “ 参数 ” ) { " 函数方法 " ; } ) ( “ 给参数传的值 ” )
2. 　　( function ( " 参数 " ) { “ 函数方法 ” ; } ( " 给参数传的值 " ) )
3. ​    ! function ( " 参数 " ) { " 函数方法 " ; } ( " 给参数传的值 " )　

```js
// 1.函数作为返回值
function print() {
    const a = 100
    return function() {
        console.log(a)
    }
}

const fn = print()
const a = 200
fn() // 100

// 2.函数作为参数传递
function print(fn) {
    const a = 100
    fn()
}

const a = 200
// 自由变量会在定义的地方一级一级网上寻找
// 自由变量会在创建函数的地方寻找对应的值
function fn() {
    console.log(a)
}

print(fn) // 200


//函数赋值
//3.一种变形的形式是将内部函数赋值给一个外部变量
var inner;
var F = function(){
    var b = 'local';
    var N = function(){
        return b;
    };
    inner = N;
};
F();
console.log(inner());
```



## This指向?



## New具体做了什么(var obj = new Base())

(1) 创建一个新对象；**var obj = {}
(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） ；obj.proto = Base.prototype;** **Base.call(obj);**
(3) 执行构造函数中的代码（为这个新对象添加属性） ；
(4) 返回新对象。



## truely和falsely变量

```js
// 以下是falsely变量 除此以外都是truely变量
!!0 === false
!!NaN === false
!!'' === false
!!null === false
!! undefined === false
!! false === false
```

 

## 判断变量类型（typeof（6种）、instanceof   Object.prototype.toString.call）

instanceof：测试一个对象是否为一个类的实例

typeof能判断的类型有:**（undefined、string、number、boolean、symbol、function、object）**

## 原型链和原型和继承?





## new Object() 和 Object.create()的区别

{}相当于new Object(),创建了之后会有Object.prototype原型

Object.create(null)创建是没有原型的，如果参数不是null，那么这个参数会作为新创建对象的原型





## Split和join的区别

答：split是通过参数来对字符串进行划分返回一个数组，join是通过参数对数组进行连接成字符串

```js
'1-2-3'.split('-') // [1,2,3]
[1,2,3].join('-') // '1-2-3'
```





## 说说数组api？那些是数组纯函数？那些不是？

**1.关于push、pop、unshift、shift**

push：向数组最后添加一个新元素、返回添加元素后一个数组的长度、改变原数组，参数是新元素

pop：向数组最后删除一个元素，返回数组删除的元素，改变原数组，无参数

unshift：向数组前面添加一个新元素、返回添加元素后一个数组的长度、改变原数组，参数是新元素

shift：向数组前面删除一个新元素、返回数组删除的元素，改变原数组，无参数

**2.数组纯函数（不改变原数组，返回一个数组）**

***属于纯函数的有：***

concat：拼接一个数组，生成一个新的数组，不改变原数组，参数是新的数组

slice（切片）：截取一个数组，生成新数组，不改变原数组，参数是 start 和 end （不包括该元素）的 arrayObject 中的元素。

map和filter也是数组纯函数

***不属于纯函数的有：***

forEach、some、every（不返回数组）

splice（剪接）、push、pop、unshift、shift（改变原数组）





## slice和splice的用法和区别?

slice为纯函数（不改变数组和返回数组）、splice不是纯函数

```js
// array-api slice
const res = [1, 2, 3, 4, 5]

const res1 = res.slice(1, 3) // 从1开始切片，到3位置不包括3返回一个新数组 [2,3]
const res2 = res.slice() // 返回一个新数组 [1,2,3,4,5]
const res3 = res.slice(1) // 从1开始切片，到最后  [2,3,4,5]
const res4 = res.slice(-2) // 从末尾开始算，切倒前两个 [4,5]

// array-api splice
const arr1 = res.splice(1, 2, ['a', 'b', 'c']) // 从1开始删除2个，添加[a,b,c]数组 最后原数组结果：[1,[a,b,c],4,5]，返回结果：[2,3]
const arr2 = res.splice(0, 2) // 0开始删除两个，最后原数组结果:[3,4,5] arr2的结果：[1.2]
const arr3 = res.splice(0) // 从0开始剪掉到最后 改变原数组  最后原数组结果:[]   arr3:[1,2,3,4,5]
```



## 列举强制转换和隐式类型转换

答：1.强制类型转换：parseInt、parseFloat、toString等

​		2.隐式类型转换：==、字符串拼接、逻辑运算if/else



## innerHTML和outerHTML的区别

innerHTML(元素内包含的内容）

outerHTML(自己以及元素内的内容）

```html
 //1.innerHTML

<body>
		<p>你好</p>
		<div id="test"><h5>就是喜欢你</h5></div>
		<script type="text/javascript">
			var hj=document.getElementById("test").innerHTML;
			alert(hj);
		</script>
</body>
 
输出结果：
 
<h5>就是喜欢你</h5>

//2.outerHTML 

<body>
		<p>你好</p>
		<div id="test"><h5>就是喜欢你</h5></div>
		<script type="text/javascript">
			var kj=document.getElementById("test").outerHTML;
			alert(kj);
		</script>
</body>
 
输出结果：
 
<div id="test"><h5>就是喜欢你</h5></div>
```



## 深拷贝和浅拷贝

**深拷贝的方式：**

1、json.parse(json.stringify(obj)) 先变成字符串再变成对象，这种方式的缺点是不能深拷贝funciton、正则、null等类型 乞丐版深拷贝

2、使用递归的方式深拷贝

```js
//1.json两种方法
//另一种深拷贝的方法是使用stringify和parse
// 但是缺点就是不能拷贝undefined ， function， RegExp 等等类型的
function deepCloneJson(obj){
    return JSON.parse(JSON.stringify(obj))
}

// 2.使用递归的方法
function deepClone(obj){
    // 这里判断是否为值类型
    // 判断是否不为对象或者等于null 如果成立直接返回值，如果不是对象则代表是值类型，null也是可以直接返回
    if(typeof obj !== 'object' || obj == null){
        return obj
    }
	
    // 新建变量
    let result
    if(obj instanceof Array){
        result = []
    }else{
        result = {}
    }
	
    // 遍历操作 递归赋值
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            result[key] = deepClone(obj[key])
        }
    }
    return result
}

let obj1 = {
    name: 'Yuteng',
    age: 12,
    class: ['a', 'b', 'c'],
    deee: {
        beijing: 'a'
    },
    Reg:/b/
}

const obj2 = deepCloneJson(obj1)
// console.log(obj2 === obj1)
console.log(obj2)
```

​						 

**浅拷贝的方式**：

参考：https://segmentfault.com/a/1190000018762510（注意这里的第二点解构赋值是错的，应该是扩展运算符）

**1、使用Object.assign方法**

```js
var obj1 = {a: 1, b: 2}
 
var obj2 = Object.assign({}, obj1)
 
obj2.a = 4
 
console.log(obj1, obj2)
```

**2、使用扩展运算符**

```js
var obj1 = {a: 1, b: 2}
 
var obj2 = {...obj1}
 
obj2.a = 4
 
console.log(obj1, obj2)
```



## offsetWidth offsetHeight和clientWidth clientHeight的区别

必看：https://blog.csdn.net/qq_35430000/article/details/80277587

必看：https://www.jianshu.com/p/7e9c5e56eb3f

(1)offsetWidth （content宽度+padding宽度+border宽度）

(2)offsetHeight（content高度+padding高度+border高度）

(3)clientWidth（content宽度+padding宽度）

(4)clientHeight（content高度+padding高度）



## 可视区域距离页面顶部的距离

documentElement代表是html节点

body代表body节点

scrollTop=document.documentElement.scrollTop||document.body.scrollTop



# @@Js手写篇@@

## 防抖和节流

防抖：在用户结束输入的最后一刻执行操作

防抖使用场景（例子）：监听一个输入框时，文字变化后触发change事件，但是如果直接用keyup事件，则会频繁触发change，用户体验不好，而防抖就可以在用户输入结束或暂停时，才会触发change事件

```js
// 关于防抖
let input1 = document.getElementById('input1')

// 设置定时器timer
// 每次触发keyup事件如果没有超过500ms都会清空timer重新计时
// 输入1 没有超过500ms就输入2 会重新清空timer直到超过500ms才会打印
let timer = null
input1.addEventListener('keyup', function() {
    if (timer) {
        clearTimeout(timer)
    }
    timer = setTimeout(() => {
        console.log(input1.value)
        timer = null
    }, 500)
})

//进一步封装
// 进行封装
function debounce(fn, delay = 500) {
    let timer = null
        // 返回一个函数（闭包）,将timer放入闭包内,使其无法在外部被修改
    return function() {
        if (timer) {
            clearTimeout(timer) // 存在即清空
        }
        timer = setTimeout(() => {
            console.log(this, 'input1')
            fn.apply(this, arguments) // 传参调用回调
            timer = null
        }, delay)
    }
}

const input1 = document.getElementById('input1')

input1.addEventListener('keyup', debounce(() => {
    console.log(this, '我是里面的')
    console.log(input1.value)
}, 1000))
```

节流：在用户频繁操作的时候保持一定的频率触发

节流使用场景：拖拽一个元素要随时拿到该元素被拖拽的位置，直接使用drag事件会频繁触发、很容易导致卡顿，使用节流无论拖拽速度有多快，都会每间隔100ms触发一次

```js
// 节流相关
let div1 = document.getElementById("div1")

let timer = null // 定义一个定时器 但是这个定时器可以被任意修改
div1.addEventListener('drag', function(e) {
    if (timer) {
        // 如果定时器存在返回，与防抖不同，防抖是结束触发，而节流是在间隔一个时间有规律触发
        return
    }

    timer = setTimeout(() => {
        console.log(e.offsetX, e.offsetY)
        timer = null // 重新定义定时器
    }, 100)
})


//进一步封装
// 节流工具函数进一步封装
function throttle(fn, delay = 100) {
    let timer = null // 闭包变量无法外部修改
    return function() {
        if (timer) {
            return
        }
        timer = setTimeout(() => {
            fn.apply(this, arguments)
            timer = null
        }, delay)
    }
}

div1.addEventListener('drag', throttle(function(e) {
    console.log(e.offsetX, e.offsetY)
}))
```



## 手写深度降维

```js
// // 降维
const arrs = [1, 2, [3, 4, [5, 6]]]
console.log(arrs)
console.log(flatten(arrs))

function flatten(arrs){
    const isFlatten = arrs.some((arr) => arr instanceof Array)

    if(!isFlatten){
        return arrs
    }

    const result = Array.prototype.concat.apply([],arrs)
    return flatten(result)
}
```



## 手写bind函数

```js
// 手写bind函数
Function.prototype.bind1 = function() {
    // 将参数变成一个数组
    const arg = Array.prototype.slice.call(arguments)

    // bind函数的第一个参数也就是要调用的对象,同时去掉数组第一个
    const that = arg.shift()

    // 拿到需要使用的函数 因为Function可以看作一个类
    // 而fn1可以看作是Funtion的实例化对象 所以this指向fn1
    console.log(this,'hhh')
    const self = this

    // 返回一个函数
    return function() {
        // 这里的arg是去掉之前数组第一个之后的
        return self.apply(that, arg)
    }
}

function fn1(a, b) {
    console.log("this", this)
    console.log(a, b)
    return 'bind function'
}

const fn2 = fn1.bind1({ x: 100 }, 200, 300)
console.log(fn2())
```



## 手写深度比较

```js
function isObject(obj){
    return typeof obj === 'object' && obj !== null
}
function isEqual(obj1,obj2){
    if(!isObject(obj1) || !isObject(obj2)){
        return obj1 === obj2
    }

    if(obj1 === obj2){
        return true
    }

    const obj1Keys = Object.keys(obj1)
    const obj2Keys = Object.keys(obj2)

    if(obj1Keys.length !== obj2Keys.length){
        return false
    }

    for (const key in obj1) {
        const res = isEqual(obj1[key],obj2[key])
        if(!res){
            return false
        }
    }
    return true
}

const obj1 = {
    a: 100,
    b: {
        x: 100,
        y: 200,
    }
}

const obj2 = {
    a: 100,
    b: {
        x: 100,
        y: 200
    }
}

console.log(isEqual(obj1, obj2))  // true
```



## 手写ajax

```js
function getAjax(){
    var xhr = new XMLHttpRequest();
    xhr.open('get','http://jsonplaceholder.typicode.com/posts')
    xhr.send(null)

    xhr.onreadystatechange = function(){
        if(xhr.status === 200 && xhr.readyState === 4){
            console.log(xhr.responseText)
        }
    }
}

function postAjax(){
    const name = '111'
    var xhr = new XMLHttpRequest()
    xhr.open('post','http://jsonplaceholder.typicode.com/posts')
    // 设置头部
    xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
    xhr.send("username="+name)
    xhr.onreadystatechange = function(){
        if(xhr.status === 200 && xhr.readyState === 4){
            console.log(xhr.responseText)
        }
    }
}
```



# @@ES6@@

## let、const、var的区别？

一，var定义的变量，作用域是	封闭函数，是全域的；let定义的变量，作用域是在块级或者字块中；

二，变量提升：不论通过var声明的变量处于当前作用于的第几行，都会提升到作用域的最顶部。

   而let声明的变量不会在顶部初始化，凡是在let声明之前使用该变量都会报错（引用错误ReferenceError）会引起暂时性死区；

三，只要块级作用域内存在let，它所声明的变量就会绑定在这个区域；

四，let不允许在相同作用域内重复声明（报错同时使用var和let，两个let）





​	

## 扩展运算符的引用有哪些？

**1、复制数组**

```js
/**
 * 复制数组
 */
const a = [1,2,3]
const [...a2] = a
const a3 = [...a]

a2[0] = 2
a3[0] = 4
console.log(a)
console.log(a2)
console.log(a3)
```



**2、合并数组和对象**

扩展运算符提供了数组合并的新写法。

```javascript
// 例1
const arr1 = ['a', 'b'];
const arr2 = ['c'];
const arr3 = ['d', 'e'];

// ES5 的合并数组
arr1.concat(arr2, arr3);
// [ 'a', 'b', 'c', 'd', 'e' ]

// ES6 的合并数组
[...arr1, ...arr2, ...arr3]
// [ 'a', 'b', 'c', 'd', 'e' ]

// 例2
let ab = { ...a, ...b };
// 等同于
let ab = Object.assign({}, a, b);
```

不过，这两种方法都是浅拷贝，使用的时候需要注意。

```javascript
const a1 = [{ foo: 1 }];
const a2 = [{ bar: 2 }];

const a3 = a1.concat(a2);
const a4 = [...a1, ...a2];

a3[0] === a1[0] // true
a4[0] === a1[0] // true
```

上面代码中，`a3`和`a4`是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了引用指向的值，会同步反映到新数组。

**3、与解构赋值结合**

```js
const [frist,...res] = [1,2,3]
console.log(frist) // 1
console.log(...res) //2，3
```

如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。

```javascript
const [...butLast, last] = [1, 2, 3, 4, 5];
// 报错

const [first, ...middle, last] = [1, 2, 3, 4, 5];
// 报错
```

**4、实现了 Iterator 接口的对象转换为数组**

任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。

```javascript
let nodeList = document.querySelectorAll('div');
let array = [...nodeList];
```

上面代码中，`querySelectorAll`方法返回的是一个`NodeList`对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于`NodeList`对象实现了 Iterator 。



## 使用结构赋值，实现两个变量的值的交换

```js
let a = 1;let b = 2;
[a,b] = [b,a];
```



## 使用箭头函数应注意什么？

（1）用了箭头函数，this就不是指向window，而是父级（指向是可变的）
（2）不能够使用arguments对象
（3）不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误
（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数



## 介绍下 Set、Map的区别？

**Set**： Set是ES6引入的一种类似Array的新的数据结构，Set实例的成员类似于数组item成员，区别是Set实例的成员都是唯一，不重复的。这个特性可以轻松地实现数组去重。

**Map**: Map是ES6引入的一种类似Object的新的数据结构，Map可以理解为是Object的超集，打破了以传统键值对形式定义对象，对象的key不再局限于字符串，也可以是Object。可以更加全面的描述对象的属性。

应用场景Set用于数据重组，Map用于数据储存Set：　
（1）成员不能重复
（2）只有键值没有键名，类似数组
（3）可以遍历，方法有add, delete,has
Map:
（1）本质上是健值对的集合，类似集合
（2）可以遍历，可以跟各种数据格式转换



## Proxy是什么，有什么作用？Reflect是什么，有什么作用？

**Proxy**：  Proxy是ES6新增的一个构造函数，可以理解为JS语言的一个代理，用来改变JS默认的一些语言行为，包括拦截默认的get/set等底层方法，使得JS的使用自由度更高，可以最大限度的满足开发者的需求。比如通过拦截对象的get/set方法，可以轻松地定制自己想要的key或者value。下面的例子可以看到，随便定义一个myOwnObj的key,都可以变成自己想要的函数

基本形式：

```js
let obj = new Proxy({},{
	/**
	* 定制自己想要写的方法
	**/
})
```

**Reflect：**  Reflect是ES6引入的一个新的对象，他的主要作用有两点，一是将原生的一些零散分布在Object、Function或者全局函数里的方法(如apply、delete、get、set等等)，统一整合到Reflect上，这样可以更加方便更加统一的管理一些原生API。其次就是因为Proxy可以改写默认的原生API，如果一旦原生API别改写可能就找不到了，所以Reflect也可以起到备份原生API的作用，使得即使原生API被改写了之后，也可以在被改写之后的API用上默认的API。



## promise有几种状态，什么时候会进入catch？

**三个状态：**
pending、fulfilled、reject
**两个过程：**
padding -> fulfilled、padding -> rejected当pending为rejectd时，会进入catch



## iterator（遍历器）

首先`Symbol.iterator`方法返回一个对象（这个对象中包含了next方法、throw方法、return方法等），然后通过调用这个next方法才会返回一个遍历器对象（这个对象包含了value和done属性），这是需要注意的



## 具备iterator（遍历器）接口的数据结构有

（注意对象没有iterator遍历器）

- Array
- Map
- Set
- String
- TypedArray
- 函数的 arguments 对象
- NodeList 对象



## ES5和ES6遍历方法的比较？（for、forEach、for...in、for....of）

**for语句**：比较麻烦，是比较传统的一种方法

**forEach方法**：是数组上的api方法、缺点是无法中途跳出`forEach`循环，`break`命令或`return`命令都不能奏效。

**for..in**：是给对象所设计的，遍历出来的是key值，缺点如下：

- 数组的键名是数字，但是`for...in`循环是以字符串作为键名“0”、“1”、“2”等等。
- `for...in`循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。
- 某些情况下，`for...in`循环会以任意顺序遍历键名。

**for...of**：只要有[Symbol.iterator]接口的数据结构都可以进行遍历，遍历出来的是value值，同时也可以有break、return命令跳出



## Promise构造函数是同步执行还是异步执行，那么 then 方法呢？

promise构造函数是同步执行的，then方法是异步执行的，下面有示例

**下面的输出结果是多少?**

```js
const promise = new Promise((resolve, reject) => {
    console.log(1);
    resolve();
    console.log(2);
})


promise.then(() => {
    console.log(3);
})


console.log(4);
```

Promise 新建后立即执行，所以会先输出 1，2，而 Promise.then()内部的代码在 当次 事件循环的 结尾 立刻执行 ，所以会继续输出4，最后输出3



## Promise 中reject 和 catch 处理上有什么区别

reject 是用来抛出异常，catch 是用来处理异常
reject 是 Promise 的方法，而 catch 是 Promise 实例的方法
reject后的东西，一定会进入then中的第二个回调，如果then中没有写第二个回调，则进入catch
网络异常（比如断网），会直接进入catch而不会进入then的第二个回调



## Generator函数的特点

感谢文章：https://www.jianshu.com/p/e0778b004596

Generator 函数的特点就是：

1、分段执行，可以暂停
2、可以控制阶段和每个阶段的返回值
3、可以知道是否执行到结尾



## Async/Await

参考：https://segmentfault.com/a/1190000015488033

`async/await`实际上是`Generator`的语法糖。顾名思义，`async`关键字代表后面的函数中有异步操作，`await`表示等待一个异步方法执行完成。

- #### async

`async` 函数返回一个Promise对象（如果指定的返回值不是Promise对象，也返回一个Promise，只不过立即 `resolve `，处理方式同 `then `方法），因此 `async `函数通过 `return `返回的值，会成为 `then `方法中回调函数的参数：

```js
async function funcA() {
  return 'hello!';
}

funcA().then(value => {
  console.log(value);
})
// hello!
```

单独一个 `async `函数，其实与Promise执行的功能是一样的

- #### await

顾名思义， `await `就是异步等待，它等待的是一个Promise，因此 `await `后面应该写一个Promise对象，如果不是Promise对象，那么会被转成一个立即 `resolve `的Promise。 `async `函数被调用后就立即执行，但是一旦遇到 `await `就会先返回，等到同步操作执行完成，再接着执行函数体内后面的语句。总结一下就是：`async`函数调用不会造成代码的阻塞，但是`await`会引起`async`函数内部代码的阻塞。



## 说一下es6的导入导出模块

导入通过import关键字

```js
// 只导入一个
import {sum} from "./example.js"
// 导入多个
import {sum,multiply,time} from "./exportExample.js"
// 导入一整个模块
import * as example from "./exportExample.js"
```

导出通过export关键字

```js
//可以将export放在任何变量,函数或类声明的前面
export var firstName = 'Michael';
export var lastName = 'Jackson';
export var year = 1958;
//也可以使用大括号指定所要输出的一组变量
var firstName = 'Michael';
var lastName = 'Jackson';
var year = 1958;
export {firstName, lastName, year};
//使用export default时，对应的import语句不需要使用大括号
let bosh = function crs(){}
export default bosh;
import crc from 'crc';
//不使用export default时，对应的import语句需要使用大括号
let bosh = function crs(){}
export bosh;
import {crc} from 'crc';
```

# @@Vue@@



## MVVM为什么会出现？是什么？

**1、为什么会出现？**

在很久以前就已经有组件化的概念，但是那时候在模板渲染完成之后页面数据就是如此了，如果要更新数据就需要操作DOM，但是因为操作DOM是一件非常消耗性能的事情，同时处理起来很难有条理，那么就诞生了数据驱动视图的概念，意思就是不用去关注dom操作，我们只需要关注数据的变化来改变视图的显示，于是就出现了vue、react等框架，他们的能够实现数据驱动视图的原理时MVVM（vue）、setData（react）

**2、是什么？**

MVVM是一种实现数据驱动视图的一种方式，M是model层（可以看作数据data）、V是视图层（可以看做页面dom等）、VM是视图模型（可以看作是连接M和V的一种桥梁，例如methods、事件、mixin等）



## 说说你对 SPA 单页面的理解，它的优缺点分别是什么？

**优点：**

用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
基于上面一点，SPA 相对对服务器压力小；
前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

**缺点：**

初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。



## v-show 与 v-if 有什么区别？

**区别**：v-if每次条件为true的时候都将dom节点会重新渲染，然后将条件为false的节点销毁，而v-show则是会将所有节点都渲染，在切换的时候只不过将条件为false的节点用display:none隐藏掉



## Class 与 Style 如何动态绑定？

##### **3.1、在vue中绑定样式的两种方式?**

答：v-bind:class和v-bind:style

##### **3.2、具体使用**

```html
<template>
  <div>
    <!-- 1.绑定a属性的值，a的值在data中 -->
    <div :class="a">class1</div>
    <!-- 2.Active的存在取决于 isactive的值，为true就说明存在，为false就说明不存在。 -->
    <div :class="{active:isActive}">class2</div>
    <!-- :class = [“a”,”b”] 
    在数组中元素带不带引号的问题。带了说明是类名，不带就是data中的属性对应的值-->
    <div :class="['active',a]">class3</div>
    <!-- 1. 注意 style中是一个对象，中间用，隔开。前者是style属性，值是data中对应的数值 -->
    <div :style="styleData">style1</div>
  </div>
</template>

<script>
export default {
    data(){
        return{
            a:"class1",
            isActive:true,
            styleData:{
                color:'yellow',
                fontSize:"100px"
            }
        }
    }
}
</script>
<style lang="scss">
.class1{
    color:red
}
.active{
    font-size:50px;
}
</style>

```



## 为什么要在v-for中使用key?

在v-for循环中使用key（不要使用index和random），原因是因为diff算法是通过tag和key来判断，是否是同一个node，这样做会减少渲染不必要的node的次数，提升渲染性能



## computed 和 watch 的区别和运用的场景？

参考：https://www.cnblogs.com/jiajialove/p/11327945.html

**计算属性computed :** 

\1. 支持缓存，只有依赖数据发生改变，才会重新进行计算

\2. 不支持异步，当computed内有异步操作时无效，无法监听数据的变化

3.computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值

\4. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed

5.如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。

![img](https://img2018.cnblogs.com/blog/1402448/201908/1402448-20190809154932198-1444047098.png)

**侦听属性watch：**

1. 不支持缓存，数据变，直接会触发相应的操作；
2. watch支持异步
3. 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；

4. 当一个属性发生变化时，需要执行对应的操作；一对多；

5. 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，

　　**immediate**：组件加载立即触发回调函数执行，

　　**deep**: 深度监听，为了发现**对象内部值**的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。

![img](https://img2018.cnblogs.com/blog/1402448/201908/1402448-20190809160441362-1201017336.png)

**监听的对象也可以写成字符串的形式**

![img](https://img2018.cnblogs.com/blog/1402448/201908/1402448-20190809160648619-505189772.png)

**当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。这是和computed最大的区别**



## Vue的生命周期？描述Vue父子组件的执行顺序？

- 加载渲染过程

```
　　父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted
```

- 子组件更新过程

```
　　父beforeUpdate->子beforeUpdate->子updated->父updated
```

- 父组件更新过程

```
　　父beforeUpdate->父updated
```

- 销毁过程

```
　　父beforeDestroy->子beforeDestroy->子destroyed->父destroyed
```



## 描述组件渲染和更新过程（初次渲染、更新渲染、异步渲染）

##### 5.1、初次渲染过程

答：1、解析模板为render函数（vue-cli中在开发环境已经完成，vue-loader）

​		2、触发响应式，监听data属性getter和setter

​		3、执行render函数，生成vnode

​		4、patch（element，vnode）将e lement和vnode关联显示视图

##### 5.2、更新过程

答：1、修改data，触发setter（此前在getter中已被监听到了）

​		2、重新执行render函数，生成newVode

​		3、更新节点 patch（vnode，newVnode）

总结： *Vue.js* 是如何在我们修改 `data` 中的数据后修改视图了。简单回顾一下，这里面其实就是一个“`setter -> Dep -> Watcher -> 生成render函数产生vnode-> patch -> 视图`”的过程。

##### 5.3、异步渲染



答：1、nextTick是等待DOM更新渲染后再次执行

​		2、会去收集data的修改，一次性更新视图

​		3、这样会减少DOM的操作次数，提高性能

##### 5.4、为甚么要异步渲染？

因为如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染.

所以为了性能考虑。`Vue`会在本轮数据更新后，再去异步更新视图!



## 父组件可以监听到子组件的生命周期吗？

比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：

```js
// Parent.vue
// 通过监听子组件的生命周期在doSometing函数中做某些事情
<Child @mounted="doSomething"/>
    
// Child.vue
mounted() {
  this.$emit("mounted");
}
```

以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：

```html
//  Parent.vue
<Child @hook:mounted="doSomething" ></Child>

doSomething() {
   console.log('父组件监听到 mounted 钩子函数 ...');
},
    
//  Child.vue
mounted(){
   console.log('子组件触发 mounted 钩子函数 ...');
},    
    
// 以上输出顺序为：
// 子组件触发 mounted 钩子函数 ...
// 父组件监听到 mounted 钩子函数 ...     
```

当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。



## Vue组件间的通信



## slot（普通插槽、作用域插槽、具名插槽）



## 直接给一个数组项赋值，Vue 能检测到变化吗？



## 组件中 data 为什么是一个函数？



## Vue 是如何实现数据双向绑定的？

Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示：



![1.png](https://user-gold-cdn.xitu.io/2019/8/19/16ca75871f2e5f80?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

即：

- 输入框内容变化时，Data 中的数据同步变化。即 View => Data 的变化。
- Data 中的数据变化时，文本节点的内容同步变化。即 Data => View 的变化。

其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。

Vue 主要通过以下 4 个步骤来实现数据双向绑定的：

实现一个监听器 Observer：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。

实现一个解析器 Compile：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。

实现一个订阅者 Watcher：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。

实现一个订阅器 Dep：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。

以上四个步骤的流程图表示如下，如果有同学理解不大清晰的，可以查看文章[《0 到 1 掌握：Vue 核心之数据双向绑定》](https://juejin.im/post/5d421bcf6fb9a06af23853f1)，有进行详细的讲解、以及代码 demo 示例。



![1.png](https://user-gold-cdn.xitu.io/2019/8/19/16ca75871f729d89?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



## Vue修饰符

事件修饰符：

​	1、stop：阻止事件冒泡、

​	2、capture：捕获事件，从外到内触发事件、

​	3、prevent：阻止默认行为

​	4、self：只会触发自己范围内的事件，不包含子元素

​	5、once：只会触发一次

​	6、native：就是在父组件中给子组件绑定一个原生的事件，就将子组件变成了普通的HTML标签，不加'. native'事件是无法触 发的。

组件绑定事件时

表单修饰符：

​	1、lazy:使用了这个修饰符将会从“input事件”变成change事件进行同步

​	2、number：首先谁明这个number并不是限制用户的输入,而是将用户输入的数据尝试绑定为 js 中的 number 类型

举个例子，如果用户输入`300`，data 中绑定的其实是`'300'`(string)，添加 number 指令后可以得到 `300`(number)的绑定结果。
而如果用户输入的不是数字，这个指令并不会产生任何效果。

​	3、trim可以用来过滤前后的空格



## 怎么给vue定义全局的方法？

- 第一种：挂载到Vue的prototype上。把全局方法写到一个文件里面，然后for循环挂载到Vue的prototype上，缺点是调用这个方法的时候没有提示

```js
 Object.keys(tools).forEach(key => {
      Vue.prototype[key] = tools[key]
 })
```

- 第二种：利用全局混入mixin，因为mixin里面的methods会和创建的每个单文件组件合并。这样做的优点是调用这个方法的时候有提示

步骤：创建mixins.js文件、再main.js文件中引入Vue.mixin(mixins)，就可以使用了

```js
const mixin = {

 methods: {

  /**

   * 格式化时间

   * @param {string|number|object|Array} dateTime - 时间，可以是一个字符串、时间戳、表示时间的对象、Date对象或者******表示时间的数组

   * @param {string} [fmt] - 格式

   * @returns {string} 返回格式化后的日期时间，默认格式：2018年1月11日 15:00

   * @see [momentjs]{@tutorial http://momentjs.cn/}

   */

  formatDate (dateTime, fmt = 'YYYY年M月DD日 HH:mm:ss') {

   if (!dateTime) {

    return ''

   }

   moment.locale('zh-CN')

   dateTime = moment(dateTime).format(fmt)

   return dateTime

  }

 }

}
export defaullt mixin
```

- 第三种：自定义函数模块`  myFun.js

```jsx
exports.install = function(Vue) {
    Vue.prototype.customFun1 = function() {
        console.log('myFun customFun1()');
    };

    Vue.prototype.customFun2 = function() {
        let str_result = 'myFun customFun2()';
        return str_result
    };
}
```

> 在 main.js 中导入自定义模块

```jsx
import myFun from "./utils/myFun"

Vue.use(myFun);
```



## 怎么解决vue动态设置img的src不生效的问题？

使用require关键字，因为动态添加src被当作静态资源处理了，没有进行编译，所以要加上require

```js
<template>
  <div>
    <img :src="imgSrc" style="width:100px;height:100px"/>
  </div>
</template>

<script>

export default {
  name: 'Home',
  components: {
    
  },
  data(){
    return {
    // 这里引入静态文件要使用require
      imgSrc:require('../assets/logo.png')
    }
  }

}
</script>

```



## [怎么解决vue打包后静态资源图片失效的问题？](https://github.com/haizlin/fe-interview/issues/554#)

**vue打包后静态资源图片失效：**

老版本中需要找到config/index.js，找build打包对象里的assetsPublicPath属性，默认值为/，更改为./就好了；

新版本中只有手动更改vue.config.js， 在里面配置publicPath即可（从vue 3.3开始，baseUrl被废弃，使用publicPath代替）



## vue中怎么重置data？使用场景？

使用Object.assign将初始化的data覆盖当前的data

Object.assign（）方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象
this.$data获取当前状态下的data
this.$options.data()获取该组件初始状态下的data。
Object.assign(this.$data, this.$options.data())

**使用场景：** 当有一个表单提交后，希望组件恢复到初始状态，重置data数据

## Vue.observable你有了解过吗？说说看

简单来说就一个简单的轻量的类vuex的Api，可以实现简单的跨组件的数据共享的问题

比如说在一个js文件中定义

```js
// /observer/observer.js
import Vue from 'vue'

export const store = Vue.observable({ count: 0 })
export const mutations = {
  setCount (count) {
    store.count = count
  }
}
```

然后再一个vue文件中引入

```js
<template>
    <div>
        <label for="bookNum">数 量</label>
            <button @click="setCount(count+1)">+</button>
            <span>{{count}}</span>
            <button @click="setCount(count-1)">-</button>
    </div>
</template>

<script>
import { store, mutations } from '../store/store' // Vue2.6新增API Observable

export default {
  name: 'Add',
  computed: {
    count () {
      return store.count
    }
  },
  methods: {
    setCount: mutations.setCount
  }
}
</script>
```

这样可以实现数据的修改



## 你知道style加scoped属性的用途和原理吗？

用途：防止全局同名CSS污染
原理：在标签加上v-data-something属性，再在选择器时加上对应[v-data-something]，即CSS带属性选择器，以此完成类似作用域的选择方式

在标签上绑定data-v-xxx属性，使得只能控制当前组件的样式，防止CSS样式全局污染



## vue怎么实现强制刷新组件？

1、强制重新渲染

```js
1、使用this.$forceUpdate()
2、使用v-if
```

2、强制重新刷新组件

```js
//模版上绑定key
<SomeComponent :key="theKey"/>
//选项里绑定data
data(){
  return{
      theKey:0
  }
}
//刷新key达到刷新组件的目的
theKey++;
```



## vue如果想扩展某个现有的组件时，怎么做呢

方法：

1. 使用Vue.extend直接扩展
2. 使用Vue.mixin全局混入
3. HOC封装
4. 加slot扩展



## vue使用v-for遍历对象时，是按什么顺序遍历的？如何保证顺序？

1、会先判断是否有iterator接口，如果有循环执行next()方法
2、没有iterator的情况下，会调用Object.keys()方法，在不同浏览器中，JS引擎不能保证输出顺序一致
3、保证对象的输出顺序可以把对象放在数组中，作为数组的元素



## 使用vue渲染大量数据时应该怎么优化？

非常感谢：https://www.cnblogs.com/crizy/p/9922246.html

使用Object.freeze()冻结一个对象不能够修改



## vue组件里的定时器要怎么销毁？

当生命周期销毁后，并没有将组件中的计时器销毁，虽然页面上看不出来，但是如果在控制台打印的话，会发现计时器还在运行，所以要销毁计时器，避免代码一直执行

```js
const timer = setInterval(() =>{
// 某些定时器操作
}, 500);
// 通过$once来监听定时器，在beforeDestroy钩子可以被清除。
this.$once('hook:beforeDestroy', () => {
clearInterval(timer);
})
```



## vue 创建监听,和销毁监听(addEventListener, removeEventListener)

最近在做一个有关监听scroll的功能, 发现我添加监听之后一直不起作用:

```js
mounted() {
    window.addEventListener("scroll", this.setHeadPosition); 
}//this.setHeadPosition方法名
```

　　后来发现要在后面添加一个true之后才行:

```js
mounted() {
	window.addEventListener("scroll", this.setHeadPosition, true);
},
```

　　而在离开是的时候需要销毁监听: (在destroyed里面销毁), 否则监听会一直存在, 因为这是单页面应用, 页面并未关闭.

```js
destroyed() {
	window.removeEventListener("scroll", this.setHeadPosition, true);
},
```

　 在销毁的时候一定也要加上true, 否则销毁不起作用.



## 使用vue语法ref时获取到undefined为空？如何解决？

**1、你在哪里调用，和你调用的对象**

试试在mounted（）里面调用有效果没有

调用的对象是本来就存在的，还是需要数据渲染之后才会出现的，同理，在mounted（）里面调用看看

**2、调用对象是不是数组列表**

  我一开始设置ref在v-for列表上，直接获取this.$refs.name.style，永远是空的，

  后来才发现，this.$refs.name是一个数组，无法通过 .style 获取样式，

  只能遍历这个this.$refs.name数组，在this.$refs.name[index]上设置样式

  但是像高度宽度，可以通过offsetHeight，等来获取。

**3、调用对象是否和v-if结合使用**

 ref不是响应式的，所有的动态加载的模板更新它都无法相应的变化。

解决方案：

　　通过

**setTimeout(() => {**

　　　　**}, 0)**

来得到数据



vue中的mixins实现图片懒加载

# @@Vue-router@@



## Vue-router有哪几种钩子（导航守卫）

全局：

路由内：

组件内:



## Vue-router完整的导航流程是什么



## Router和route有什么区别?

Router是指整个路由对象，里面有一些跳转的方法比如：push、go、replace等

route是指当前的路由对象，里面有一些当前路由的信息比如query、params等



## Push、go、replace的区别

**push**：跳转到不同的url，但这个方法会向history栈添加一个记录，点击后退会返回到上一个页面。

**replace**：同样是跳转到指定的url，但是这个方法不会向history里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的

**go**：相对于当前页面向前或向后跳转多少个页面,类似 `window.history.go(n)`。n可为正数可为负数。正数返回上一个页面



## 如何配置重定向？

```js
//路径：
{ path: '/a', redirect: '/b' }
//命名的路由： 
{ path: '/a', redirect: {name:'/foo'} }
//动态重定向目标： 
{ path: '/a', redirect: to => {
const {
query,
params,
hash
} = to
if (params.name) {
return /${params.name}
} else if (query.to && query.to === "bar") {
return /${query.to}
} else if (hash === '#baz') {
return '/baz'
}
}
}
```



## 如何配置404页面？

再路由的最后添加，如果所有的路由都不匹配会走这一条

```js
{
	path:*,
	component:NotFound,
	name:NotFound
}
```



## vue-router如何响应路由参数的变化？

问题：为什么要响应参数变化？

- 切换路由，路由参数发生了变化，但是页面数据并未及时更新，需要强制刷新后才会变化。
- 不同路由渲染相同的组件时（组件复用比销毁重新创建效率要高），在切换路由后，当前组件下的生命周期函数不会再被调用。

解决方案：

1. 使用 watch 监听

```js
watch: {
    $route(to, from){
        if(to != from) {
            console.log("监听到路由变化，做出相应的处理");
        }
    }
}
```

1. 向 router-view 组件中添加 key

   ```js
   <router-view :key="$route.fullPath"></router-view>
   ```

   $route.fullPath 是完成后解析的URL，包含其查询参数信息和hash完整路径





## 如何获取路由参数？

如果使用`query`方式传入的参数使用`this.$route.query` 接收
如果使用`params`方式传入的参数使用`this.$router.params`接收



## 在vue组件中怎么获取到当前的路由信息？

如果是template中获取直接 `$route` 即可
如果是script中获取 `this.$route`
可以 `console.log(this.$route)` 查看其详细信息



## Vue中的sync修饰是干什么用的？

在`Vue`中，`props`属性是单向数据传输的,父级的prop的更新会向下流动到子组件中，但是反过来不行。可是有些情况，我们需要对prop进行“双向绑定”。我们提到了使用`v-model`实现双向绑定。但有时候我们希望一个组件可以实现多个数据的“双向绑定”，而`v-model`一个组件只能有一个(Vue3.0可以有多个)，这时候就需要使用到`.sync`。

#### `.sync`与`v-model`的异同

相同点：

- 两者的本质都是语法糖，目的都是实现组件与外部数据的双向绑定
- 两个都是通过属性+事件来实现的

不同点(个人观点，如有不对，麻烦下方评论指出，谢谢)：

- 一个组件只能定义一个`v-model`,但可以定义多个`.sync`
- `v-model`与`.sync`对于的事件名称不同，`v-model`默认事件为`input`,可以通过配置`model`来修改，`.sync`事件名称固定为`update:属性名`

#### 自定义`.sync`

在开发业务时，有时候需要使用一个遮罩层来阻止用户的行为（更多会使用遮罩层+loading动画），下面通过自定义`.sync`来实现一个遮罩层

![img](https://user-gold-cdn.xitu.io/2020/6/12/172a70e9a027bdc8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

```js
<!--调用方式-->
<template>
  <custom-overlay :visible.sync="visible" />
</template>

<script>
export default {
  data() {
    return {
      visible: false
    }
  }
}
</script>
```



# @@VueX@@



# @@React@@



## 关于生命周期

**1、React 组件生命周期有哪些不同阶段？**

在组件生命周期中有四个不同的阶段：

1. **Initialization**：在这个阶段，组件准备设置初始化状态和默认属性。
2. **Mounting**：react 组件已经准备好挂载到浏览器 DOM 中。这个阶段包括`componentWillMount`和`componentDidMount`生命周期方法。
3. **Updating**：在这个阶段，组件以两种方式更新，发送新的 props 和 state 状态。此阶段包括`shouldComponentUpdate`、`componentWillUpdate`和`componentDidUpdate`生命周期方法。
4. **Unmounting**：在这个阶段，组件已经不再被需要了，它从浏览器 DOM 中卸载下来。这个阶段包含 `componentWillUnmount` 生命周期方法。

除以上四个常用生命周期外，还有一个错误处理的阶段：

**Error Handling**：在这个阶段，不论在渲染的过程中，还是在生命周期方法中或是在任何子组件的构造函数中发生错误，该组件都会被调用。这个阶段包含了 `componentDidCatch` 生命周期方法。



![img](https://user-gold-cdn.xitu.io/2019/11/6/16e3df8cee593053?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



**2、React 的生命周期方法有哪些？**

- `componentWillMount`:在渲染之前执行，用于根组件中的 App 级配置。
- `componentDidMount`：在第一次渲染之后执行，可以在这里做AJAX请求，DOM 的操作或状态更新以及设置事件监听器。
- `componentWillReceiveProps`：**在初始化`render`的时候不会执行，它会在组件接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染**
- `shouldComponentUpdate`：确定是否更新组件。默认情况下，它返回`true`。如果确定在 `state` 或 `props` 更新后组件不需要在重新渲染，则可以返回`false`，这是一个提高性能的方法。
- `componentWillUpdate`：在`shouldComponentUpdate`返回 `true` 确定要更新组件之后执行。
- `componentDidUpdate`：它主要用于更新DOM以响应`props`或`state`更改。
- `componentWillUnmount`：它用于取消任何的网络请求，或删除与组件关联的所有事件监听器。



**类组件和函数组件之间的区别是啥？**

- **类组件**可以使用其他特性，如状态 `state` 和生命周期钩子。
- 当组件只是接收 `props` 渲染到页面时，就是无状态组件，就属于函数组件，也被称为哑组件或展示组件。

函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。为了提高性能，尽量使用函数组件。

| 区别               | 函数组件 | 类组件 |
| ------------------ | -------- | ------ |
| 是否有 `this`      | 没有     | 有     |
| 是否有生命周期     | 没有     | 有     |
| 是否有状态 `state` | 没有     | 有     |



## **React 中 refs 干嘛用的？**

`Refs` 提供了一种访问在`render`方法中创建的 DOM 节点或者 React 元素的方法。在典型的数据流中，`props` 是父子组件交互的唯一方式，想要修改子组件，需要使用新的`pros`重新渲染它。凡事有例外，某些情况下咱们需要在典型数据流外，强制修改子代，这个时候可以使用 `Refs`。

咱们可以在组件添加一个 `ref` 属性来使用，该属性的值是一个回调函数，接收作为其第一个参数的底层 DOM 元素或组件的挂载实例。

```
class UnControlledForm extends Component {
  handleSubmit = () => {
    console.log("Input Value: ", this.input.value)
  }
  render () {
    return (
      <form onSubmit={this.handleSubmit}>
        <input
          type='text'
          ref={(input) => this.input = input} />
        <button type='submit'>Submit</button>
      </form>
    )
  }
}
复制代码
```

请注意，`input` 元素有一个`ref`属性，它的值是一个函数。该函数接收输入的实际 DOM 元素，然后将其放在实例上，这样就可以在 `handleSubmit` 函数内部访问它。

经常被误解的只有在类组件中才能使用 `refs`，但是`refs`也可以通过利用 JS 中的闭包与函数组件一起使用。

```
function CustomForm ({handleSubmit}) {
  let inputElement
  return (
    <form onSubmit={() => handleSubmit(inputElement.value)}>
      <input
        type='text'
        ref={(input) => inputElement = input} />
      <button type='submit'>Submit</button>
    </form>
  )
}
```





## **在 React 中如何处理事件？**

为了解决跨浏览器的兼容性问题，`SyntheticEvent` 实例将被传递给你的事件处理函数，`SyntheticEvent`是 React 跨浏览器的浏览器原生事件包装器，它还拥有和浏览器原生事件相同的接口，包括 `stopPropagation()` 和 `preventDefault()`。

比较有趣的是，React 实际上并不将事件附加到子节点本身。React 使用单个事件侦听器侦听顶层的所有事件。这对性能有好处，也意味着 React 在更新 DOM 时不需要跟踪事件监听器。



## **state 和 props 区别是啥？**

`props`和`state`是普通的 JS 对象。虽然它们都包含影响渲染输出的信息，但是它们在组件方面的功能是不同的。即

- `state` 是组件自己管理数据，控制自己的状态，可变；
- `props` 是外部传入的数据参数，不可变；
- 没有`state`的叫做无状态组件，有`state`的叫做有状态组件；
- 多用 `props`，少用 `state`，也就是多写无状态组件。



## 如何创建 refs

Refs 是使用 `React.createRef()` 创建的，并通过 `ref` 属性附加到 React 元素。在构造组件时，通常将 `Refs` 分配给实例属性，以便可以在整个组件中引用它们。

```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }
  render() {
    return <div ref={this.myRef} />;
  }
}
复制代码
```

或者这样用：

```jsx
class UserForm extends Component {
  handleSubmit = () => {
    console.log("Input Value is: ", this.input.value)
  }
  render () {
    return (
      <form onSubmit={this.handleSubmit}>
        <input
          type='text'
          ref={(input) => this.input = input} /> // Access DOM input in handle submit
        <button type='submit'>Submit</button>
      </form>
    )
  }
}
```



## 在构造函数调用 `super` 并将 `props` 作为参数传入的作用是啥？

在调用 `super()` 方法之前，子类构造函数无法使用`this`引用，ES6 子类也是如此。将 `props` 参数传递给 `super()` 调用的主要原因是在子构造函数中能够通过`this.props`来获取传入的 `props`。

**传递 props**

```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    console.log(this.props);  // { name: 'sudheer',age: 30 }
  }
}
复制代码
```

**没传递 props**

```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super();
    console.log(this.props); // undefined
    // 但是 Props 参数仍然可用
    console.log(props); // Prints { name: 'sudheer',age: 30 }
  }

  render() {
    // 构造函数外部不受影响
    console.log(this.props) // { name: 'sudheer',age: 30 }
  }
}
复制代码
```

上面示例揭示了一点。`props` 的行为只有在构造函数中是不同的，在构造函数之外也是一样的。



## 讲讲什么是 JSX ？

当 **Facebook** 第一次发布 React 时，他们还引入了一种新的 JS 方言 `JSX`，将原始 HTML 模板嵌入到 JS 代码中。JSX 代码本身不能被浏览器读取，必须使用`Babel`和`webpack`等工具将其转换为传统的JS。很多开发人员就能无意识使用 JSX，因为它已经与 React 结合在一直了。

```jsx
class MyComponent extends React.Component {
  render() {
    let props = this.props;  
    return (
      <div className="my-component">
      <a href={props.url}>{props.name}</a>
      </div>
    );
  }
}
```



## **为什么不直接更新 `state` 呢 ?**

如果试图直接更新 `state` ，则不会重新渲染组件。

```jsx
 // 错误
 This.state.message = 'Hello world';
复制代码
```

需要使用`setState()`方法来更新 `state`。它调度对组件`state`对象的更新。当`state`改变时，组件通过重新渲染来响应：

```jsx
// 正确做法
This.setState({message: ‘Hello World’});
```



## React 中的StrictMode(严格模式)是什么？？

React 的`StrictMode`是一种辅助组件，可以帮助咱们编写更好的 react 组件，可以使用`<StrictMode />`包装一组组件，并且可以帮咱们以下检查：

- 验证内部组件是否遵循某些推荐做法，如果没有，会在控制台给出警告。
- 验证是否使用的已经废弃的方法，如果有，会在控制台给出警告。
- 通过识别潜在的风险预防一些副作用。



## **为什么类方法需要绑定到类实例？**

在 JS 中，`this` 值会根据当前上下文变化。在 React 类组件方法中，开发人员通常希望 `this` 引用组件的当前实例，因此有必要将这些方法绑定到实例。通常这是在构造函数中完成的:

```jsx
class SubmitButton extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      isFormSubmitted: false
    };
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleSubmit() {
    this.setState({
      isFormSubmitted: true
    });
  }

  render() {
    return (
      <button onClick={this.handleSubmit}>Submit</button>
    )
  }
}
```



## 什么是 prop drilling，如何避免？

在构建 React 应用程序时，在多层嵌套组件来使用另一个嵌套组件提供的数据。最简单的方法是将一个 `prop` 从每个组件一层层的传递下去，从源组件传递到深层嵌套组件，这叫做**prop drilling**。

`prop drilling`的主要缺点是原本不需要数据的组件变得不必要地复杂，并且难以维护。

为了避免`prop drilling`，一种常用的方法是使用**React Context**。通过定义提供数据的`Provider`组件，并允许嵌套的组件通过`Consumer`组件或`useContext` Hook 使用上下文数据。



## 受控组件和非受控组件

- **受控组件**是 React 控制中的组件，并且是表单数据真实的唯一来源。
- **非受控组件**是由 DOM 处理表单数据的地方，而不是在 React 组件中。



## 如何在 ReactJS 的 Props上应用验证？

答：使用prop-types插件

```js
import PropsType from 'prop-types'

组件名.propTypes = {
	username:PropsType.string.isRequired,
	age:PropsType.number.isRequired
}
```



## 如何避免组件的重新渲染？

React 中最常见的问题之一是组件不必要地重新渲染。React 提供了两个方法，在这些情况下非常有用：

- `React.memo()`:这可以防止不必要地重新渲染函数组件
- `PureComponent`:这可以防止不必要地重新渲染类组件

这两种方法都依赖于对传递给组件的`props`的浅比较，如果 `props` 没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。



## 什么是纯函数

答：https://blog.csdn.net/c_kite/article/details/79138814

**一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数。**



## 关于Hoc高阶组件的写法

```jsx
const HocFunc = (Com) => {
    return class HocDemo extends Component{
        state = {x:0,y:0}

        handleMove = (event) => {
            this.setState({
                x:event.clientX,
                y:event.clientY
            })
        }
        render(){
            return (
                <div onMouseMove={this.handleMove}>
                    <Com state={this.state} />
                </div>
            )
        }
    }
}

class Demo extends Component{
    render(){
        const {x,y} = this.props.state
        return(
            <div>
                this is position {x} - {y}
            </div>
        )
    }
}

export default HocFunc(Demo)
```



## 关于富文本的写法（dangerouslySetInnerHTML）

```jsx
const rawHtml = "<span>我是富文本</span>"
const rawData = {
	__html:rawHtml
}

const rawHtmlElem = <div>
    // 这种就不会渲染成下面这种形式
	<p dangerouslySetInnerHTML={rawData}></p>
          
    // 这样会直接渲染成<span>我是富文本</span>
    <p>{rawData}</p>
</div>
```



## 关于setState的知识

**2.1、不可变值（不要直接修改state）：** 在使用setState的时候，不要去修改原先的值

**2.2、可能会异步更新：**在一般的情况会会是异步更新，但是在setTimeout和自定义DOM事件的时候是同步更新的

**2.3、可能会被合并成一个setState：**在使用对象时，



## 关于受控组件和非受控组件

**受控组件:**

```js
在React中，可变状态通常保存在组件的状态属性中，并且只能使用 setState() 进行更新，而呈现表单的React组件也控制着在后续用户输入时该表单中发生的情况，以这种由React控制的输入表单元素而改变其值的方式，称为受控组件。
```

```js
import React, { Component } from 'react'
export default class MyInput extends Component{
  constructor(props) {
    super(props);
    this.state = {
      value: 0
    }
  }
  handleChange = (event)=>{
    this.setState({
        value: event.target.value
    })
  }
  render(){
    return(
      <div>
          <input
              type="text"
              value={this.state.value}
              onChange={this.handleChange}
           />
      </div>
    )
  }
}
```



**非受控组件:**

```html
非受控组件指的是，表单数据由DOM本身处理。即不受setState()的控制，与传统的HTML表单输入相似，input输入值即显示最新值。
input、textArea这些默认都是非受控组件
```

```jsx
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
  }
	
  
  handleSubmit(event) {
    console.log('A name was submitted: ' + this.input.value);
    event.preventDefault();
  }

  render() {
    // 通过ref获取DOM中的值
     return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Name:
          <input type="text" ref={(input) => this.input = input} />
        </label>
        <input type="submit" value="Submit" />
      </form>
    );
  }
}
```

**两者区别**

 **1、受控组件**

 受控组件依赖于状态
 受控组件的修改会实时映射到状态值上，此时可以对输入的内容进行校验
 受控组件只有继承React.Component才会有状态
 受控组件必须要在表单上使用onChange事件来绑定对应的事件

**2、非受控组件** 

 非受控组件不受状态的控制
 非受控组件获取数据就是相当于操作DOM
 非受控组件可以很容易和第三方组件结合，更容易同时集成 React 和非 React 代码



## 关于React的生命周期



## 关于Portals

原因：

**正常情况下组件会以既定层次嵌套渲染,但是有时候我们想让组件渲染到父组件之外**



描述：

**1、使得组件可以脱离父组件层级挂载在DOM树的任何位置。**

**2、组件的挂载点虽然可以脱离父组件。但是组件的事件冒泡机制仍可以传给父组件**



使用场景：

**1、overflow:hidden（当父组件设置了overflow：hidden属性的时候，子组件无法显示，可以通过portals将子组件逃离父组件）**

**2、父组件的z-index值太小**

**3、设置了fixed的子组件需要将自身逃离父组件，放在body的第一层**

使用：

```jsx
import React, { Component } from 'react'
import ReactDOM from 'react-dom'
import '../css/style.css'
export default class ProtalDemo extends Component {
    render() {

        // return (
        //     // 正常情况下组件会以既定层次嵌套渲染,但是有时候我们想让组件渲染到父组件之外
        //     // 比如下面的情况我们将这个div的position设置为fixed，想让他在body里面渲染
        //     // 就可以使用protal方法
        //     <div>
        //         <div className="modal">
        //             {/* {this.props.children} */}
        //             protalDemo
        //         </div>
        //     </div>
        // )

        // 这样就可以将这个元素挂载在body上面
        return ReactDOM.createPortal(
            <div className="modal">
                protalDemo
            </div>,
            document.body
        )
    }
}
```



## 关于React的异步组件加载

**步骤：使用React.lazy引入组件、使用React.Suspense加载组件**

**示例：**

```jsx
import React, { Component } from 'react'
import CotextDemo from './CotextDemo'

// 异步组件加载
// 通过React.lazy加载
const ContextDemo = React.lazy(()=>import('./CotextDemo'))
export default class AsyncDemo extends Component {
    render() {
        return (
            <div>
                <p>异步组件加载</p>
                {/*使用React.Suspense fallback加载时的html结构*/}
                <React.Suspense fallback={<div>....loading</div>}>
                    <ContextDemo></ContextDemo>
                </React.Suspense>
            </div>
        )
    }
}
```



## 关于SCU(shouldComponentUpdate生命周期)

介绍：

1、SCU默认返回true，即React默认渲染所有子组件

2、当父组件因为数据改变重新渲染时，无论该子组件是否有过数据更新都会更新

3、必须配合“不可变值”一起使用

4、在SCU中，不建议使用深度比较。使用PureCompoent是比较好的选择



**问：为什么要给一个SCU作为性能优化，react直接对比props和state帮你处理不行吗？**

答：因为有时候开发人员的业务书写不规范的，举个栗子：

```jsx
import React, { Component } from 'react'
import PropTypes from 'prop-types'
import _ from 'lodash'

export default class PropsDemo extends Component {

    sumbitTitle = (title) => {
        const newObj = {
            id:Math.random(),
            title:title
        }
        // 这个是正确的写法
        // this.setState({
        //     list:this.state.list.concat(newObj)
        // })

        // 如果react帮你在SCU中完全处理了,那么如果开发者开发不规范，就会引起这种错误
        // this.state.list push了之后就等于setState中的list了
        // 重要的地方*****请关注这里
        // 所以为什么react会开放SCU供开发者自行选择是否重新渲染UI
        this.state.list.push(newObj)
        this.setState({
            list:this.state.list
        })
    }

    state = {
        list:[
            {
                id:1,
                title:'标题1'
            },
            {
                id:2,
                title:'标题2'
            },
            {
                id:3,
                title:'标题3'
            }
        ],
        footer:'我是父组件底部文字'
    }

    render() {
        return (
            <div>
                <List list={this.state.list}/>
                <Input sumbitTitle={this.sumbitTitle} />
                <Footer footer={this.state.footer} length={this.state.list.length}></Footer>
            </div>
        )
    }
}

// Input组件
class Input extends Component{
    InputChange = (event) => {
        this.setState({
            title:event.target.value
        })
    }

    handleSumbit = () => {
        const { sumbitTitle } = this.props
        // 调用父组件的方法传值
        sumbitTitle(this.state.title)
        // 清空title
        // this.setState({
        //     title:''
        // })
    }

    render(){
        return (
            <div>
                <input type="text" onChange={this.InputChange}/>
                <button onClick={this.handleSumbit}>提交</button>
            </div>
        )
    }
}



class List extends Component{
    
    render(){
        const { list } = this.props
        return (
            <div>
                <ul>
                    {
                        list.map((item,index)=>{
                            // 每次遍历都必须加上key值，而且key值不能是random或者index
                            return <li key={item.id}>{index}----{item.title}</li>
                        })
                    }
                </ul>
            </div>
        )
    }

    //SCU使用方式，假设这里时进行深度比较，是react帮你处理的理想状态
    // 重要的地方*****请关注这里
    shouldComponentUpdate(nextProps,nextState){
        if(_.isEqual(nextProps.list,this.props.list)){
            return false
        }
        return true
    }
}
```



## 关于PureComponent和memo

**1、使用PureComponent：**首先PureComponent是在类组件使用的，当继承了PureCompoent之后，就不需要使用SCU生命周期了，直接帮你比较里面的数据是否变化

```jsx
class Footer extends PureComponent{
    // constructor(props){
    //     super(props)
    //     this.state = {
    //         footer:'底部文字'
    //     }
    // }
    render(){
        return (
            <div>
                {this.props.footer}
                {this.props.length}
            </div>
        )
    }



    // SCU的使用方式
    // shouldComponentUpdate(nextProps,nextState){
    //     // 如果下一个的props的footer和state中的footer相同那么没有必要渲染
    //     if(nextProps.footer !== this.props.footer || nextProps.length !== this.props.length){
    //         return true
    //     }
    //     // 否正重新渲染
    //     return false
    // }
    // shouldComponentUpdate(){}
    

    componentDidUpdate(){
        console.log('底部文字重新渲染')
    }
}
```



**2、使用memo：**memo是在函数组件中使用的，类似于PureComponents

```jsx
// 函数组件
function Footer(props) {
    return (
        <div>
            {props.footer}
            {props.length}
        </div>
    )
}

// 定义一个类似与SCU的方法
function areaEqual(prevProps,nextProps){
    if(prevProps.footer !== nextProps.footer && prevProps.length !== nextProps.length){
        return true
    }
    return false
}

// 使用memo方法
React.memo(Footer,areaEqual)
```



## 关于react中组件公共逻辑的抽离

**1、mixin，已经被react弃用**

**2、高阶组件HOC**

**3、Render Props** 





## 关于redux和react-redux的考点

**1、Redux的实现流程**

答：用户页面行为触发一个`Action`，然后，`Store `自动调用 `Reducer`，并且传入两个参数：当前 State 和收到的 Action。Reducer 会返回新的 State 。每当state更新之后，`view`会根据state触发重新渲染。



**2、react-redux的实现原理**

答：Redux作为一个通用模块，主要还是用来处理应用中state的变更，通过react-redux做连接，可以在React+Redux的项目中将两者结合的更好。
react-redux是一个轻量级的封装库，它主要通过两个核心方法实现：

```
Provider：从最外部封装了整个应用，并向connect模块传递store。
Connect： 
    1、包装原组件，将state和action通过props的方式传入到原组件内部。
    2、监听store tree变化，使其包装的原组件可以响应state变化	
```



**3、redux和react-redux的结合使用**

答：



## 关于React-router的考点

**1、路由传值的几种方式**

答：https://www.cnblogs.com/yuerdong/p/10605817.html

**2、React-Router 4中`<Router>`组件有几种类型**

答：

1、BrowserRouter 用于有服务器处理动态请求 ，HashRouter 用于处理静态资源网站

2、HashRouter 页面跳转原理是使用了location.hash、location.replace,并且路径中是包含/#

3、BrowerRouter页面跳转原理是使用了pushState、replaceState,路径不包含#直接定位到/目录下

4、BrowerRouter要与后端配合使用，BrowerRouter所跳转的url是真实的url，在测试的时候是可以跳转的，但是如果部署上去是会出现问题，而hashRouter是不会出现这种错误



**3、如何使用react-router写出一个后台管理的路由嵌套？**



**4、Switch有什么作用？**

答：Switch排他性路由，采用 `<Switch>`，只有**一个路由**会被渲染，并且总是渲染第一个匹配到的组件，更好进行路由匹配。而且匹配成功之后就不会再往下执行操作

# @@Webpack@@

## 什么是webpack？

答：webpack虽然是可以翻译模块导出语法，但实际上基于node环境的模块打包工具，

​		他的工作是：分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。



## filename和chunkname的区别？

filename 是对应entry入口的文件

chunkFilename 不在`output.entry`中的文件，但是需要单独打包的文件名 设置使用`require.ensure`或者`import`异步加载模块打包后的名称



## 什么是loader？

答：loader是对特定语言和文件的打包方案，能够让浏览器识别并且能运行起来



## css-loader和style-loader的功能？

答： css-loader会根据多个css文件之间的关系进行分析并且将其所有变成一个统一的css

​		style-loader会将这个统一的css文件挂载到html的head标签里面变成css样式



## url-loader和file-loader的区别？

答：1、url-loader依赖file-loader
       2、当使用url-loader加载图片，图片大小小于上限值，则将图片转base64字符串，；否则使用file-loader加载图片，      都是为了提高浏览器加载图片速度。
       3、使用url-loader加载图片比file-loader更优秀



## loader的相关配置

webpack.config.js文件

```js
// webpack 配置文件
// 通过命令行npx webpack 可以直接打包entry指定的文件
// 而不用使用npx webpack 文件名  的命令方式
// 如果webpack配置文件不是webpack.config.js的话 可以使用npx webpack --config (webpack配置文件名) 的方法打包
const path = require('path')
    // 使用loader打包样式、图片
module.exports = {
    // 入口文件
    entry: './src/index.js',
    output: {
        // 打包出口文件名
        filename: "bundle.js",
        path: path.resolve(__dirname, 'dist')
    },
    module: {
        rules: [{
                test: /\.(jpg|png|gif)$/,
                // loader: "file-loader",
                // 可以使用url-loader
                loader: "url-loader",
                options: {
                    // []中的值是占位符意思为按照原来的图片名和后缀打包
                    name: '[name].[ext]',
                    // 这是打包后的文件夹名/dist/images
                    outputPath: 'images/',
                    // limit是文件大小 大于这个值url-loader会按照file-loader打包
                    limit: 10240
                }
            },
            {
                test: /\.css$/,
                // loader 从右往左执行
                use: ['style-loader',
                    {
                        loader: 'css-loader',
                        options: {
                            modules: true,
                        }
                    }
                ],
            },
            {
                test: /\.scss$/,
                // loader 从右往左执行
                // postcss-loader它负责进一步处理 CSS 文件，比如添加浏览器前缀，压缩 CSS、兼容css样式等。
                loader: ['style-loader', 'css-loader', 'scss-loader', 'postcss-loader'],
            }
        ]
    }
}
```

postcss.config.js

```js
module.exports = {
    plugins: [
        // 对于css3的新特性会为其加入新前缀
        require('autoprefixer')
    ]
}
```

## 配置Es6转Es5语法的loader（重要）

1、安装babel-loader和 @babel/core

```js
npm install --save-dev babel-loader @babel/core @babel/preset-env @babel/polyfill 
```

**babel-loader的作用**：这个是babel和webpack连接的桥梁，当遇到js文件时需要使用loader处理

**@babel/core的作用**：这个时babel的核心，是将js文件转化成抽象语法树（ast）的关键，方便各个插件分析语法进行相应的处理

**注意！！：如果想要将ES6语法转化为ES5语法还是不够的，还要使用@babel/preset-env插件以及@babel/polyfill插件**

**@babel/preset-env的作用：** 将Es6语法转化成Es5语法这个才是最关键的转化语法插件（转换新的js语法，但是一些没有的新的api -——————> 比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如`Object.assign`）都不会转码。），**babel仅仅解析语法，但是是否ES5存在这个变量(比如promise.resolve这个语法es5但是promise并不是es5有的变量)他就不知道了**

**@babel/polyfill的作用：**这个插件的作用就是将一些新的api补充进去使得**@babel/preset-env能转码，是corejs和regenerator的集合

2、配置相关的loader语法

```js
    module: {
        rules: [{
            test: /\.js$/,
            exclude: /node_modules/,
            loader: "babel-loader",
            // 注意点1：option 这些选项存在与.babelrc文件中
            // options: {
            //     presets: [
            //         ["@babel/preset-env", {
            //             targets: {
            //                 chrome: 67
            //             },
            //             // 这个的作用就是当使用到新的js的api时才会通知进行@babel/preset-env转码
            //             useBuiltIns: 'usage'
            //         }]
            //     ]
            // }

            // 注意点2：@babel/preset-env仅仅适用于业务代码的转化
            // 当编写一些组件库或者自己写一些工具时，@babel/preset-env往往因为使用全局变量而污染了
            // 所以使用@babel/plugin-transform-runtime往往更合适(使用类似闭包特性 变量不会污染全局)
            // options在.babelrc文件
        }]
    },
```

.babelrc文件中配置optiions（主要时plugin和preset）

**注意!!：@babel/preset-env可以看作多个plugin的集合只不过是预设了而已**

```js
{
    // 使用@babel/preset-env业务
    "presets": [
        ["@babel/preset-env", {
            // 这个的作用就是当使用到新的js的api时才会通知进行@babel/preset-env转码
            // 而是用来"useBuiltIns": "usage"之后就没有必要再js文件中使用 import "@babel/polyfill" 这个语法 
            "useBuiltIns": "usage",
            "corejs": 3,  // corejs的版本
        }]
    ],
    "plugins": []
    
    //使用@babel/plugin-transform-runtime（编写组件库等）
    // "plugins": [
    //     [
    //         "@babel/plugin-transform-runtime",
    //         {
    //             "absoluteRuntime": false,
    //             "corejs": 2,  // corejs的版本
    //             "version": "^7.7.4"
    //         }
    //     ]
    // ]
}
```



## 什么是plugin？

**答：**plugin可以在webpack运行到某一时刻的时候帮我们做某一些事情



## module chunk bundle分别是什么意思，有何区别？

答：module是指任意的文件模块，等价于commonjs中的模块,相当于一个js文件

​       chunks是webpack处理过程中被分组了的modules，多个js文件经过打包后的dist目录下的js文件（有多个模块合成，一个依赖另一个），如代码分割时一个异步加载的chunk可能包含多个module

​       Bunldes是指打包出来的整个文件夹



## es6 module 和 commonJs的区别 ？

1、es module 属于静态引入，在编译时引入 （像import _ from 'lodash' 这种的没有定义变量const引入，也就是不需要代码执行时才去引入，而是在代码编译时就可以直接引入了）

2、commonJs 属于动态引入，在执行时引入（因为会定义变量 const a = require("lodash")，这种就是会在代码执行时才会去引入）

3、只有es module才能treeShaking 因为treeShaking就是在代码打包编译的时候执行的



## Devtools（source-map）是什么？

**介绍：**source-map是一种映射关系，通过这种映射关系在代码发生错误的时候可以定位的源代码错误的位置而不是打包后的代码的错误位置，可以给开发者更好的开发体验

**使用建议：**

​		1.当在开发模式下，建议使用cheap-module-eval-source-map

```js
    mode: 'development',
    devtool: 'cheap-module-eval-source-map',
```

​		2.当在生产模式下，建议使用cheap-module-source-map

```js
	mode: 'production',
    devtool: 'cheap-module-source-map',
```

​	

## 配置热更新要怎么做?

```js
// webpack.config.js文件
const webpack = require("webpack")
devServer:{
    hot:true // 配置hot为true
}
plugins:[
    new webpack.HotModuleReplacementPlugin()
]
```



## DevServer的配置？

 使用devServer配置(这样做的好处是对于服务器来说，可以发送ajax请求或者做其他处理，对于第1种用watch的方式是不可以的)

~~~js
// 1、需要先安装webpack-dev-server
// 2、在webpack.config.js文件下进行配置
    devServer: {
        contentBase: path.join(__dirname, "dist"), // 服务器运行的目录
        port: 9000
    },
        
// 3、运行脚本npm run server 脚本配置 "server":"webpack-dev-server"
```
~~~



## TreeShaking的配置？

**介绍**：treeShaking是一种按需引入功能的方式，它可以减少引入不必要或者没有引用的功能，增加代码的打包速度

**注意**：treeShaking只支持es6的模块引入方式

**配置步骤**（production模式下没必要配置因为已经配置好了，development模式下可以配置）

webpack.config.js文件下

```js
// mode为development
    // 在开发模式下配置treeShaking 但是在生产模式下已经配置好了没必要在配置
    optimization: {
        usedExports: true
    },
```

**注意：**如果遇到一些你不想去使用treeShaking（或者说仅仅是引入而不用去使用的比如一些css文件或者babel/pofill）可以在package.json文件下

```js
{	
    // 可以为false 或者写入你不想要去treeShaking的文件
  "sideEffects": [
    "./src/some-side-effectful-file.js"
  ]
}

```



## 代码分割（CodeSpliting）的配置？

webpack实现JS代码分割有两种方式：同步代码分割、异步代码分割

只需要配置

```js
optimization：{
	splitChunks:{
		chunks:"all"  // 代码分割的类型 async异步 initial同步 all全都分割，同步分割需要配合chcheGroups的vendors选项
}
```

splitChunks里面有多个参数，最主要的出来chunks之外还有一个cacheGroup的参数（当代码分割同步的时候）里面有两个vendors和default，分别对应的是第三方插件的代码分割和除了第三方插件的代码分割

```js
splitChunks: {
    // 代码分割的类型 async异步 initial同步 all全都分割，同步分割需要配合chcheGroups的vendors选项
    chunks: "async", 
    // 分割的最小占用内存
    minSize: 30000,
    // 当一个模块至少用了多少次才进行代码分割
    // 比如这里的意思是当有一个js文件需要引入目标分割文件时就需要被分割
    minChunks: 1,
    //按需加载时并行请求的最大数量 也就是最多进行5次
    maxAsyncRequests: 5,
    //入口点的最大并行请求数
    maxInitialRequests: 3,
    // 分割后文件名连接符
    automaticNameDelimiter: '~',
    name: true,
    // 分割同步代码时的走的方向
    cacheGroups: {
        // 同步分割
        vendors: {
            // 将所有node_modules的插件都打包在这个vendors里面
            // 符合node_modules模块里面的
            test: /[\\/]node_modules[\\/]/,
                // 优先级与vendors对比（都符合的情况下）
            priority: -10
            // 可以配置分割后的文件名 vendors.js
            // filename:'vendors.js'
        },
        // 如果不是第三方插件的情况下
    default: {
            minChunks: 2,
                // 优先级与vendors对比（都符合的情况下）
            priority: -20,
                // 如果一个模块已经被引入了，那么忽略这个模块
            reuseExistingChunk: true
        }
    }
}
```



## 讲一讲proxy的代理？

实现proxy请求转发

​	介绍：在开发环境中可以使用webpack内置的devServer可以便于我们构建一个服务器协助开发，而devServer中的配置proxy是帮助我们实现跨域代理转发请求，让我们可以访问到后台服务器的api

```js
        proxy: {
            // 这里的意思是当访问这个/api的时候事实上就是加上前缀http://www.hyt.com
            //请求到 /api/xxx 现在会被代理到请求 http://www.hyt.com/api/xxx, 例如 /api/user 现在会被代理到请求 http://www.hyt.com/api/user
            // '/api': 'http://www.hyt.com'
            '/api': {
                //如果你想要代码多个路径代理到同一个target下, 你可以使用由一个或多个「具有 context 属性的对象」构成的数组
                context: ['/auth', '/api'],
                target: 'http://www.hyt.com',
                // 这个意思是当访问路劲中有header.json改写成demo.json
                // 如果是 /api : '' 意思就是将这个改成空 
                changeOrigin:true,  // 解决跨域
                pathRewrite: {
                    "header.json": "demo.json",
                     // 这里的api请求发出去是会变成""
                     "/api" : ''
                }
            }
        }
```





# @@Git@@

## 常用命令

```js
git add . // 实际上就是把文件修改添加到暂存区；
git commit -m //'实际上就是把暂存区的所有内容提交到当前分支。
git status // 查看修改状态
git diff （文件名） // 查看文件名修改的不同地方位置
git log  // 查看日志版本改变
git reset --hard HEAD^ // 回退上个版本号 HEAD是当版本 HEAD^是上一个版本
git reset --hard 0754c9 // 回退上个版本号后 想要回到之前的版本 可以使用这个命令， 但前提是知道git log 后那个git版本的id好0754c9就是id号
git reflog // 用来记录你的每一次命令
git checkout -- 文件名 // 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。

git checkout -b dev || git switch -c dev // 创建分支dev
git branch // 命令查看当前分支
git checkkout 分支名 || git switch 分支名// 切换分支
git branch -d dev // 删除分支

git merge 分支名 // 表示需要合并的分支名 
git merge --no--ff -m '内容' 分支名 // 合并分支和上面个一样 区别是--no--ff表示禁用Fast forward模式
 //加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。
```



**合并远程分支**

```js
// 1.首先创建一个本地的dev分支
git branch dev
// 2.切换dev分支，将远程dev分支拉取
git switch dev 
git pull origin origin/dev  // 拉取
// 3.切换master分支，合并dev分支，解决冲突，推送上去
git switch master
git merge dev
git commit -m "更新"
git push origin master
```



# @@微信小程序@@



## 微信小程序的生命周期有哪些（全局5种、页面8种、组件生命周期6种、组件所在页面生命周期3种）

**全局App生命周期**

```js
App({
  onLaunch (options) {
    // 
    console.log('小程序初始化')
 
  },
  onShow(options) {
    console.log('监听小程序启动或切前台')
  },
  onHide() {
    console.log('监听小程序切后台')
  },
 
  onError(msg) {
    console.log('错误监听函数')
  },
  onPageNotFound(res) {
    console.log('小程序要打开的页面不存在时触发');
    wx.redirectTo({ // 重定向
      url: 'pages/...'
    }) // 如果是 tabbar 页面，请使用 wx.switchTab
  }
})
```

**页面内生命周期**

```js
Page({
 
  /**
   * 页面的初始数据
   */
  data: {
 
  },
 
  /**
   * 生命周期函数--监听页面加载
   * 一个页面只会调用一次，可以在onLoad中获取当前页面从上一级页面带过来的参数
   */
  onLoad: function (options) {
 
  },
 
  /**
   * 生命周期函数--监听页面初次渲染完成
   * 一个页面只会调用一次，代表当前页面已经准备妥当，可以和视图层进行交互
   */
  onReady: function () {
 
  },
 
  /**
   * 生命周期函数--监听页面显示
   * 每次打开页面都会调用一次，如果需要每次进入页面时刷新数据，可在此方法中实现
   */
  onShow: function () {
 
  },
 
  /**
   * 生命周期函数--监听页面隐藏
   * 当navigateTo或底部tab切换时调用
   */
  onHide: function () {
 
  },
 
  /**
   * 生命周期函数--监听页面卸载
   * 当redirectTo或navigateBack的时候调用
   */
  onUnload: function () {
 
  },
 
  /**
   * 页面相关事件处理函数--监听用户下拉动作
   */
  onPullDownRefresh: function () {
 
  },
 
  /**
   * 页面上拉触底事件的处理函数
   */
  onReachBottom: function () {
 
  },
 
  /**
   * 用户点击右上角分享
   */
  onShareAppMessage: function () {
 
  }
})
```

组件生命周期

```js
// pages/myComponent.js
Component({
  /**
   * 组件的属性列表
   */
  properties: {
 
  },
 
  /**
   * 组件的初始数据
   */
  data: {
 
  },
 
  /**
   * 组件的方法列表
   */
  methods: {
 
  },
 
  /*组件生命周期*/ 
  lifetimes: {
    created() {
      console.log("在组件实例刚刚被创建时执行")
    },
    attached() { 
      console.log("在组件实例进入页面节点树时执行")
    },
    ready() {
      console.log("在组件在视图层布局完成后执行")
    },
    moved() {
      console.log("在组件实例被移动到节点树另一个位置时执行")
    },
    detached() {
      console.log("在组件实例被从页面节点树移除时执行")
    },
    error() {
      console.log("每当组件方法抛出错误时执行")
    },
    /*组件所在页面的生命周期 */
    pageLifetimes: {
      show: function () {
        // 页面被展示
        console.log("页面被展示")
      },
      hide: function () {
        // 页面被隐藏
        console.log("页面被隐藏")
      },
      resize: function (size) {
        // 页面尺寸变化
        console.log("页面尺寸变化")
      }
    }
  }
})
```





## OpenId和UnionId的区别

**openid同一用户同一应用唯一，unionid同一用户不同应用唯一。**

这里的不同应用是指在同一微信开发平台下的不同应用

为了识别用户，每个用户针对每个公众号会产生一个安全的openid。

如果需要在多公众号、移动应用之间做用户共通，则需要前往微信开放平台，将这些公众号和应用绑定到一个开放平台账号下，绑定后，一个用户虽然对多个公众号和应用有多个不同的openid，但他对所有这些同一开放平台账号下的公众号和应用，只有一个unionid。一个微信开放平台只可以绑定10个公众号。

**总结：**

`OpenId` 是一个用户对于一个小程序／公众号的标识，开发者可以通过这个标识识别出用户。

`UnionId` 是一个用户对于同主体微信小程序／公众号／APP的标识，开发者需要在微信开放平台下绑定相同账号的主体。开发者可通过UnionId，实现多个小程序、公众号、甚至APP 之间的数据互通了。

**获取用户的openid是无需用户同意的，获取用户的基本信息则需要用户同意**



## 微信小程序的关键api有哪些？

- [`wx.login`](https://developers.weixin.qq.com/miniprogram/dev/api/api-login.html) 官方提供的登录能力

- [`wx.checkSession`](https://developers.weixin.qq.com/miniprogram/dev/api/signature.html#wxchecksessionobject) 校验用户当前的session_key是否有效

- [`wx.authorize`](https://developers.weixin.qq.com/miniprogram/dev/api/authorize.html) 提前向用户发起授权请求

  ```js
  // 可以通过 wx.getSetting 先查询一下用户是否授权了 "scope.record" 这个 scope
  wx.getSetting({
    success(res) {
      if (!res.authSetting['scope.record']) {
        wx.authorize({
          scope: 'scope.record',
          success () {
            // 用户已经同意小程序使用录音功能，后续调用 wx.startRecord 接口不会弹窗询问
            wx.startRecord()
          }
        })
      }
    }
  })
  ```

  

- [`wx.getUserInfo`](https://developers.weixin.qq.com/miniprogram/dev/api/api-login.html) 获取用户基本信息

- **wx.previewImage**   在新页面中全屏预览图片。预览的过程中用户可以进行保存图片、发送给朋友等操作。



## 小程序的渲染逻辑

在渲染层将 `WXML` 先转换为 `js` 对象也就是虚拟 `DOM`

在逻辑层将虚拟 `DOM` 对象生成真实 `DOM` 树，交给渲染层渲染

当视图有数据需更新时，逻辑层调用小程序宿主环境提供的 `setData` 方法将数据从逻辑层传递到渲染层

经过对比前后差异 ( diff算法 )，把差异应用在真实的 `Dom` 树上，渲染出正确的 UI 界面完成视图更新



## 小程序和H5的区别

参考：https://juejin.im/post/5e7e2cd86fb9a03c7d3ceb0c#heading-9

**运行环境方面**

**运行机制**

**系统权限**

**渲染机制**



## 微信小程序 session_key 的作用是什么

A.session_key 有两个作用：

1. 校验用户信息(wx.getUserInfo(OBJECT)返回的signature);
2. 解密(wx.getUserInfo(OBJECT)返回的encryptedData);

B.按照官方的说法，wx.checksession是用来检查 wx.login(OBJECT) 的时效性，判断登录是否过期;

疑惑的是（openid，unionid ）都是用户唯一标识，不会因为wx.login(OBJECT)的过期而改变，所以要是没有使用wx.getUserInfo(OBJECT)获得的用户信息，确实没必要使用wx.checksession()来检查wx.login(OBJECT) 是否过期；

如果使用了wx.getUserInfo(OBJECT)获得的用户信息，还是有必要使用wx.checksession()来检查wx.login(OBJECT) 是否过期的，因为用户有可能修改了头像、昵称、城市，省份等信息，可以通过检查wx.login(OBJECT) 是否过期来更新着些信息；





## 小程序的传值方式有什么？

参考：https://www.jianshu.com/p/287ab6081153

1、url传值

2、全局传值

3、页面自定义传值

4、form表单传值

5、页面路由栈中直接获取和操作目标Page对象传值

## 小程序的wxss和css有什么不同？

1、像素单位的不同rpx 以iphone6为例 750rpx = 325px 

2、可以通过@import方式导入外部样式



## 微信小程序与vue区别

**生命周期不一样**，微信小程序生命周期比较简单

**数据绑定也不同**，微信小程序数据绑定需要使用`{{}}，vue` 直接使用v-bind（或者：）

**控制元素的显示和隐藏**，小程序中，使用`wx-if`和`hidden` 控制元素的显示和隐藏，vue`中，使用 `v-if`和 `v-show`

**事件处理不同**，小程序中，全用  `bindtap(bind+event)`，或者  `catchtap(catch+event)`绑定事件,vue：使用`v-on:event` 绑定事件，或者使用`@event`绑定事件

**数据双向绑定**也不一样在 `vue`中,只需要再表单元素上加上 `v-model`,然后再绑定 `data`中对应的一个值，当表单元素内容发生变化时，`data`中对应的值也会相应改变，这是 `vue`非常 `nice` 的一点。微信小程序必须获取到表单元素，改变的值，然后再把值赋给一个 `data`中声明的变量。



## 怎么解决小程序的异步请求问题

小程序里面的api有很多是异步请求的比如：wx.request方法，当我们去网络请求的时候，如果网络请求太慢就直接执行下一段代码，会发生错误，那么就要使用promise来控制，当然也可以使用async和await，这样就可以确保网络请求完成在执行后面的代码



## 如何实现下拉刷新

首先在全局 `config` 中的 `window`配置 `enablePullDownRefresh` ，在 `Page` 中定义`onPullDownRefresh` 钩子函数,到达下拉刷新条件后，该钩子函数执行，发起请求方法 请求返回后，调用`wx.stopPullDownRefresh`停止下拉刷新



## bindtap和catchtap的区别是什么

他们的不同点主要是`bindtap`是不会阻止冒泡事件的，`catchtap`是阻值冒泡的



## 小程序wxml与标准的html的异同？

```
相同：
```

- 都是用来描述页面的结构；
- 都由标签、属性等构成；

```
不同：
```

- 标签名字不一样，且小程序标签更少，单一标签更多；
- 多了一些`wx:if` 这样的属性以及 `{{ }}`这样的表达式
- WXML仅能在微信小程序开发者工具中预览，而`HTML`可以在浏览器内预览；
- 组件封装不同， `WXML`对组件进行了重新封装，
- 小程序运行在`JS Core`内，没有`DOM树`和`window`对象，小程序中无法使用`window`对象和`document`对象。



## 小程序对wx:if 和 hidden使用的理解？

- `wx:if`有更高的切换消耗。
- `hidden` 有更高的初始渲染消耗。
- 因此，如果需要频繁切换的情景下，用 `hidden` 更好，如果在运行时条件不大可能改变则`wx:if` 较好。



## app.json 是对当前小程序的全局配置，讲述三个配置各个项的含义？

- \```pages字段`` —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。
- `window字段` —— 小程序所有页面的顶部背景颜色，文字颜色定义在这里的
- `tab字段`—小程序全局顶部或底部`tab`



## 小程序onPageScroll方法的使用注意什么？

由于此方法调用频繁，不需要时，可以去掉，不要保留空方法，并且使用`onPageScroll`时，尽量避免使用`setData()`，尽量减少`setData()`的使用频次。



## 小程序同步API和异步API使用时注意事项？

`wx.setStorageSync`是以Sync结尾的API为同步API，使用时使用`try-catch`来查看异常，如果判定API为异步，可以在其回调方法`success、fail、complete`中进行下一步操作。



## 简述下 `wx.navigateTo(), wx.redirectTo(), wx.switchTab(), wx.navigateBack(), wx.reLaunch()`的区别

- `wx.navigateTo()：`保留当前页面，跳转到应用内的某个页面。但是不能跳到 `tabbar` 页面
- `wx.redirectTo()：`关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 `tabbar` 页面
- `wx.switchTab()：`跳转到 `abBar` 页面，并关闭其他所有非 `tabBar` 页面
- `wx.navigateBack()：`关闭当前页面，返回上一页面或多级页面。可通过`getCurrentPages()` 获取当前的页面栈，决定需要返回几层
- `wx.reLaunch()：`关闭所有页面，打开到应用内的某个页面



# @@webSocket@@

## 什么是webSocket？

允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输

# @@项目总结@@

Hm





# @@简单介绍一下登录流程有什么？@@



cookie和session登录方式

token登录方式

sso单点登录

**oAuth第三方登录方式（重点）**

具体可以参考阮一峰老师的oAuth登录方式

oAuth的登录方式有四种







# @@源码



## vue相关

### 1、diff算法

**为什么加key会提高diff计算速度。**

  经过旧头新头、旧尾新尾、旧头新尾、旧尾新头四次交叉比对后，都没有匹配到值得比对的节点，这时如果新节点有key的话。可以通过map直接获得值得对比的旧节点的下标，如果没有key的话，就要通过循环旧节点数组用sameVnode方法判断新节点和该旧节点是否值得比较，值得就返回该旧节点的下标。显然通过map比通过循环数组的计算速度来的快。

**什么是diff算法？**

  对于渲染watcher触发时会执行`vm._update(vm._render(), hydrating)`，在`vm._undata`方法中会调用`vm.__patch__`，而`vm.__patch__`指向patch方法，diff计算是指在调用patch方法开始，用sameVnode方法判断节点是否值得比较，若不值得直接新节点替换旧节点后结束。值得对比进入patchVnode方法，分别处理一下几种情况，若新旧节点都有文本节点，新节点下的文本节点直接替换旧节点下的文本节点，如果新节点有子节点，旧节点没有子节点，那么直接把新节点查到旧节点的父级中，如果新节点没有子节点，旧节点有子节点，那么旧节点的父级下的子节点都删了。如果新旧节点都有子节点，进入updateChildren方法，通过旧头新头、旧尾新尾、旧头新尾、旧尾新头四次交叉比对，如果值得对比再进入patchVnode方法，如果都不值得对比，有key用map获得值得对比的旧节点，没有key通过循环旧节点获得值得对比的旧节点。当新节点都对比完，旧节点还没对比完，将还没对比完的旧节点删掉。当旧节点都对比完，新节点还没对比完，将新节点添加到最后一个对比过的新节点后面，完成diff计算。










