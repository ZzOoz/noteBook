# .:curry::curry:HTML:curry::curry:

## 行内元素有哪些？块级元素有哪些？空(void)元素有那些？行内元素和块级元素有什么区别？

行内元素有：`a b span img input select strong`

块级元素有：`div ul ol li dl dt dd h1 h2 h3 h4… p`

空元素：`<br> <hr> <img> <input> <link> <meta>`

行内元素不可以设置宽高，不独占一行

块级元素可以设置宽高，独占一行



## html5新增的语义化标签

article、section、header、footer、aside、time等

# :rice_ball::rice_ball:CSS:rice_ball::rice_ball:

## dispaly:none 和 visibility:hidden

dispaly:none 设置该属性后，该元素下的元素都会隐藏，占据的空间消失。
visibility:hidden 设置该元素后，元素虽然不可见了，但是依然占据空间的位置。

**区别： display:none会引起回流(重排)和重绘 visibility:hidden会引起重绘**



## 标准盒模型（content-box）和IE盒模型（怪异盒模型）（border-box）的区别

W3C标准下padding、border所占的空间不在width、height范围内，而IE盒模型width包括content尺寸＋padding＋border的总和

用处：当使用布局时，可以使用border-box对padding进行更改，他的width会在内部更改而不会在外部更改（避免被撑开），如果使用margin的话可能会引起很多不必要的布局麻烦



## 如何将一个按钮始终在屏幕的底部？

```css
.btn{
	position：fixed;
	left:0;
	bottom:0;
	width:100%
}
```



## Css选择器优先级

**优先级：*内联样式 > ID选择器 > 类选择器 = 属性选择器 = 伪类选择器 > 元素选择器 = 关系选择器 = 伪元素选择器 > 通配符选择器**

**!important的优先级是最高的**

## CSS常用选择器

```
通配符：*
ID选择器：#ID
类选择器：.class
元素选择器：p、a    等
后代选择器：p span、div a   等
伪类选择器：a:hover 等
属性选择器：input[type="text"]  等
```



## link和@import区别

**1.从属关系区别**

@import是 CSS 提供的语法规则，只有导入样式表的作用；link是HTML提供的标签，不仅可以加载 CSS 文件，还可以定义 RSS、rel 连接属性等。

**2.加载顺序区别**

加载页面时，link标签引入的 CSS 被同时加载；@import引入的 CSS 将在页面加载完毕后被加载。

**3.兼容性区别**

@import是 CSS2.1 才有的语法，故只可在 IE5+ 才能识别；link标签作为 HTML 元素，不存在兼容性问题



## 如何创建块级格式化上下文(block formatting context),`BFC`有什么用

非常感谢：https://www.jianshu.com/p/0fb2f90418c3

**什么是`BFC`**?

- `BFC`格式化上下文，它是一个独立的渲染区域，让处于 `BFC`内部的元素和外部的元素相互隔离，使内外元素的定位不会相互影响



**创建BFC**

1. float的值不是none。
2. position的值不是static或者relative。
3. overflow的值不是visible。
4. display的值是inline-block、table-cell、flex、table-caption或者inline-flex。

**BFC的作用**

1. 利用BFC避免margin重叠
2. 自适应两栏布局
3. 清除浮动
4. BFC最大的一个作用就是：在页面上有一个独立隔离容器，容器内的元素和容器外的元素布局不会相互影响



## CSS3动画（简单动画的实现，如旋转等）

- 依靠`CSS3`中提出的三个属性：`transition、transform、animation`
- `transition`：定义了元素在变化过程中是怎么样的，包含`transition-property、transition-duration、transition-timing-function、transition-delay`。
- `transform`：定义元素的变化结果，包含`rotate、scale、skew、translate`。
- `animation`：动画定义了动作的每一帧（`@keyframes`）有什么效果，包括`animation-name，animation-duration、animation-timing-function、animation-delay、animation-iteration-count、animation-direction`



## Css3伪类选择器before和after中添加图片

参考：https://www.cnblogs.com/qq976864507/p/11765513.html

```css
.box:before{
    content:"";
    background:url("doorImg2.png") no-repeat;
    background-size: 19px 24px;
    width:19px;
    height:24px;
    position:absolute;
    left:20px;
    top:25%;
}
```

​	**注意**：因为直接用content不能控制图片大小，所以把图片变成背景图片，然后用background-size就能控制图片大小了。这里width:30px;height:30px;也是必要的，不然图片也是不能显示出来，因为content为空就相当于没有宽度，背景图片是不能被渲染出来的。display：inline-block可以换成block，不过效果的话图片就会跑到下一行，但不能没有这个display样式。（我这里没有写也没有发现有什么问题）还有background-size不要不写，如果不明确background-size，但又保留了width和height，那图片只能显示其中的一部分



## box-shadow阴影详解

## 语法

box-shadow: *h-shadow v-shadow blur spread color* inset;

**注意：**boxShadow 属性把一个或多个下拉阴影添加到框上。该属性是一个用逗号分隔阴影的列表，每个阴影由 2-4 个长度值、一个可选的颜色值和一个可选的 inset 关键字来规定。省略长度的值是 0。

| 值         | 说明                                                         |
| :--------- | :----------------------------------------------------------- |
| *h-shadow* | 必需的。水平阴影的位置。允许负值                             |
| *v-shadow* | 必需的。垂直阴影的位置。允许负值                             |
| *blur*     | 可选。模糊距离                                               |
| *spread*   | 可选。阴影的大小                                             |
| *color*    | 可选。阴影的颜色。在[CSS颜色值](https://www.runoob.com/cssref/css_colors_legal.aspx)寻找颜色值的完整列表 |
| inset      | 可选。从外层的阴影（开始时）改变阴影内侧阴影                 |



## css垂直居中的方法

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        .out{
            width: 300px;
            height: 300px;
            background-color: pink;
            position: relative;
        }
        .inner{
            width: 100px;
            height: 100px;
            background-color: blue;
            position:absolute;
            /* 第一种 */
            /* top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            margin: auto; */
            
            /* 第二种 */
            /* margin-left: -50px;
            margin-top: -50px;
            left: 50%;
            top: 50%; */

            /* 第三种 */
            /* left:calc(50% - 50px);
            top:calc(50% - 50px); */

            /* 第四种 */
            /* left:50%;
            top:50%;
            transform: translate(-50%,-50%); */


        }
    </style>
</head>

<body>
    <div class="out">
        <div class="inner">12345</div>
    </div>
</body>

</html>
```



# :poultry_leg::poultry_leg:JavaScript:poultry_leg::poultry_leg:



## 前端代码复用的几种方式

- 1）函数封装
- 2）继承
- 3）复制extend
- 4）混入mixin
- 5）借用apply/call



## js面向对象编程思想和面向函数编程思想

参考：https://juejin.im/post/6844903917059309576#heading-5

**面向对象编程：**面向对象编程是用抽象方式创建基于现实世界模型的一种编程模式， 在 OOP 中，每个对象能够接收消息，处理数据和发送消息给其他对象。每个对象都可以被看作是一个拥有清晰角色或责任的独立小机器

面向对象的特点：继承、多态、封装

继承：**继承是面向对象一个特点，可以实现子类调用自己没有的属性方法【父类属性方法】**

多态：**多态是面向对象一个特点，可以实现子类有不同对表现形态，可以实现同一种表现形式，可以有不同对状态**

封装：**封装是面向对象一个特点，将属性和方法封装这对象中，可以利用私有或者公有属性，对外提供可以访问的方法或属性**



## 介绍一下 JS 的基本数据类型和引用类型

基本数据类型：String、Number、Boolean、null、undefined、Symbol、BigInt

引用类型：Object、Function、Array、Date等



## typof运算符能判断那些类型？ 

（undefined、string、number、boolean、symbol、function、object）

​	答：能判断所有的值类型、识别函数、判断是否为引用类型（引用类型中有array和obj、null不能细分）



## call和apply的作用是什么？区别是什么？

call和apply的作用都是显式改变this指向、他们的区别是call第一个参数后面接收多个参数、apply接收一个数组

**apply的妙用**

```js
// 第一个参数为null时,指向window（call,apply,bind都是如此）
Math.max.apply(null,array)  // 获取数组中的最大值
Math.min.apply(null,array)  // 获取数组中的最小值


// 合并数组
const arr1 = [1,2,3]
const arr2 = [4,5,6]
const arr3 = Array.prototype.push.apply(aar1,arr2)
console.log(arr3) // [1,2,3,4,5,6]
```



## bind的使用

在 MDN 上的解释是：bind() 方法创建一个新的函数，在调用时设置 this 关键字为提供的值。并在调用新函数时，将给定参数列表作为原函数的参数序列的前若干项。
它的语法如下：

```js
Function.bind(thisArg[, arg1[, arg2[, ...]]])
```

bind 方法 与 apply 和 call 比较类似，也能改变函数体内的 this 指向。不同的是，**bind 方法的返回值是函数，并且需要稍后调用，才会执行**。而 apply 和 call 则是立即调用。
来看下面这个例子：

```js
function add (a, b) {
    return a + b;
}
function sub (a, b) {
    return a - b;
}
add.bind(sub, 5, 3); // 这时，并不会返回 8
add.bind(sub, 5, 3)(); // 调用后，返回 8
```

**如果 bind 的第一个参数是 null 或者 undefined，this 就指向全局对象 window。**

**总结：**

call 和 apply 的主要作用，是改变对象的执行上下文，并且是立即执行的。它们在参数上的写法略有区别。
bind 也能改变对象的执行上下文，它与 call 和 apply 不同的是，返回值是一个函数，并且需要稍后再调用一下，才会执行。



## window.onload和DOMCotentLoaded的区别

onLoad会等到DOM结构、图片、视频加载完成后执行；

DOMCotentLoaded会等到DOM结构加载完成后就立刻执行



## 渲染页面的过程

1. 用户输入url地址，浏览器根据域名寻找IP地址
2. 浏览器向服务器发送http请求，如果服务器段返回以301之类的重定向，浏览器根据相应头中的location再次发送请求
3. 服务器端接受请求，处理请求生成html代码，返回给浏览器，这时的html页面代码可能是经过压缩的
4. 浏览器接收服务器响应结果，如果有压缩则首先进行解压处理，紧接着就是页面解析渲染

　　解析渲染该过程主要分为以下步骤：

1. 解析HTML
2. 构建DOM树s
3. DOM树与CSS样式进行附着构造呈现树
4. 布局(laytout)
5. 绘制(panting)



## 回流（重排 Reflow）和重绘（Repaint）

**重排：**DOM 结构中各个元素都有自己的盒子（模型），这些都需要浏览器根据各种样式来计算并根据计算结果将元素放到它该出现的位置，这个过程称为 reflow。

**什么时候触发重排？**

- 增加、删除、修改 DOM 节点时，会导致 Reflow 或 Repaint

- 移动 DOM 位置，或搞个动画时

- 修改 CSS 样式时、元素尺寸改变时；元素位置改变时；元素内容改变时；

- Resize 窗口（移动端没这个问题）或滚动的时候

- 修改网页默认字体时

  

**重绘：**当各种盒子的位置、大小以及其他属性，例如颜色、字体大小等都确定之后，浏览器把这些元素按照各自的特性绘制了一遍，于是页面内容出现了，这个过程称之为 repaint

**什么时候触发重绘？**

元素背景颜色的改变、字体颜色的改变、边框颜色的改变、透明度的改变等



#### **如何最小程度的 Repaint**

比如要添加多个 DOM 节点，一次性添加，而不要一个个添加。



**注意：当页面发生重排时一定会导致重绘，而重绘不一定导致重排**



## 为何要把css文件放在head标签中?为何要把js文件放在body标签最后?



## 前端性能优化（加载更快、渲染更快）

vue性能优化：https://juejin.im/post/6844903913410314247

1.让加载更快

​			1.1、减少资源体积：压缩代码（webpack打包压缩）

​			1.2、减少访问次数：合并代码（webpack打包）、SSR服务端渲染（减少ajax请求）、缓存

​			1.3、使用CDN

​	2.让渲染更快

​			2.1、CSS放在head中、js放在body最后

​			2.2、尽早执行js用DOMContentLoaded触发

​			2.3、懒加载

​			2.4、对DOM查询进行缓存、减少dom操作（合并到一起最后插入，使用文档片段）

​			2.5、节流防抖



## 闭包和自执行函数和自由变量

https://blog.csdn.net/weixin_42793426/article/details/81356337

https://www.cnblogs.com/libin-1/p/5955202.html

https://zhuanlan.zhihu.com/p/22486908

闭包：是可以访问另外一个作用域内部变量的函数

闭包常见的形式：作为函数返回和令函数作为参数传递

自由变量：一个变量在当前作用域没有被定义，但是被使用了会在**定义的地方向上级作用域**一层一层依次寻找，如果到全局作用域都没有被找到，会报undefined（注意是定义的地方）

自执行函数：自执行函数就是当它被定义出来，就会自动执行的函数。不需要调用，传参也很方便。

自执行函数有三种写法：

1. 　　( function ( “ 参数 ” ) { " 函数方法 " ; } ) ( “ 给参数传的值 ” )
2. 　　( function ( " 参数 " ) { “ 函数方法 ” ; } ( " 给参数传的值 " ) )
3. ​    ! function ( " 参数 " ) { " 函数方法 " ; } ( " 给参数传的值 " )　

```js
// 1.函数作为返回值
function print() {
    const a = 100
    return function() {
        console.log(a)
    }
}

const fn = print()
const a = 200
fn() // 100

// 2.函数作为参数传递
function print(fn) {
    const a = 100
    fn()
}

const a = 200
// 自由变量会在定义的地方一级一级网上寻找
// 自由变量会在创建函数的地方寻找对应的值
function fn() {
    console.log(a)
}

print(fn) // 200


//函数赋值
//3.一种变形的形式是将内部函数赋值给一个外部变量
var inner;
var F = function(){
    var b = 'local';
    var N = function(){
        return b;
    };
    inner = N;
};
F();
console.log(inner());
```



## This指向?

9.1、this的指向是在函数执行的时候被确定的，不是在定义的时候被确定的（与自由变量不同）

9.2、this用于普通函数、对象引用、call和apply和bind、箭头函数、class中的this

9.3、以下是一些示例：

```js
// 关于this指向问题（window普通函数调用、call、apply、bind显示调用）

let x = 100

function fn() {
    console.log(this.x)
}

fn() // 作为普通函数被调用指向window x是100


fn.call({ x: 200 }) // 被显示调用（call、apply、bind）指向调用对象 x是200

let fn2 = fn.bind({ x: 300 })
fn2() // 被显示调用（call、apply、bind）指向调用对象 x是300
```

```js
// 关于this指向问题（对象隐式调用、箭头函数）
var name = 'hyt' // 如果是let name = 'hyt' sayName2()的值是undefined 因为let只对当前作用域生效
let obj = {
    name: 'jjj',
    // 作为对象隐式调用 this指向执行时候的对象
    sayName() {
        console.log(this.name, '111') 
    },
    // 实际执行的函数是setTimeout里面的函数，执行时（this指向是执行时候确定的）
    // 函数并没有对象调用，因此作为普通函数调用，指向window
    sayName2() {
        setTimeout(function() {
            console.log(this.name, '222') 
        })
    },
    // 箭头函数this的指向他的上一级作用域的this，因为自身并没有this指向
    // 他的上级作用域是sayName3的作用域，sayName3的tihs指向obj 因此未jjj
    sayName3() {
        setTimeout(() => {
            console.log(this.name, '333') 
        })
    }
}

obj.sayName()// jjj
obj.sayName2()// hyt
obj.sayName3()// jjj
```



## New具体做了什么(var obj = new Base())

(1) 创建一个新对象；**var obj = {}
(2) 将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象） ；obj.proto = Base.prototype;** **Base.call(obj);**
(3) 执行构造函数中的代码（为这个新对象添加属性） ；
(4) 返回新对象。



## truely和falsely变量

```js
// 以下是falsely变量 除此以外都是truely变量
!!0 === false
!!NaN === false
!!'' === false
!!null === false
!! undefined === false
!! false === false
```

 

## 判断变量类型（typeof（6种）、instanceof   Object.prototype.toString.call）

instanceof：测试一个对象是否为一个类的实例

typeof能判断的类型有:**（undefined、string、number、boolean、symbol、function、object）**



## 原型链和原型和继承?

参考：https://www.jianshu.com/p/be7c95714586

**原型：**每一个JavaScript对象(null除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型"继承"属性。

**原型链：**当我们去访问一个属性的时候，我们首先会从这个对象本身去寻找，如果找不到会从他的原型对象上面找，也就是Prototype属性，如果还是找不到，我们会从他所继承的原型对象上面寻找，直至Object.prototype.proto上面寻找，如果还是找不到那么就会显示错误，而这一条链式寻找属性就是原型链

**继承：**实质上就是一个原型对象引用另外一个原型对象上的属性和方法



## new Object() 和 Object.create()的区别

{}相当于new Object(),创建了之后会有Object.prototype原型

Object.create(null)创建是没有原型的，如果参数不是null，那么这个参数会作为新创建对象的原型





## Split和join的区别

答：split是通过参数来对字符串进行划分返回一个数组，join是通过参数对数组进行连接成字符串

```js
'1-2-3'.split('-') // [1,2,3]
[1,2,3].join('-') // '1-2-3'
```





## 说说数组api？那些是数组纯函数？那些不是？

**1.关于push、pop、unshift、shift**

push：向数组最后添加一个新元素、返回添加元素后一个数组的长度、改变原数组，参数是新元素

pop：向数组最后删除一个元素，返回数组删除的元素，改变原数组，无参数

unshift：向数组前面添加一个新元素、返回添加元素后一个数组的长度、改变原数组，参数是新元素

shift：向数组前面删除一个新元素、返回数组删除的元素，改变原数组，无参数

**2.数组纯函数（不改变原数组，返回一个数组）**

***属于纯函数的有：***

concat：拼接一个数组，生成一个新的数组，不改变原数组，参数是新的数组

slice（切片）：截取一个数组，生成新数组，不改变原数组，参数是 start 和 end （不包括该元素）的 arrayObject 中的元素。

map和filter也是数组纯函数

***不属于纯函数的有：***

forEach、some、every（不返回数组）

splice（剪接）、push、pop、unshift、shift（改变原数组）





## slice和splice的用法和区别?

slice为纯函数（不改变数组和返回数组）、splice不是纯函数

```js
// array-api slice
const res = [1, 2, 3, 4, 5]

const res1 = res.slice(1, 3) // 从1开始切片，到3位置不包括3返回一个新数组 [2,3]
const res2 = res.slice() // 返回一个新数组 [1,2,3,4,5]
const res3 = res.slice(1) // 从1开始切片，到最后  [2,3,4,5]
const res4 = res.slice(-2) // 从末尾开始算，切倒前两个 [4,5]

// array-api splice
const arr1 = res.splice(1, 2, ['a', 'b', 'c']) // 从1开始删除2个，添加[a,b,c]数组 最后原数组结果：[1,[a,b,c],4,5]，返回结果：[2,3]
const arr2 = res.splice(0, 2) // 0开始删除两个，最后原数组结果:[3,4,5] arr2的结果：[1.2]
const arr3 = res.splice(0) // 从0开始剪掉到最后 改变原数组  最后原数组结果:[]   arr3:[1,2,3,4,5]
```



## 列举强制转换和隐式类型转换

答：1.强制类型转换：parseInt、parseFloat、toString等

​		2.隐式类型转换：==、字符串拼接、逻辑运算if/else



## innerHTML和outerHTML的区别

innerHTML(元素内包含的内容）

outerHTML(自己以及元素内的内容）

```html
 //1.innerHTML

<body>
		<p>你好</p>
		<div id="test"><h5>就是喜欢你</h5></div>
		<script type="text/javascript">
			var hj=document.getElementById("test").innerHTML;
			alert(hj);
		</script>
</body>
 
输出结果：
 
<h5>就是喜欢你</h5>

//2.outerHTML 

<body>
		<p>你好</p>
		<div id="test"><h5>就是喜欢你</h5></div>
		<script type="text/javascript">
			var kj=document.getElementById("test").outerHTML;
			alert(kj);
		</script>
</body>
 
输出结果：
 
<div id="test"><h5>就是喜欢你</h5></div>
```



## 深拷贝和浅拷贝

**深拷贝的方式：**

1、json.parse(json.stringify(obj)) 先变成字符串再变成对象，这种方式的缺点是不能深拷贝funciton、正则、null等类型 乞丐版深拷贝

2、使用递归的方式深拷贝

```js
//1.json两种方法
//另一种深拷贝的方法是使用stringify和parse
// 但是缺点就是不能拷贝undefined ， function， RegExp 等等类型的
function deepCloneJson(obj){
    return JSON.parse(JSON.stringify(obj))
}

// 2.使用递归的方法
function deepClone(obj){
    // 这里判断是否为值类型
    // 判断是否不为对象或者等于null 如果成立直接返回值，如果不是对象则代表是值类型，null也是可以直接返回
    if(typeof obj !== 'object' || obj == null){
        return obj
    }
	
    // 新建变量
    let result
    if(obj instanceof Array){
        result = []
    }else{
        result = {}
    }
	
    // 遍历操作 递归赋值
    for (const key in obj) {
        if (obj.hasOwnProperty(key)) {
            result[key] = deepClone(obj[key])
        }
    }
    return result
}

let obj1 = {
    name: 'Yuteng',
    age: 12,
    class: ['a', 'b', 'c'],
    deee: {
        beijing: 'a'
    },
    Reg:/b/
}

const obj2 = deepCloneJson(obj1)
// console.log(obj2 === obj1)
console.log(obj2)
```

​						 

**浅拷贝的方式**：

参考：https://segmentfault.com/a/1190000018762510（注意这里的第二点解构赋值是错的，应该是扩展运算符）

**1、使用Object.assign方法**

```js
var obj1 = {a: 1, b: 2}
 
var obj2 = Object.assign({}, obj1)
 
obj2.a = 4
 
console.log(obj1, obj2)
```

**2、使用扩展运算符**

```js
var obj1 = {a: 1, b: 2}
 
var obj2 = {...obj1}
 
obj2.a = 4
 
console.log(obj1, obj2)
```



## offsetWidth offsetHeight和clientWidth clientHeight的区别

必看：https://blog.csdn.net/qq_35430000/article/details/80277587

必看：https://www.jianshu.com/p/7e9c5e56eb3f

(1)offsetWidth （content宽度+padding宽度+border宽度）

(2)offsetHeight（content高度+padding高度+border高度）

(3)clientWidth（content宽度+padding宽度）

(4)clientHeight（content高度+padding高度）



## 可视区域距离页面顶部的距离

documentElement代表是html节点

body代表body节点

scrollTop=document.documentElement.scrollTop||document.body.scrollTop





## 关于BOM对象

参考：https://www.jianshu.com/p/eac7f9dc3b17

BOM:是指浏览器对象模型（BOM是一套操作浏览器的API（接口/方法/属性）），它提供了一系列对象用于与浏览器窗口进行交互，这些对象通常统称为BOM。

 ![img](https://images2015.cnblogs.com/blog/449064/201509/449064-20150901201202388-1759134225.png)



## 事件冒泡和事件捕获以及事件委托（代理）

参考：https://blog.csdn.net/g291976422/article/details/88719975

参考：https://www.cnblogs.com/li-qiang-blog/p/10807078.html

![在这里插入图片描述](https://img-blog.csdnimg.cn/20190321170243220.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2cyOTE5NzY0MjI=,size_16,color_FFFFFF,t_70)

## 获取元素宽高的方法

参考：https://www.jianshu.com/p/eac7f9dc3b17

**总结**

1. 通过 offsetWidth 和 offsetHeight 获取的宽高包含 边框 + 内边距 + 元素宽高

   通过getComputedStyle(); / currentStyle / style 获取的宽高不包括边框和内边距

2. 通过 offsetWidth 和 offsetHeight / getComputedStyle(); / currentStyle 既可以获取行内宽高，也可以获取CSS设置的宽高
    通过style  可以获取行内宽高，但不可以获取CSS设置的宽高

3. 高级浏览器 getComputedStyle();  低级浏览器 通过currentStyle获取  高低级都支持：通过style获取 / offsetWidth 和 offsetHeight

4. style可以获取也可以设置 其他的只能获取



## 三大家族（重点）

https://blog.csdn.net/qq_41800366/article/details/85995432（scroll家族）

#### **offset家族**

 offsetWidth / offsetHeight ： 获取的宽高包含 边框 + 内边距 + 元素宽高
 offsetParent  ： 获取元素的第一个定位祖先元素 ，如果没有定位的则获取到的是body
 offsetLeft /offsetTop ：获取元素到第一个定位元素的偏移量，如果没有定位的则获取到的是到body的偏移量

##### **client家族**

 clientWidth / clientHeight ： 获取的宽高包含内边距 + 元素宽高
 clientLeft /clientHeight ： 获取 元素的 左边框 或者 顶部边框

##### **scroll家族**

 scrollWidth / scrollHeight ：当内容没超出元素范围时 获取的是 内边距 + 元素宽高
 当内容超出元素范围时  获取的是 内边距 + 元素宽高+超出的宽度
 scrollTop / scrollLeft ：Top获取的是内容超出顶部内边距的距离 Left获取的是内容超出左边内边距的距离

**（注意：scrollTop和scrollLeft的必须要配合overflow属性的设置，且overflow的值不能为visible，但可以为hidden,auto,scroll的之中，但是hidden最常见）**



## Event常见应用

参考：https://www.cnblogs.com/dqsBK/p/6287907.html

**1、event. preventDefault()**

取消事件的默认动作。

**2、event.stopPropagation()**

   阻止事件冒泡。

**3、event.stopImmediatePropagation()**

阻止剩下的事件处理程序被执行。如果一个元素上绑定了三个事件，在其中一个事件上调用了这个方法，那其他 的两个事件将不会被执行。



## instanceof 的原理

**instanceof 用于判断一个引用类型是否属于某构造函数；还可以在继承关系中用来判断一个实例是否属于它的父类型。**
**instanceof 的原理是判断实例对象的 `__proto__` 是否与构造函数的 `prototype` 指向同一个引用。**

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/a0e907fe756e4413bef916c35c4c2e2b~tplv-k3u1fbpfcp-zoom-1.image)



## Es5的继承

```js
// 1、借用构造函数继承
// 这种方式不能继承父类原型链上的属性，只能继承在父类显式声明的属性。
function Person(name){
    this.name = name
}
function Child(name,age){
    Person.call(this,name)
    this.age = age
}

const c1 = new Child('yt',12)
console.log(c1)



// 2、借用原型链继承
// 这种方法也有缺点，看 arr 属性是一个数组，如果创建两个实例对象 c2、c3，因为这两个实例对象的 arr 指向同一个引用，所以改变其中一个的值，另一个也会跟着改变。
function Person2(name){
    this.name = name
    this.arr = [1,2,3]
}

function Chlid2(age){
    this.age = age
}

Child2.prototype = new Person2('yt')
Child2.prototype.constructor = Child2
const c2 = new Chlid2(12)
console.log(c2)


// 3、借用组合继承
// 这种的缺点是进行两次的实例化父类构造函数
function Person3(name){
    this.name = name
    this.arr = [1,2,3]
}

Person3.prototype.sayName = function(){
    console.log(this.name)
}

function Chlid3(name,age){
    Person3.call(this,name)
    this.age = age
}

Child3.prototype = new Person3()
Child2.prototype.constructor = Child3
const c3 = new Child3('yt',12)
console.log(c3)


// 4、组合继承的优化
function Person4(name){
    this.name = name
    this.arr = [1,2,3]
}

Person4.prototype.sayName = function(){
    console.log(this.name)
}

function Chlid4(name,age){
    Person4.call(this,name)
    this.age = age
}

Chlid4.prototype = Object.create(Person4.prototype)
Child4.prototype.constructor = Child4

const c4 = new Child4('yt',333)
console.log(c4)
c4.sayName()
```



## ES5和ES6实现继承的区别是什么？

参考：https://blog.csdn.net/qq_42908794/article/details/83863886

　　ES5和ES6继承最大的区别就是在于：
　　　　1.ES5先创建子类，在实例化父类并添加到子类this中
　　　　2.ES6先创建父类，在实例化子集中通过调用super方法访问父级后，在通过修改this实现继承



## 为什么Js只能是单线程？

JavaScript的单线程，与它的用途有关。作为浏览器脚本语言，JavaScript的主要用途是与用户互动，以及操作DOM。这决定了它只能是单线程，否则会带来很复杂的同步问题。比如，假定JavaScript同时有两个线程，一个线程在某个DOM节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？这样就会带来问题



## 宏任务和微任务

这里需要注意的是new Promise是会进入到主线程中立刻执行，而promise.then则属于微任务

- 宏任务(macro-task)：整体代码script、setTimeOut、setInterval
- 微任务(mincro-task)：promise.then、promise.nextTick(node)



## EventLoop



## 提升页面性能的方法有哪些？

1. 资源压缩合并，减少 HTTP 请求
2. 非核心代码异步加载（异步加载的方式，异步加载的区别）
3. 利用浏览器缓存（缓存的分类，缓存原理）
4. 使用 CDN
5. 预解析 DNS



## 异步加载

#### **异步加载的方式**

1. 动态脚本加载
2. defer
3. async

#### **异步加载的区别**

1. defer 是在 HTML 解析完之后才会执行，如果是多个，按照加载的顺序依次执行。`defer`脚本会在`DOMContentLoaded`和`load`事件之前执行。
2. async 是在脚本加载完之后立即执行，如果是多个，执行顺序和加载顺序无关。`async`会在`load`事件之前执行，但并不能确保与`DOMContentLoaded`的执行先后顺序。




# :hamburger::hamburger:Js手写篇:hamburger::hamburger:

## 用代码实现一个 new 方法

```HTML
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>模拟new的过程</title>
    <link rel="stylesheet" href="">
</head>
<body>
    <script type="text/javascript" charset="utf-8" async defer>
        function Person(name, age){
            this.name = name;
            this.age = age;
        }

        //手动实现new
        function _new(){
            //1.拿到传入的参数中的第一个参数，即构造函数名Func
            var Func = [].shift.call(arguments)
            //2.创建一个空对象obj,并让其继承Func.prototype
            var obj = Object.create(Func.prototype)
            //第二步也可以这样写
            // var obj = {}
            // obj.__proto__ = Func.prototype
            //3.执行构造函数，并将this指向创建的空对象obj
            var ret = Func.apply(obj, arguments)
            //4.如果构造函数返回的值是对象则返回，不是对象则返回创建的对象obj
            return typeof ret === 'object' ? ret : obj
        }

        var p1 = _new(Person, 'bob', 19)
        console.log(p1)
    </script>
</body>
</html>
```

**(注意：[].shift.call()是什么意思？实际上可以就是指向argument截取argument的第一个参数，然后将arguments转化成数组)**

```js
//[].shift.call(arguments) 和 Array.prtotype.shift.call(arguments) 相同
// 可以看成两步
// 第一步
const arg = Array.from(arguments)
// 第二步
const Func = arg.shift(arg)
```



## 编写一个通用的事件绑定函数

参考：https://www.jianshu.com/p/52ba109c0815

```js
function bindEvent (ele, type, selector, fn) { // 加入选择器应对更多情况
      if (fn == null) {
            fn = selector
            selector = null
      }//当不使用selector时，把fn换到前面来

      ele.addEventListener(type, function (e) {
            //绑定事件，绑定时执行判断
            var target
            if (selector) {
                  //需要代理
                  target = e.target
                  if (target.matches(selector)) {
                        //判断，是否匹配选择器
                        fn.call (target, e)
                  }     //执行主体为e.target，所以要把函数给回它执行
            } else {
                  //不代理
                  fn(e)
            }
      })
}





function BindEvent(ele,type,selector,fn){
    if(fn == null){
        fn = selector
        selector = null
    }
    
    ele.addEventListener(type,function(){
		let target 
         if(selector){
             target = e.target
             if(target.matches(selector)){
                 fn.call(target,e)
             }
         }else{
             fn(e)
         }
    })
}
```



## 防抖和节流

防抖：在用户结束输入的最后一刻执行操作

防抖使用场景（例子）：监听一个输入框时，文字变化后触发change事件，但是如果直接用keyup事件，则会频繁触发change，用户体验不好，而防抖就可以在用户输入结束或暂停时，才会触发change事件

```js
// 关于防抖
let input1 = document.getElementById('input1')

// 设置定时器timer
// 每次触发keyup事件如果没有超过500ms都会清空timer重新计时
// 输入1 没有超过500ms就输入2 会重新清空timer直到超过500ms才会打印
let timer = null
input1.addEventListener('keyup', function() {
    if (timer) {
        clearTimeout(timer)
    }
    timer = setTimeout(() => {
        console.log(input1.value)
        timer = null
    }, 500)
})

//进一步封装
// 进行封装
function debounce(fn, delay = 500) {
    let timer = null
        // 返回一个函数（闭包）,将timer放入闭包内,使其无法在外部被修改
    return function() {
        if (timer) {
            clearTimeout(timer) // 存在即清空
        }
        timer = setTimeout(() => {
            console.log(this, 'input1')
            fn.apply(this, arguments) // 传参调用回调
            timer = null
        }, delay)
    }
}

const input1 = document.getElementById('input1')

input1.addEventListener('keyup', debounce(() => {
    console.log(this, '我是里面的')
    console.log(input1.value)
}, 1000))
```

节流：在用户频繁操作的时候保持一定的频率触发

节流使用场景：拖拽一个元素要随时拿到该元素被拖拽的位置，直接使用drag事件会频繁触发、很容易导致卡顿，使用节流无论拖拽速度有多快，都会每间隔100ms触发一次

```js
// 节流相关
let div1 = document.getElementById("div1")

let timer = null // 定义一个定时器 但是这个定时器可以被任意修改
div1.addEventListener('drag', function(e) {
    if (timer) {
        // 如果定时器存在返回，与防抖不同，防抖是结束触发，而节流是在间隔一个时间有规律触发
        return
    }

    timer = setTimeout(() => {
        console.log(e.offsetX, e.offsetY)
        timer = null // 重新定义定时器
    }, 100)
})


//进一步封装
// 节流工具函数进一步封装
function throttle(fn, delay = 100) {
    let timer = null // 闭包变量无法外部修改
    return function() {
        if (timer) {
            return
        }
        timer = setTimeout(() => {
            fn.apply(this, arguments)
            timer = null
        }, delay)
    }
}

div1.addEventListener('drag', throttle(function(e) {
    console.log(e.offsetX, e.offsetY)
}))
```



## 手写深度降维

```js
// 降维方法1
const arrs = [1, 2, [3, 4, [5, 6]]]
console.log(arrs)
console.log(flatten(arrs))

function flatten(arrs){
    const isFlatten = arrs.some((arr) => arr instanceof Array)

    if(!isFlatten){
        return arrs
    }

    const result = Array.prototype.concat.apply([],arrs)
    return flatten(result)
}


// 降维方法2
console.log(arr.flat(Infinity))
```



## 手写bind函数

```js
// 手写bind函数
Function.prototype.bind1 = function() {
    // 将参数变成一个数组
    const arg = Array.prototype.slice.call(arguments)

    // bind函数的第一个参数也就是要调用的对象,同时去掉数组第一个
    const that = arg.shift()

    // 拿到需要使用的函数 因为Function可以看作一个类
    // 而fn1可以看作是Funtion的实例化对象 所以this指向fn1
    console.log(this,'hhh')
    const self = this

    // 返回一个函数
    return function() {
        // 这里的arg是去掉之前数组第一个之后的
        return self.apply(that, arg)
    }
}

function fn1(a, b) {
    console.log("this", this)
    console.log(a, b)
    return 'bind function'
}

const fn2 = fn1.bind1({ x: 100 }, 200, 300)
console.log(fn2())
```



## 手写深度比较

```js
function isObject(obj){
    return typeof obj === 'object' && obj !== null
}
function isEqual(obj1,obj2){
    if(!isObject(obj1) || !isObject(obj2)){
        return obj1 === obj2
    }

    if(obj1 === obj2){
        return true
    }

    const obj1Keys = Object.keys(obj1)
    const obj2Keys = Object.keys(obj2)

    if(obj1Keys.length !== obj2Keys.length){
        return false
    }

    for (const key in obj1) {
        const res = isEqual(obj1[key],obj2[key])
        if(!res){
            return false
        }
    }
    return true
}

const obj1 = {
    a: 100,
    b: {
        x: 100,
        y: 200,
    }
}

const obj2 = {
    a: 100,
    b: {
        x: 100,
        y: 200
    }
}

console.log(isEqual(obj1, obj2))  // true
```



## 手写ajax

```js
function getAjax(){
    var xhr = new XMLHttpRequest();
    xhr.open('get','http://jsonplaceholder.typicode.com/posts')
    xhr.send(null)

    xhr.onreadystatechange = function(){
        if(xhr.status === 200 && xhr.readyState === 4){
            console.log(xhr.responseText)
        }
    }
}

function postAjax(){
    const name = '111'
    var xhr = new XMLHttpRequest()
    xhr.open('post','http://jsonplaceholder.typicode.com/posts')
    // 设置头部
    xhr.setRequestHeader("Content-Type","application/x-www-form-urlencoded");
    xhr.send("username="+name)
    xhr.onreadystatechange = function(){
        if(xhr.status === 200 && xhr.readyState === 4){
            console.log(xhr.responseText)
        }
    }
}
```





## 将类数组转化为数组的方法有哪些？

```js
// 1、使用Array.from方法
Array.from(document.querySelectorAll('div'))

// 2、使用Array.prototype.slice.call()
Array.prototype.slice.call(document.querySelectorAll('div'))

// 3、扩展运算符
[...document.querySelectorAll('div')]

// 4、利用concat
Array.prototype.concat.apply([], document.querySelectorAll('div'));
```



## 自行实现图片懒加载

```js
//可以给img标签统一自定义属性data-src='default.png'，当检测到图片出现在窗口之后再补充src属性，此时才会进行图片资源加载。

function lazyload(){
    // 获取图片元素数组
    const imgs = document.getElementByTagName('img')
    // 获取长度
    const len = imgs.length
    // 获取视窗高度
    const viewHeight = document.docuemntElement.clientHeight
    // 获取滚动条高度
    const scrollHeight = document.docuemntElement.scrollTop || document.body.scrollTop
    for(let i = 0;i < len;i++){
        // 获取图片元素距离顶部的距离
        const offsetHeight = imgs[i].offsetTop;
        // 滚动的时候如果视窗高度和滚动高度加起来大于元素距离顶部的距离,那么就意味着要加载图片了
        if(offsetHeight < viewHeight + scrollHeight){
            // 加载图片的时候在img中加上data-src自定义属性
            const src = imgs[i].dataset.src;
            imgs[i].src = src
        }
    }
}

// 这里可以使用节流优化，防止卡死
window.addEventListener('srcoll',lazyload)
```



## 渲染几万条数据不卡顿页面

```js
setTimeout(()=>{
    const total = 1000
    const once = 20;
    // 渲染的次数
    const loopRender = Math.ceil(total / once)
    // 已经渲染的次数
    let renderCount = 0;
    let ul = document.querySelector('ul')
    // 添加元素的函数
    function add(){
        // 新建文档片段
        let frag = document.createDocumentFragment()
        for(let i = 0; i < once; i++){
            let li = document.createElement('li');
            li.innerText = Math.random()
            // 插入文档片段中
            frag.appendChild(li)
        }
        // 插入到真实的Dom
        ul.appendChild(frag)
        // 已经渲染的次数加1
        renderCount += 1;
        loop()
    }
    function loop(){
        // 如果已经渲染的次数小于需要渲染的次数那么就继续调用requestAnimationFrame
        if(renderCount < loopRender){
            window.requestAnimationFrame(add)
        }
    }

    // 首次调用loop
    loop()
},0)
```



# :sushi::sushi:ES6:sushi::sushi:



## 前端模块化

参考：https://segmentfault.com/a/1190000015437724?utm_source=tag-newest

模块化：是指对逻辑层面的划分，将一个大的逻辑分成多个小的模块，一个模块就是一个文件

前端模块化的方案有：commonJS、AMD、CMD、Es6模块等方案

#### 1、commonJS

```js
//同步加载CommonJS
//比如我们的node.js，使用的便是CommomJS规范。通过require，module.exports，exports来进行导入和导出，这里exports是module.exports的一个引用。

var http = require('http');
var server = http.createServer();

module.exports = {
  myserver: server
}
//同步模块化的应用场景：对于服务器而言，所有的模块都是存在本地硬盘中的，读取速度快，所以可以采用同步的方式读取模块。
```

#### 2、AMD

```JS
//采用异步方式加载模块，通过define来定义一个模块，通过require来引入模块，模块的加载不影响后面语句的执行，所有依赖于这些模块的语句都写在一个回调函数中，加载完毕后，这个回调函数才运行。如：

// 定义一个模块，name为定义的模块名称，foo为该模块依赖的其他模块

define( 'name', [ 'foo' ], function(foo) {
  function outPutFoo () {
    console.log(foo.data)
  }
  return {
    outPutFoo: outPutFoo
  }
})
// 导入模块
require(['name'], function (name) {
  name.outPutFoo();
})
//异步模块化的产生主要是因为同步加载方式无法应用到浏览器等受网速等限制加载速度较慢且不稳定的场景，所以通过异步加载的方式防止代码执行受阻，页面停止渲染等问题。
```



#### 3、CMD

```js
//CMD (Common Module Definition，通用模块定义)
//CMD规范是国内SeaJS的推广过程中产生的，CMD规范中一个模块是一个文件。

//AMD提倡依赖前置，在定义模块的时候就要声明其依赖的模块
//CMD提倡就近依赖（按需加载），在用到某个模块的时候再去require进来。
// 定义一个模块，可通过return， exports， mudule.exports决定要导出的内容

define(function (require, exports, module) {
  var one = require('./one')
  one.do()
// 就近依赖，按需加载
  var  two = require('./two')
  two.do() 
})
```



#### 4、ES6(import\export\export default)

```js
//es6带来了语言原生的模块化方案。

const methodOne = params => {
  console.log(params)
}
const methodTwo = params => {
  console.log(params)
}
// 导出方式 1
export default {
   methodOne,
   methodTwo
}
// 导出方式 2 
export {
  methodOne,
  methodTwo
}
// 引入方式 1 对应导出方式 1
import module from './module'
module.methodOne();

// 引入方式2 对应导出方式 2
import { methodOne } from './module'
methodOne();
```



**目前使用的最多的是commonJs和Es6的模块方案，他们的区别是如下：**

1.ES6只能新增值，无法重新赋值就会报错 

2.CommonJS 输出是值的拷贝，即原来模块中的值改变不会影响已经加载的该值， ES6静态分析，动态引用，输出的是值的引用，值改变，引用也改变，即原来模块中的值改变则该加载的值也改变。 

```js
// common.js  对输出是值的拷贝*************************************//
var count = 1;

var printCount = () =>{ 
   return ++count;
}

module.exports = {
     printCount: printCount,
     count: count
};
 // index.js
let v = require('./common');
console.log(v.count); // 1
console.log(v.printCount()); // 2
console.log(v.count); // 1


// ES6.js  对输出是值的是引用********************************************//
export let count = 1;
export function printCount() {
     ++count;
}
// main1.js
import  { count, printCount } from './es6';
console.log(count)  // 1
console.log(printCount()); // 2
console.log(count) // 2
```

3.CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。

4.CommonJS 加载的是整个模块，即将所有的接口全部加载进来， ES6 可以单独加载其中的某个接口（方法）。 

5.CommonJS this 指向当前模块，ES6 this指向undefined



## 前端组件化思想

**组件化：**本质上是对ui界面的划分（模块化是对逻辑的划分），最主要的目的是复用



## let、const、var的区别？

一，var定义的变量，作用域是封闭函数，是全域的；let定义的变量，作用域是在块级或者字块中；

二，变量提升：不论通过var声明的变量处于当前作用于的第几行，都会提升到作用域的最顶部。

   而let声明的变量不会在顶部初始化，凡是在let声明之前使用该变量都会报错（引用错误ReferenceError）会引起暂时性死区；

三，只要块级作用域内存在let，它所声明的变量就会绑定在这个区域；

四，let不允许在相同作用域内重复声明（报错同时使用var和let，两个let）



##  let 和 const

- let 在块级作用域内有效，不会污染全局变量
- const 一经声明不能改变。注意保证的是它指向的内存地址不能改变，如果是对象或者数组里面的属性或元素可以改变的。
- 存在暂时性死区，不能变量提升。
- 只能先声明再使用，且不能重复声明



## 关于Symbol

**symbol表示的是一个独一无二的值，是ES6新增的原始数据类型**

注意，`Symbol`函数前不能使用`new`命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象

`Symbol`函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。

```js
// 没有参数的情况
var s1 = Symbol();
var s2 = Symbol();

s1 === s2 // false

// 有参数的情况
var s1 = Symbol("foo");
var s2 = Symbol("foo");

s1 === s2 // false
```

​	**作为属性名的Symbol**

```js
var mySymbol = Symbol();

// 第一种写法
var a = {};
a[mySymbol] = 'Hello!';

// 第二种写法
var a = {
  [mySymbol]: 'Hello!'
};

// 第三种写法
var a = {};
Object.defineProperty(a, mySymbol, { value: 'Hello!' });

// 以上写法都得到同样结果
a[mySymbol] // "Hello!"
```

**注意，Symbol值作为对象属性名时，不能用点运算符。**

```js
var a = {};
var name = Symbol();
a.name = 'lili';
a[name] = 'lucy';
console.log(a.name,a[name]);             //lili,lucy
```

但是这里的Symbol在类外部也是可以访问的，只是不会出现在`for...in`、`for...of`循环中，也不会被`Object.keys()`、`Object.getOwnPropertyNames()`返回。但有一个`Object.getOwnPropertySymbols`方法，可以获取指定对象的所有Symbol属性名

## Symbol.for()，Symbol.keyFor()

Symbol.for机制有点类似于单例模式，首先在全局中搜索有没有以该参数作为名称的Symbol值，如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。和直接的Symbol就点不同了。

```js
var s1 = Symbol.for('foo');
var s2 = Symbol.for('foo');

s1 === s2 // true
```

Symbol.keyFor方法返回一个已登记的Symbol类型值的key。实质就是检测该Symbol是否已创建

```js
var s1 = Symbol.for("foo");
Symbol.keyFor(s1) // "foo"

var s2 = Symbol("foo");
Symbol.keyFor(s2) // undefined
```



## 扩展运算符的引用有哪些？

**1、复制数组**

```js
/**
 * 复制数组
 */
const a = [1,2,3]
const [...a2] = a
const a3 = [...a]

a2[0] = 2
a3[0] = 4
console.log(a)
console.log(a2)
console.log(a3)
```



**2、合并数组和对象**

扩展运算符提供了数组合并的新写法。

```javascript
// 例1
const arr1 = ['a', 'b'];
const arr2 = ['c'];
const arr3 = ['d', 'e'];

// ES5 的合并数组
arr1.concat(arr2, arr3);
// [ 'a', 'b', 'c', 'd', 'e' ]

// ES6 的合并数组
[...arr1, ...arr2, ...arr3]
// [ 'a', 'b', 'c', 'd', 'e' ]

// 例2
let ab = { ...a, ...b };
// 等同于
let ab = Object.assign({}, a, b);
```

不过，这两种方法都是浅拷贝，使用的时候需要注意。

```javascript
const a1 = [{ foo: 1 }];
const a2 = [{ bar: 2 }];

const a3 = a1.concat(a2);
const a4 = [...a1, ...a2];

a3[0] === a1[0] // true
a4[0] === a1[0] // true
```

上面代码中，`a3`和`a4`是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了引用指向的值，会同步反映到新数组。

**3、与解构赋值结合**

```js
const [frist,...res] = [1,2,3]
console.log(frist) // 1
console.log(...res) //2，3
```

如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。

```javascript
const [...butLast, last] = [1, 2, 3, 4, 5];
// 报错

const [first, ...middle, last] = [1, 2, 3, 4, 5];
// 报错
```

**4、实现了 Iterator 接口的对象转换为数组**

任何定义了遍历器（Iterator）接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。

```javascript
let nodeList = document.querySelectorAll('div');
let array = [...nodeList];
```

上面代码中，`querySelectorAll`方法返回的是一个`NodeList`对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于`NodeList`对象实现了 Iterator 。



## 关于iterator

迭代器iterator, 可以理解成一个为不同的数据结构，统一访问的机制（Symbol.iterator属性）。只要对应的数据结构有Symbol.iterator属性，就可以完成遍历操作。

```js
function createIterator(items) {
    var i = 0;
    return {
        next: function() {
            var done = (i >= items.length);
            var value = !done ? items[i++] : undefined;
            return {
                done: done,
                value: value
            };
        }
    };
}
var iterator = createIterator([1, 2, 3]);
console.log(iterator.next()); // "{ value: 1, done: false }"
console.log(iterator.next()); // "{ value: 2, done: false }"
console.log(iterator.next()); // "{ value: 3, done: false }"
console.log(iterator.next()); // "{ value: undefined, done: true }"
```

我们的字符串，数组、类数组的对象、Set和Map，都具备Iterator接口。所以他们都是可迭代对象。

可迭代的作用有三个：

- 1.为各种数据结构，提供一个统一的、简便的访问接口；
- 2.是使得数据结构的成员能够按某种次序排列；
- 3.是ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费。

常用到iterator的场景包括：

- 1.for...of循环
- 2.扩展运算符
- 3.解构赋值
- 4.yield*_yield*后面跟的是一个可遍历的结构
- 5.数组的遍历会调用遍历器接口



## 使用结构赋值，实现两个变量的值的交换

```js
let a = 1;let b = 2;
[a,b] = [b,a];
```



## 使用箭头函数应注意什么？

（1）用了箭头函数，this就不是指向window，而是父级（指向是可变的）
（2）不能够使用arguments对象
（3）不能用作构造函数，这就是说不能够使用new命令，否则会抛出一个错误
（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数



## 介绍下 Set、Map的区别？

**Set**： Set是ES6引入的一种类似Array的新的数据结构，Set实例的成员类似于数组item成员，区别是Set实例的成员都是唯一，不重复的。这个特性可以轻松地实现数组去重。

```js
console.log(...new Set([1,2,2,3,4,5,5,6])) // 去重
```

**Map**: Map是ES6引入的一种类似Object的新的数据结构，Map可以理解为是Object的超集，打破了以传统键值对形式定义对象，对象的key不再局限于字符串，也可以是Object。可以更加全面的描述对象的属性。

应用场景Set用于数据重组，Map用于数据储存Set：　
（1）成员不能重复
（2）只有键值没有键名，类似数组
（3）可以遍历，方法有add, delete,has
Map:
（1）本质上是健值对的集合，类似集合
（2）可以遍历，可以跟各种数据格式转换



## Proxy是什么，有什么作用？Reflect是什么，有什么作用？

**Proxy**：  Proxy是ES6新增的一个构造函数，可以理解为JS语言的一个代理，用来改变JS默认的一些语言行为，包括拦截默认的get/set等底层方法，使得JS的使用自由度更高，可以最大限度的满足开发者的需求。比如通过拦截对象的get/set方法，可以轻松地定制自己想要的key或者value。下面的例子可以看到，随便定义一个myOwnObj的key,都可以变成自己想要的函数

基本形式：

```js
let obj = new Proxy({},{
	/**
	* 定制自己想要写的方法
	**/
})
```

**Reflect：**  Reflect是ES6引入的一个新的对象，他的主要作用有两点，一是将原生的一些零散分布在Object、Function或者全局函数里的方法(如apply、delete、get、set等等)，统一整合到Reflect上，这样可以更加方便更加统一的管理一些原生API。其次就是因为Proxy可以改写默认的原生API，如果一旦原生API别改写可能就找不到了，所以Reflect也可以起到备份原生API的作用，使得即使原生API被改写了之后，也可以在被改写之后的API用上默认的API。



## 异步的解决方案有哪些？

答：回调、promise、generator、async/await



## 关于Promise

Promise 被设计用于改善 JS 中的异步编程，与事件及回调函数对比，在异步操作方面为你提供了更多的控制权与组合性。 Promise 调度被添加到 JS 引擎作业队列，以便稍后执行。不过此处有另一个作业队列追踪着 Promise 的完成与拒绝处理函数，以确保适当的执行。

Promise 具有三种状态：挂起、已完成、已拒绝。一个 Promise 起始于挂起态，并在成功时转为完成态，或在失败时转为拒绝态。在这两种情况下，处理函数都能被添加以表明Promise 何时被解决。

Promise的缺陷：

- 1）无法取消Promise，一旦新建它就会立即执行，无法中途取消。
- 2）如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。
- 3）当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。
- 4）then的写法相比await，明显在程序代码抒写上，更加繁琐。







## promise有几种状态，什么时候会进入catch？

**三个状态：**
pending、fulfilled、reject
**两个过程：**
padding -> fulfilled、padding -> rejected当pending为rejectd时，会进入catch



## iterator（遍历器）

首先`Symbol.iterator`方法返回一个对象（这个对象中包含了next方法、throw方法、return方法等），然后通过调用这个next方法才会返回一个遍历器对象（这个对象包含了value和done属性），这是需要注意的



## 具备iterator（遍历器）接口的数据结构有

（注意对象没有iterator遍历器）

- Array
- Map
- Set
- String
- TypedArray
- 函数的 arguments 对象
- NodeList 对象



## ES5和ES6遍历方法的比较？（for、forEach、for...in、for....of）

**for语句**：比较麻烦，是比较传统的一种方法

**forEach方法**：是数组上的api方法、缺点是无法中途跳出`forEach`循环，`break`命令或`return`命令都不能奏效。

**for..in**：是给对象所设计的，遍历出来的是key值，缺点如下：

- 数组的键名是数字，但是`for...in`循环是以字符串作为键名“0”、“1”、“2”等等。
- `for...in`循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。
- 某些情况下，`for...in`循环会以任意顺序遍历键名。

**for...of**：只要有[Symbol.iterator]接口的数据结构都可以进行遍历，遍历出来的是value值，同时也可以有break、return命令跳出



## Promise构造函数是同步执行还是异步执行，那么 then 方法呢？

promise构造函数是同步执行的，then方法是异步执行的，下面有示例

**下面的输出结果是多少?**

```js
const promise = new Promise((resolve, reject) => {
    console.log(1);
    resolve();
    console.log(2);
})


promise.then(() => {
    console.log(3);
})


console.log(4);
```

Promise 新建后立即执行，所以会先输出 1，2，而 Promise.then()内部的代码在 当次 事件循环的 结尾 立刻执行 ，所以会继续输出4，最后输出3



## Promise 中reject 和 catch 处理上有什么区别

reject 是用来抛出异常，catch 是用来处理异常
reject 是 Promise 的方法，而 catch 是 Promise 实例的方法
reject后的东西，一定会进入then中的第二个回调，如果then中没有写第二个回调，则进入catch
网络异常（比如断网），会直接进入catch而不会进入then的第二个回调



## Generator函数的特点

感谢文章：https://www.jianshu.com/p/e0778b004596

Generator 函数的特点就是：

1、分段执行，可以暂停
2、可以控制阶段和每个阶段的返回值
3、可以知道是否执行到结尾



## Async/Await（重要）

参考：https://segmentfault.com/a/1190000015488033

`async/await`实际上是`Generator`的语法糖。顾名思义，`async`关键字代表后面的函数中有异步操作，`await`表示等待一个异步方法执行完成。

- #### async

`async` 函数返回一个Promise对象（如果指定的返回值不是Promise对象，也返回一个Promise，只不过立即 `resolve `，处理方式同 `then `方法），因此 `async `函数通过 `return `返回的值，会成为 `then `方法中回调函数的参数：

```js
async function funcA() {
  return 'hello!';
}

funcA().then(value => {
  console.log(value);
})
// hello!
```

单独一个 `async `函数，其实与Promise执行的功能是一样的

- #### await

顾名思义， `await `就是异步等待，它等待的是一个Promise，因此 `await `后面应该写一个Promise对象，如果不是Promise对象，那么会被转成一个立即 `resolve `的Promise。 `async `函数被调用后就立即执行，但是一旦遇到 `await `就会先返回，等到异步操作执行完成，再接着执行函数体内后面的语句。总结一下就是：`async`函数调用不会造成代码的阻塞，但是`await`会引起`async`函数内部代码的阻塞。



## 说一下es6的导入导出模块

导入通过import关键字

```js
// 只导入一个
import {sum} from "./example.js"
// 导入多个
import {sum,multiply,time} from "./exportExample.js"
// 导入一整个模块
import * as example from "./exportExample.js"
```

导出通过export关键字

```js
//可以将export放在任何变量,函数或类声明的前面
export var firstName = 'Michael';
export var lastName = 'Jackson';
export var year = 1958;
//也可以使用大括号指定所要输出的一组变量
var firstName = 'Michael';
var lastName = 'Jackson';
var year = 1958;
export {firstName, lastName, year};
//使用export default时，对应的import语句不需要使用大括号
let bosh = function crs(){}
export default bosh;
import crc from 'crc';
//不使用export default时，对应的import语句需要使用大括号
let bosh = function crs(){}
export bosh;
import {crc} from 'crc';
```



## Es6和CommonJs的区别

参考：https://www.cnblogs.com/unclekeith/p/7679503.html

它们有两个重大差异：

- CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用。
- CommonJS 模块是运行时加载，ES6 模块是编译时输出接口。



# :fish_cake::fish_cake:设计模式:fish_cake::fish_cake:

## 单例模式

**定义：**保证一个类里面只会创建一个实例，不创建额外的实例，从而保证当修改这个实例的时候只会修改这个实例

**例子：**

```js
function A(name){
 	// 判断是否为object，是否已经创建
    if(typeof A.instance === 'object'){
        // 有就直接返回
        return A.instance
    }
	
    // 没有就创建
    this.name = name
	
    // 缓存单例
    A.instance = this
	
    // 返回
    return this
}

let a1 = new A()
let a2 = new A()

console.log(a1 === a2)
```





## 工厂模式和抽象工厂模式

参考：https://blog.csdn.net/weixin_43314846/article/details/107159416?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.nonecase

**定义：**工厂模式是用来创建对象的一种常用的设计模式。在使用该模式时，我们不去暴露创建对象的具体逻辑，而是将逻辑封装到一个函数中，那么该函数就会被视为一个工厂，从而能够解决创建相似对象的问题。工厂模式可以分为：`简单工厂`、`工厂方法`、`抽象工厂`。

**简单工厂模式：**针对的是某一个产品

```js
class User {
       constructor(opt) {
           this.identity = opt.identity
           this.viewPage = opt.viewPage
       }

       static getInstance(identity) {
           switch (identity) {
               case 'simple':
                   return new User({ identity: 'simple', viewPage: ['首页', '通讯录', '发现页'] });
                   break;
               case 'admin':
                   return new User({ identity: 'admin', viewPage: ['首页', '通讯录', '发现页', '应用数据'] });
                   break;
               default:
                   break;
           }
       }
   }

   let simpleUser = User.getInstance('simple')
   let adminUser = User.getInstance('admin')
   console.log(simpleUser, adminUser)
```

**缺点：**且当用户身份很多时，`getInstance`方法便会变得非常庞大，会因此变得难以维护。故简单工厂只能作用于创建的对象身份少且对象创建逻辑不复杂时。



**抽象工厂模式：**针对的是某一个产品簇，抽象工厂模式要包含四个角色：抽象产品、具体产品、抽象工厂、具体工厂

```js
//抽象工厂模式
    
     //抽象引擎产品类
     class Engine {
        start () {
            throw new Error('不能调用抽象方法，请自己实现');
        }
    }

    //具体引擎产品类
    class BenzEngine extends Engine {
        start() {
            console.log('Benz engine')
        }
    }

    class BYDEngine extends Engine {
        start() {
            console.log('BYD engine')
        }
    }


    //抽象汽车产品类
    class Car {
        drive() {
            throw new Error('不能调用抽象方法，请自己实现');
        }
    }

    //具体汽车产品类
    class BenzCar extends Car {
        drive() {
            console.log('Benz drive')
        }
    }

    class BYDCar extends Car {
        drive() {
            console.log('BYD drive')
        }
    }

    //抽象工厂类
    class AutoMakerFactory {
        createCar() {
            throw new Error('不能调用抽象方法，请自己实现')
        }

        createEngine() {
            throw new Error('不能调用抽象方法，请自己实现')
        }
    }

    //具体工厂类
    class BenzFactory extends AutoMakerFactory {
        createCar() {
            return new BenzCar();
        }
        createEngine() {
            return new BenzEngine();
        }
    }

    class BYDFactory extends AutoMakerFactory {
        createCar() {
            return new BYDCar();
        }
        createEngine() {
            return new BYDEngine();
        }
    }

    let benzFactory = new BenzFactory();
    let benzCar = benzFactory.createCar();
    let benzEngine = benzFactory.createEngine();

    let bydFactory = new BYDFactory();
    let bydCar = bydFactory.createCar();
    let bydEngine = bydFactory.createEngine();

    benzCar.drive()
    benzEngine.start()

    bydCar.drive()
    bydEngine.start()

    console.log(benzCar,benzEngine,bydCar,bydEngine)
```



## 责任链模式

**定义：**责任链模式：使多个对象都有机会处理请求，从而**避免请求的发送者和接受者之间的耦合关系**，将这些对象连成一条链，并沿着这条链传递该请求，直到有一个对象处理它为止。

**无论是作用域链、原型链、还是DOM节点中的事件冒泡，我们都能从中找到职责链的影子。**

**例子：**

```js
场景需求：假设这么一个场景：
我们负责一个售卖手机的电商网站，经过分别缴纳500元定金和200元定金的两轮预定后，到了正式购买阶段。针对预定用户实行优惠，支付过500元定金的用户会收到100元的商城优惠券，支付过200元定金的用户会收到50元的商城优惠券，没有支付定金的用户归为普通购买，且在库存有限的情况下不一定保证买到。

/*职责链 */
var order500 = function(orderType, isPaid, stock) {
	if(orderType === 1 && isPaid === true) {
		console.log("500元定金预购，得到100优惠券");
	}else {
		return "nextSuccessor";
	}
};

var order200 = function(orderType, isPaid, stock) {
	if(orderType === 2 && isPaid === true) {
		console.log("200元定金预购，得到50优惠券");
	}else {
		return "nextSuccessor";
	}
};

var orderNormal = function(orderType, isPaid, stock) {
	if(stock > 0) {
		console.log("普通购买，无优惠券");
	}else {
		console.log("库存不足");
	}
};

Function.prototype.after = function(fn) {
	var self = this;
	return function() {
		var ret = self.apply(this, arguments);
		if(ret === "nextSuccessor") {
			return fn.apply(this, arguments);
		}
		return ret;
	};
}

var order = order500.after(order200).after(orderNormal);
order(1, true, 10);
```



## 发布订阅模式和观察者模式（Vue）

观察者模式：https://blog.csdn.net/hf872914334/article/details/88899326



## 装饰器模式（react）

**定义：**装饰者(decorator)模式能够在不改变对象自身的基础上，动态的给某个对象添加额外的职责，不会影响原有接口的功能。

**例子：**react里面的高阶组件、react-redux里面的connect也是一个高阶组件



# :rice_cracker::rice_cracker:Vue:rice_cracker::rice_cracker:

## 虚拟 DOM 的实现原理

虚拟 DOM 的实现原理主要包括以下 3 部分：

- 用 JavaScript 对象模拟真实 DOM 树，对真实 DOM 进行抽象；
- diff 算法 — 比较两棵虚拟 DOM 树的差异；
- pach 算法 — 将两个虚拟 DOM 对象的差异应用到真正的 DOM 树。

**优点：**

- **保证性能下限：** 框架的虚拟 DOM 需要适配任何上层 API 可能产生的操作，它的一些 DOM 操作的实现必须是普适的，所以它的性能并不是最优的；但是比起粗暴的 DOM 操作性能要好很多，因此框架的虚拟 DOM 至少可以保证在你不需要手动优化的情况下，依然可以提供还不错的性能，即保证性能的下限；
- **无需手动操作 DOM：** 我们不再需要手动去操作 DOM，只需要写好 View-Model 的代码逻辑，框架会根据虚拟 DOM 和 数据双向绑定，帮我们以可预期的方式更新视图，极大提高我们的开发效率；
- **跨平台：** 虚拟 DOM 本质上是 JavaScript 对象,而 DOM 与平台强相关，相比之下虚拟 DOM 可以进行更方便地跨平台操作，例如服务器渲染、weex 开发等等。

**缺点:**

- **无法进行极致优化：** 虽然虚拟 DOM + 合理的优化，足以应对绝大部分应用的性能需求，但在一些性能要求极高的应用中虚拟 DOM 无法进行针对性的极致优化。



## MVVM为什么会出现？是什么？

**1、为什么会出现？**

在很久以前就已经有组件化的概念，但是那时候在模板渲染完成之后页面数据就是如此了，如果要更新数据就需要操作DOM，但是因为操作DOM是一件非常消耗性能的事情，同时处理起来很难有条理，那么就诞生了数据驱动视图的概念，意思就是不用去关注dom操作，我们只需要关注数据的变化来改变视图的显示，于是就出现了vue、react等框架，他们的能够实现数据驱动视图的原理时MVVM（vue）、setData（react）

**2、是什么？**

MVVM是一种实现数据驱动视图的一种方式，M是model层（可以看作数据data）、V是视图层（可以看做页面dom等）、VM是视图模型（可以看作是连接M和V的一种桥梁，例如methods、事件、mixin等）



## 说说你对 SPA 单页面的理解，它的优缺点分别是什么？

**优点：**

用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；
基于上面一点，SPA 相对对服务器压力小；
前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；

**缺点：**

初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；
前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；
SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。



## v-show 与 v-if 有什么区别？

**区别**：v-if每次条件为true的时候都将dom节点会重新渲染，然后将条件为false的节点销毁，而v-show则是会将所有节点都渲染，在切换的时候只不过将条件为false的节点用display:none隐藏掉



## Class 与 Style 如何动态绑定？

##### **3.1、在vue中绑定样式的两种方式?**

答：v-bind:class和v-bind:style

##### **3.2、具体使用**

```html
<template>
  <div>
    <!-- 1.绑定a属性的值，a的值在data中 -->
    <div :class="a">class1</div>
    <!-- 2.Active的存在取决于 isactive的值，为true就说明存在，为false就说明不存在。 -->
    <div :class="{active:isActive}">class2</div>
    <!-- :class = [“a”,”b”] 
    在数组中元素带不带引号的问题。带了说明是类名，不带就是data中的属性对应的值-->
    <div :class="['active',a]">class3</div>
    <!-- 1. 注意 style中是一个对象，中间用，隔开。前者是style属性，值是data中对应的数值 -->
    <div :style="styleData">style1</div>
  </div>
</template>

<script>
export default {
    data(){
        return{
            a:"class1",
            isActive:true,
            styleData:{
                color:'yellow',
                fontSize:"100px"
            }
        }
    }
}
</script>
<style lang="scss">
.class1{
    color:red
}
.active{
    font-size:50px;
}
</style>

```



## 为什么要在v-for中使用key?

在v-for循环中使用key（不要使用index和random），原因是因为diff算法是通过tag和key来判断，是否是同一个node，这样做会减少渲染不必要的node的次数，提升渲染性能



## computed 和 watch 的区别和运用的场景？

参考：https://www.cnblogs.com/jiajialove/p/11327945.html

**计算属性computed :** 

1. 支持缓存，只有依赖数据发生改变，才会重新进行计算

2. 不支持异步，当computed内有异步操作时无效，无法监听数据的变化

   3.computed 属性值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data中声明过或者父组件传递的props中的数据通过计算得到的值

4. 如果一个属性是由其他属性计算而来的，这个属性依赖其他属性，是一个多对一或者一对一，一般用computed

5.如果computed属性属性值是函数，那么默认会走get方法；函数的返回值就是属性的属性值；在computed中的，属性都有一个get和一个set方法，当数据变化时，调用set方法。

![img](https://img2018.cnblogs.com/blog/1402448/201908/1402448-20190809154932198-1444047098.png)

**侦听属性watch：**

1. 不支持缓存，数据变，直接会触发相应的操作；
2. watch支持异步
3. 监听的函数接收两个参数，第一个参数是最新的值；第二个参数是输入之前的值；

4. 当一个属性发生变化时，需要执行对应的操作；一对多；

5. 监听数据必须是data中声明过或者父组件传递过来的props中的数据，当数据变化时，触发其他操作，函数有两个参数，

　　**immediate**：组件加载立即触发回调函数执行，

　　**deep**: 深度监听，为了发现**对象内部值**的变化，复杂类型的数据时使用，例如数组中的对象内容的改变，注意监听数组的变动不需要这么做。注意：deep无法监听到数组的变动和对象的新增，参考vue数组变异,只有以响应式的方式触发才会被监听到。

![img](https://img2018.cnblogs.com/blog/1402448/201908/1402448-20190809160441362-1201017336.png)

**监听的对象也可以写成字符串的形式**

![img](https://img2018.cnblogs.com/blog/1402448/201908/1402448-20190809160648619-505189772.png)

**当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。这是和computed最大的区别**



## Vue的生命周期？描述Vue父子组件的执行顺序？

**beforeCreated：**在实例初始化之后，数据观测和事件配置之前被调用，此时组件的选项对象还未创建，el 和 data 并未初始化，因此无法访问methods， data， computed等上的方法和数据

**Created:**  data、methods、computed等选项已经初始化完成，最早可以在这里发送ajax请求

**beforeMount：** 挂在开始之前被调用，相关的render函数首次被调用（虚拟DOM），实例已完成以下的配置： 编译模板，把data里面的数据和模板生成html，注意此时还没有挂在html到页面上。

**mounted:** 挂载完成，也就是模板中的HTML渲染到HTML页面中，此时一般可以做一些ajax操作，mounted只会执行一次

**beforeUpdate：**在数据更新之前被调用，发生在虚拟DOM重新渲染和打补丁之前，可以在该钩子中进一步地更改状态，不会触发附加地重渲染过程

**Updated：**在由于数据更改导致地虚拟DOM重新渲染和打补丁只会调用，调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作，然后在大多是情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环，该钩子在服务器端渲染期间不被调用

**beforeDestory：**在实例销毁之前调用，实例仍然完全可用，

1. 这一步还可以用this来获取实例，
2. 一般在这一步做一些重置的操作，比如清除掉组件中的定时器 和 监听的dom事件

**destory：**在实例销毁之后调用，调用后，所以的事件监听器会被移出，所有的子实例也会被销毁，该钩子在服务器端渲染期间不被调用



- 加载渲染过程

```
　　父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted
```

- 子组件更新过程

```
　　父beforeUpdate->子beforeUpdate->子updated->父updated
```

- 父组件更新过程

```
　　父beforeUpdate->父updated
```

- 销毁过程

```
　　父beforeDestroy->子beforeDestroy->子destroyed->父destroyed
```



## 描述组件渲染和更新过程（初次渲染、更新渲染、异步渲染）

##### 5.1、初次渲染过程

答：1、解析模板为render函数（vue-cli中在开发环境已经完成，vue-loader）

​		2、触发响应式，监听data属性getter和setter

​		3、执行render函数，生成vnode

​		4、patch（element，vnode）将e lement和vnode关联显示视图

##### 5.2、更新过程

答：1、修改data，触发setter（此前在getter中已被监听到了）

​		2、重新执行render函数，生成newVode

​		3、更新节点 patch（vnode，newVnode）

总结： *Vue.js* 是如何在我们修改 `data` 中的数据后修改视图了。简单回顾一下，这里面其实就是一个“`setter -> Dep -> Watcher -> 生成render函数产生vnode-> patch -> 视图`”的过程。

##### 5.3、异步渲染



答：1、nextTick是等待DOM更新渲染后再次执行

​		2、会去收集data的修改，一次性更新视图

​		3、这样会减少DOM的操作次数，提高性能

##### 5.4、为甚么要异步渲染？

因为如果不采用异步更新，那么每次更新数据都会对当前组件进行重新渲染.

所以为了性能考虑。`Vue`会在本轮数据更新后，再去异步更新视图!



## 父组件可以监听到子组件的生命周期吗？

比如有父组件 Parent 和子组件 Child，如果父组件监听到子组件挂载 mounted 就做一些逻辑处理，可以通过以下写法实现：

```js
// Parent.vue
// 通过监听子组件的生命周期在doSometing函数中做某些事情
<Child @mounted="doSomething"/>
    
// Child.vue
mounted() {
  this.$emit("mounted");
}
```

以上需要手动通过 $emit 触发父组件的事件，更简单的方式可以在父组件引用子组件时通过 @hook 来监听即可，如下所示：

```html
//  Parent.vue
<Child @hook:mounted="doSomething" ></Child>

doSomething() {
   console.log('父组件监听到 mounted 钩子函数 ...');
},
    
//  Child.vue
mounted(){
   console.log('子组件触发 mounted 钩子函数 ...');
},    
    
// 以上输出顺序为：
// 子组件触发 mounted 钩子函数 ...
// 父组件监听到 mounted 钩子函数 ...     
```

当然 @hook 方法不仅仅是可以监听 mounted，其它的生命周期事件，例如：created，updated 等都可以监听。



## Vue组件间的通信

https://segmentfault.com/a/1190000019208626#item-6

**2.0、父子组件间通信（$parent和$children）**

**2.1、父子组件间通信（prop和$emit）**

**2.2、兄弟组件间通信（event.$emit和event.$on）**

**介绍**：这里实现通过在一个js文件中初始化一个新的实例(new Vue)将其导出，然后通过引用这个实例调用$on（监听事件的组件同时接收值）和$emit（需要触发事件的组件同时可以传值）互相传值

**示例**：

index.js文件

```js
import Vue from 'vue'

export default new Vue()
```



```vue
// bro1.vue组件
<template>
  <div>
      <div>我是bro1组件 {{title}}</div>
  </div>
</template>

<script>
import Event from './index'
export default {
  name: 'bro1',
  data(){
      return{
          title:""
      }
  },
  mounted(){
      Event.$on('brotherEvent',(val)=>{
          this.title = val
          console.log(val)
      })
  }
}
</script>

```



```vue
// bro2.vue组件
<template>
  <div>
    <div>我是bro2组件</div>
    <button @click="sendEventFromBro2">bro2</button>

  </div>
</template>

<script>
import Event from './index'
export default {
    name: 'bro2',
    data(){
        return{
            title:'我是bro2组件的title'
        }
    },
    methods:{
      sendEventFromBro2(){
          Event.$emit('brotherEvent',this.title)
      }
  } 
}
</script>
```

引用bro1和bro2组件的主组件**(点击bro2的事件会触发bro1的监听成功将title值变成bro2传过去的值)**

```vue
<template>
  <div>
  <bro1 /> 
  <bro2 />
  </div>
</template>

<script>
import bro1 from '../components/EventBus/bro1.vue'
import bro2 from '../components/EventBus/bro2.vue'

export default {
  name: 'EventBus',
  components: {
    bro1,
    bro2
  }
}
</script>
```

**2.3、跨级组件通信（$attr和$listener）**

**介绍**： $attrs--继承所有的父组件属性（除了组件内prop属性、class 和 style ）

​			inheritAttrs：默认值true,继承所有的父组件属性（除props的特定绑定）作为普通的HTML特性应用在子组件的根元素上，如果你不希望组件的根元素继承特性设置inheritAttrs: false,但是class属性会继承

​			$listeners--属性，它是一个对象，里面包含了作用在这个组件上的所有监听器（不含.native修饰符），你就可以配合 `v-on="$listeners"` 将所有的事件监听器指向这个组件的某个特定的子元素。

**示例**：

```vue
// index.vue
<template>
  <div>
    <h2>我是index.vue</h2>
    <child-com1
      :foo="foo"
      :boo="boo"
      :coo="coo"
      :doo="doo"
      title="前端工匠"
	  @Event="sendEvent" 
    ></child-com1>
  </div>
</template>
<script>
const childCom1 = () => import("./childCom1.vue");
export default {
  components: { childCom1 },
  data() {
    return {
      foo: "Javascript",
      boo: "Html",
      coo: "CSS",
      doo: "Vue"
    };
  },
  methods:{
      sendEvent(){
          console.log("我是祖先组件传来的事件")
      }
  }
};
</script>
```

childCom1.vue中

```vue
// childCom1.vue
<template class="border">
  <div>
    <p>foo: {{ foo }}</p>
    <p>childCom1的$attrs: {{ $attrs }}</p>
    <child-com2 v-bind="$attrs"></child-com2>
  </div>
</template>
<script>
const childCom2 = () => import("./childCom2.vue");
export default {
  components: {
    childCom2
  },
  inheritAttrs: false, // 可以关闭自动挂载到组件根元素上的没有在props声明的属性
  props: {
    foo: String // foo作为props属性绑定
  },
  created() {
    // 注意这里已经没有foo属性了，foo已经是被childCom1当作prop属性了
    console.log(this.$attrs); // { "boo": "Html", "coo": "CSS", "doo": "Vue", "title": "前端工匠" }
  }
};
</script>
```

childeCom2.vue

```vue
// childCom2.vue
<template>
  <div class="border">
    <p>boo: {{ boo }}</p>
    <p>childCom2: {{ $attrs }}</p>	
    <!-- 这里要绑定listeners事件就可以监听所有的祖先事件啦 -->
    <child-com3 v-bind="$attrs" v-on="$listeners"></child-com3> 
  </div>
</template>
<script>
const childCom3 = () => import("./childCom3.vue");
export default {
  components: {
    childCom3
  },
  inheritAttrs: false,
  props: {
    boo: String
  },
  created() {
  // 注意这里已经也没有boo属性了
    console.log(this.$attrs); // {"coo": "CSS", "doo": "Vue", "title": "前端工匠" }
  }
};
</script>
```

childCom3.vue

```vue
// childCom3.vue
<template>
  <div class="border">
    <p>childCom3: {{ $attrs }}</p>
  </div>
</template>
<script>
export default {
  props: {
    coo: String,  // 成功传到
    title: String // 成功传到
  },
  methods:{
	demo(){
		this.$emit("Event") // 触发祖先组件的事件
    }
  }
};
</script>
```

**2.4、跨级组件通信（$provide和$inject）**

**介绍**：以允许一个祖先组件向其所有子孙后代注入一个依赖，不论组件层次有多深，并在起上下游关系成立的时间里始终生效。换句人话：祖先组件中通过provider来提供变量，然后在子孙组件中通过inject来注入变量

2.4.1、$provide和$inject需要成对使用，同时在后代组件inject注入后改变祖先组件的属性后是不会响应式改变值的

Father.vue

```vue
<template>
  <div>
      <Chlid />
  </div>
</template>

<script>
import Chlid from './Child.vue'
export default {
  name: "",
  provide(){
      return {
          for:'demo'
      }
  },
  components:{
    Chlid
  },
}
</script>

```

Chlid.vue

```vue
<template>
  <div>
      <div>{{demo}}</div>
  </div>
</template>

<script>
export default {
  name: "",
  inject:['for'],
  data(){
    return{
        demo:this.for
    }
  }
}
</script>
```



## 自定义model



## slot（普通插槽、作用域插槽、具名插槽）

**作用域插槽：目的是为了让父组件拿到子组件的数据进行展示**

```vue
<template>
  <div>
      <!-- 1.普通插槽 -->
      <NormalSlot>
          我是父组件里面的内容
      </NormalSlot>

      <!-- 2.作用域插槽 主要是父组件希望使用子组件的数据
      <ScopeSlot v-slot:default="{user}">
          {{user.age}}--{{user.name}}
      </ScopeSlot> -->

      <ScopeSlot v-slot:default="{user}"> 
        {{user.name}} --- {{user.age}}
      </ScopeSlot>

      <!-- 3.具名插槽 -->
      <NameSlot>
          <div name="header"></div>
          <div name="footer"></div>
      </NameSlot> 

  </div>
</template>

<script>
import NormalSlot from '../components/slot/NormalSlot'
import ScopeSlot from '../components/slot/ScopeSlot'
import NameSlot from '../components/slot/NameSlot'

export default {
  name: 'SlotDemo',
  components: {
    NormalSlot,
    ScopeSlot,
    NameSlot
  }
}
</script>

```

子组件：

```vue
<template>
  <div>
    <slot :user="user">
      {{user.age}} -- {{user.name}}
    </slot>
  </div>
</template>

<script>
export default {
    data(){
      return {
        user:{
          name:'hyt',
          age:12
        }
      }
    }
}
</script>
```



## 动态&异步组件

##### **4.1、动态组件**

**介绍**：vue提供了一种componet标签绑定is并且切换属性值可以动态更换不同类型的组件

**使用场景**： 1.:is="component-name" 用法

​					2.需要根据数据，动态渲染的场景，即组件类型不确定

**例子**：

```vue
<template>
  <div>
      <!-- 结果渲染出home、about、EventBus组件 -->
      <div v-for="(item,key) in componentsData" :key="key">
          <!-- 动态组件遍历componentsData通过item来动态切换组件 -->
          <component :is="item.type" />
      </div>
  </div>
</template>

<script>
import Home from './Home'
import About from './About'
import EventBus from './EventBus'

export default {
    components:{
        About,
        Home,
        EventBus
    },
    data(){
        return {
            componentsData:{
                1:{type:"Home"},
                2:{type:'About'},
                3:{type:'EventBus'}
            }
        }
    }
}
</script>

```

##### 4.2、异步组件

参考：https://segmentfault.com/a/1190000012138052（建议看）

参考：https://www.w3cplus.com/vue/async-vuejs-components.html

**介绍**：当需要加载一个比较大的组件或者说想要在使用时才加载组件时可以使用异步组件加载的方式

**使用**：1.import()函数、2.按需加载，异步加载大组件

**简单例子**：

```vue
//按需异步加载组件
<template>
  <div>
    <div>按需异步加载组件</div>
    <Home v-if="showFlag"/>
    <button type="button" @click="show">显示加载异步组件</button>
  </div>
</template>

<script>
 // 我们通常使用这种方式来加载组件的
 // 但是当组件太大或者是想在必要的时候加载那么就可以使用异步加载的方式
// import Home from './Home'  
export default {
  name: 'AsyncComponents',
  components:{
      // 这种就是异步加载的方式
      Home:()=>import('./Home')
  },
  data(){
      return {
          showFlag:false
      }
  },
  methods:{
      show(){
          this.showFlag = !this.showFlag
      }
  }
}
</script>

```







## 直接给一个数组项赋值，Vue 能检测到变化吗？

参考：https://www.jianshu.com/p/e6e8c45e7fd6

由于 JavaScript 的限制，Vue 不能检测到以下数组的变动：

- 当你利用索引直接设置一个数组项时，例如：`vm.items[indexOfItem] = newValue`
- 当你修改数组的长度时，例如：`vm.items.length = newLength`

为了解决第一个问题，Vue 提供了以下操作方法：

```js
// Vue.set
Vue.set(vm.items, indexOfItem, newValue)
// vm.$set，Vue.set的一个别名
vm.$set(vm.items, indexOfItem, newValue)
// Array.prototype.splice
vm.items.splice(indexOfItem, 1, newValue)
```

为了解决第二个问题，Vue 提供了以下操作方法：

```js
// Array.prototype.splice
vm.items.splice(newLength)
```



## 组件中 data 为什么是一个函数？

**答：**每一个组件都是一个vue实例，如果使用对象的方式 给组件内data赋值，那么当复用组件改变data时会影响所有的组件，如果使用函数的形式那么就是给每一个组件的data设为一个私有变量，不会相互影响

```js
// data
data() {
  return {
	message: "子组件",
	childName:this.name
  }
}

// new Vue
new Vue({
  el: '#app',
  router,
  template: '<App/>',
  components: {App}
})
```

因为组件是用来复用的，且 JS 里对象是引用关系，如果组件中 data 是一个对象，那么这样作用域没有隔离，子组件中的 data 属性值会相互影响，如果组件中 data 选项是一个函数，那么每个实例可以维护一份被返回对象的独立的拷贝，组件实例之间的 data 属性值不会互相影响；而 new Vue 的实例，是不会被复用的，因此不存在引用对象的问题



## Vue 是如何实现数据双向绑定的？(重点)

Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据，如下图所示：



![1.png](https://user-gold-cdn.xitu.io/2019/8/19/16ca75871f2e5f80?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

即：

- 输入框内容变化时，Data 中的数据同步变化。即 View => Data 的变化。
- Data 中的数据变化时，文本节点的内容同步变化。即 Data => View 的变化。

其中，View 变化更新 Data ，可以通过事件监听的方式来实现，所以 Vue 的数据双向绑定的工作主要是如何根据 Data 变化更新 View。

Vue 主要通过以下 4 个步骤来实现数据双向绑定的：

实现一个监听器 **Observer**：对数据对象进行遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter。这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化。

实现一个解析器 **Compile**：解析 Vue 模板指令，将模板中的变量都替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，调用更新函数进行数据更新。

实现一个订阅者 **Watcher**：Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁 ，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。

实现一个订阅器 **Dep**：订阅器采用 发布-订阅 设计模式，用来收集订阅者 Watcher，对监听器 Observer 和 订阅者 Watcher 进行统一管理。

以上四个步骤的流程图表示如下，如果有同学理解不大清晰的，可以查看文章[《0 到 1 掌握：Vue 核心之数据双向绑定》](https://juejin.im/post/5d421bcf6fb9a06af23853f1)，有进行详细的讲解、以及代码 demo 示例。



![1.png](https://user-gold-cdn.xitu.io/2019/8/19/16ca75871f729d89?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



## Vue修饰符

**事件修饰符：**

​	1、stop：阻止事件冒泡、

​	2、capture：捕获事件，从外到内触发事件、

​	3、prevent：阻止默认行为

​	4、self：只会触发自己范围内的事件，不包含子元素

​	5、once：只会触发一次

​	6、native：就是在父组件中给子组件绑定一个原生的事件，就将子组件变成了普通的HTML标签，不加'. native'事件是无法触 发的。

**表单修饰符：**

​	1、lazy:使用了这个修饰符将会从“input事件”变成change事件进行同步

​	2、number：首先谁明这个number并不是限制用户的输入,而是将用户输入的数据尝试绑定为 js 中的 number 类型

举个例子，如果用户输入`300`，data 中绑定的其实是`'300'`(string)，添加 number 指令后可以得到 `300`(number)的绑定结果。
而如果用户输入的不是数字，这个指令并不会产生任何效果。

​	3、trim可以用来过滤前后的空格



## 怎么给vue定义全局的方法？

- 第一种：挂载到Vue的prototype上。把全局方法写到一个文件里面，然后for循环挂载到Vue的prototype上，缺点是调用这个方法的时候没有提示

```js
 Object.keys(tools).forEach(key => {
      Vue.prototype[key] = tools[key]
 })
```

- 第二种：利用全局混入mixin，因为mixin里面的methods会和创建的每个单文件组件合并。这样做的优点是调用这个方法的时候有提示

步骤：创建mixins.js文件、再main.js文件中引入Vue.mixin(mixins)，就可以使用了

```js
const mixin = {

 methods: {

  /**

   * 格式化时间

   * @param {string|number|object|Array} dateTime - 时间，可以是一个字符串、时间戳、表示时间的对象、Date对象或者******表示时间的数组

   * @param {string} [fmt] - 格式

   * @returns {string} 返回格式化后的日期时间，默认格式：2018年1月11日 15:00

   * @see [momentjs]{@tutorial http://momentjs.cn/}

   */

  formatDate (dateTime, fmt = 'YYYY年M月DD日 HH:mm:ss') {

   if (!dateTime) {

    return ''

   }

   moment.locale('zh-CN')

   dateTime = moment(dateTime).format(fmt)

   return dateTime

  }

 }

}
export defaullt mixin
```

- 第三种：自定义函数模块`  myFun.js

```jsx
exports.install = function(Vue) {
    Vue.prototype.customFun1 = function() {
        console.log('myFun customFun1()');
    };

    Vue.prototype.customFun2 = function() {
        let str_result = 'myFun customFun2()';
        return str_result
    };
}
```

> 在 main.js 中导入自定义模块

```jsx
import myFun from "./utils/myFun"

Vue.use(myFun);
```



## 怎么解决vue动态设置img的src不生效的问题？

使用require关键字，因为动态添加src被当作静态资源处理了，没有进行编译，所以要加上require

```vue
<template>
  <div>
    <img :src="imgSrc" style="width:100px;height:100px"/>
  </div>
</template>

<script>

export default {
  name: 'Home',
  components: {
    
  },
  data(){
    return {
    // 这里引入静态文件要使用require
      imgSrc:require('../assets/logo.png')
    }
  }

}
</script>

```



## [怎么解决vue打包后静态资源图片失效的问题？](https://github.com/haizlin/fe-interview/issues/554#)

**vue打包后静态资源图片失效：**

老版本中需要找到config/index.js，找build打包对象里的assetsPublicPath属性，默认值为/，更改为./就好了；

新版本中只有手动更改vue.config.js， 在里面配置publicPath即可（更改为"./"）（从vue 3.3开始，baseUrl被废弃，使用publicPath代替）



## vue中怎么重置data？使用场景？

使用Object.assign将初始化的data覆盖当前的data

Object.assign（）方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象
this.$data获取当前状态下的data
this.$options.data()获取该组件初始状态下的data。
Object.assign(this.$data, this.$options.data())

**使用场景：** 当有一个表单提交后，希望组件恢复到初始状态，重置data数据

## Vue.observable你有了解过吗？说说看

简单来说就一个简单的轻量的类vuex的Api，可以实现简单的跨组件的数据共享的问题

比如说在一个js文件中定义

```js
// /observer/observer.js
import Vue from 'vue'

export const store = Vue.observable({ count: 0 })
export const mutations = {
  setCount (count) {
    store.count = count
  }
}
```

然后再一个vue文件中引入

```vue
<template>
    <div>
        <label for="bookNum">数 量</label>
            <button @click="setCount(count+1)">+</button>
            <span>{{count}}</span>
            <button @click="setCount(count-1)">-</button>
    </div>
</template>

<script>
import { store, mutations } from '../store/store' // Vue2.6新增API Observable

export default {
  name: 'Add',
  computed: {
    count () {
      return store.count
    }
  },
  methods: {
    setCount: mutations.setCount
  }
}
</script>
```

这样可以实现数据的修改



## 你知道style加scoped属性的用途和原理吗？

用途：防止全局同名CSS污染
原理：在标签加上v-data-something属性，再在选择器时加上对应[v-data-something]，即CSS带属性选择器，以此完成类似作用域的选择方式

在标签上绑定data-v-xxx属性，使得只能控制当前组件的样式，防止CSS样式全局污染



## vue怎么实现强制刷新组件？

1、强制重新渲染

```js
1、使用this.$forceUpdate()
2、使用v-if
```

2、强制重新刷新组件

```js
//模版上绑定key
<SomeComponent :key="theKey"/>
//选项里绑定data
data(){
  return{
      theKey:0
  }
}
//刷新key达到刷新组件的目的
theKey++;
```



**解决方案1：当数据变更后,通过`watch` 监听，先去销毁当前的组件，然后再重现渲染。使用 `v-if` 可以解决这个问题**

```vue
<template>
   <third-comp v-if="reFresh"/>
</template>
 
<script>
   export default{
       data(){
          return {
                reFresh:true,
                menuTree:[]
            }
       },
       watch:{
             menuTree(){
                  this.reFresh= false
                  this.$nextTick(()=>{
                    
                    this.reFresh = true
                })
            }
       }
}
</script>
```



**解决方案2：通过vue `key` 实现，原理[官方文档](https://cn.vuejs.org/v2/guide/list.html#key)。所以当key 值变更时，会自动的重新渲染。（推荐）**

```vue
<template>
   <third-comp  :message="menuData"  :key="menuKey"/>
</template>
 
<script>
   export default{
       data(){
          return {
                menuKey:1,
　　　　　        menuData: "",　
            }
       },
       watch:{
             menuData(){
                ++this.menuKey
            }
       }
}
</script>
```



## vue如果想扩展某个现有的组件时，怎么做呢

方法：

1. 使用Vue.extend直接扩展
2. 使用Vue.mixin全局混入
3. HOC封装
4. 加slot扩展



## vue使用v-for遍历对象时，是按什么顺序遍历的？如何保证顺序？

1、会先判断是否有iterator接口，如果有循环执行next()方法
2、没有iterator的情况下，会调用Object.keys()方法，在不同浏览器中，JS引擎不能保证输出顺序一致
3、保证对象的输出顺序可以把对象放在数组中，作为数组的元素



## 使用vue渲染大量数据时应该怎么优化？

非常感谢：https://www.cnblogs.com/crizy/p/9922246.html

使用Object.freeze()冻结一个对象不能够修改

**Object.freeze()冻结的是值，你仍然可以将变量的引用替换掉**



## vue组件里的定时器要怎么销毁？

当生命周期销毁后，并没有将组件中的计时器销毁，虽然页面上看不出来，但是如果在控制台打印的话，会发现计时器还在运行，所以要销毁计时器，避免代码一直执行

```js
const timer = setInterval(() =>{
// 某些定时器操作
}, 500);
// 通过$once来监听定时器，在beforeDestroy钩子可以被清除。
this.$once('hook:beforeDestroy', () => {
	clearInterval(timer);
})
```



## vue 创建监听,和销毁监听(addEventListener, removeEventListener)

最近在做一个有关监听scroll的功能, 发现我添加监听之后一直不起作用:

```js
mounted() {
    window.addEventListener("scroll", this.setHeadPosition); 
}//this.setHeadPosition方法名
```

　　后来发现要在后面添加一个true之后才行:

```js
mounted() {
	window.addEventListener("scroll", this.setHeadPosition, true);
},
```

　　而在离开是的时候需要销毁监听: (在destroyed里面销毁), 否则监听会一直存在, 因为这是单页面应用, 页面并未关闭.

```js
destroyed() {
	window.removeEventListener("scroll", this.setHeadPosition, true);
},
```

　 在销毁的时候一定也要加上true, 否则销毁不起作用.



## 实现图片懒加载



对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件：

（1）安装插件

```js
npm install vue-lazyload --save-dev
```

（2）在入口文件 man.js 中引入并使用

```js
import VueLazyload from 'vue-lazyload'
```

然后再 vue 中直接使用

```js
Vue.use(VueLazyload)
```

或者添加自定义选项

```js
Vue.use(VueLazyload, {
preLoad: 1.3,
error: 'dist/error.png',
loading: 'dist/loading.gif',
attempt: 1
})
```

（3）在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示：

```html
<img v-lazy="/static/img/1.png">
```



## Vue过滤器相关

参考：https://blog.csdn.net/qq_42778001/article/details/95613371

**局部过滤器：**

```vue
<template>
  <!-- 过滤器demo -->
  <div>
    <input type="text" v-model="content" @change="changeInput" />
    <h3>{{viewContent | upper}}</h3>
  </div>
</template>

<script>
export default {
  data() {
    return {
      content: "",
      viewContent: "",
    };
  },
  methods: {
    changeInput() {
      this.viewContent = this.content;
    },
  },
  filters: {
    upper(value) {
      if (value) {
        let str = value.toString();
        //获取英文，以空格分组把字符串转为数组，遍历每一项，第一项转为大写字母
        let newArr = str.split(" ").map((ele) => {
          return ele.charAt(0).toUpperCase() + ele.slice(1);
        });
        return newArr.join(" "); //数组转字符串 以空格输出。。。
      }
    },
  },
};
</script>

```



**全局过滤器：**

```js
// filters.js文件下
const prefix = function(value){
    return "$" + value
}

export {prefix}
```



```js
// main.js
import * as filters from './utils/filter'
	
Object.keys(filters).forEach(item=>{
  Vue.filter(item,filters[item])
})
```



```vue
// filterDemo.vue
<template>
  <!-- 过滤器demo使用prefix过滤器 -->
  <div>
    
    <h4>{{value | prefix}}</h4>
  </div>
</template>
```



## 使用vue语法ref时获取到undefined为空？如何解决？

**1、你在哪里调用，和你调用的对象**

试试在mounted（）里面调用有效果没有

调用的对象是本来就存在的，还是需要数据渲染之后才会出现的，同理，在mounted（）里面调用看看

**2、调用对象是不是数组列表**

  我一开始设置ref在v-for列表上，直接获取this.$refs.name.style，永远是空的，

  后来才发现，this.$refs.name是一个数组，无法通过 .style 获取样式，

  只能遍历这个this.$refs.name数组，在this.$refs.name[index]上设置样式

  但是像高度宽度，可以通过offsetHeight，等来获取。

**3、调用对象是否和v-if结合使用**

 ref不是响应式的，所有的动态加载的模板更新它都无法相应的变化。

解决方案：

　　通过

**setTimeout(() => {**

　　　　**}, 0)**

来得到数据



vue中的mixins实现图片懒加载

# :ramen::ramen:Vue-router:ramen::ramen:

##  路由跳转，name 和 path 跳转的区别

**路由跳转的几种方式**

```javascript
// 字符串
this.$router.push('home')

// 命名的路由
this.$router.push({
  name: 'user',
  params: {userId: '123'}
})
//接收参数
this.userId = this.$route.params.userId

// 带查询参数，变成 /user?userId=123
this.$router.push({
  path: '/user',
  query: {userId: '123'}
})
//接收
this.userId = this.$route.query.userId;
复制代码
```

name 和 path 跳转的区别在于

- name 传参用 params，path 传参用 query。
- 用 name 跳转后参数不会携带到 url 上，用 query 传参参数会携带到 url 上。



## Vue-router有哪几种钩子（导航守卫）

全局：

路由内：

组件内:



## Vue-router完整的导航流程是什么

**路由守卫执行顺序：**

![完整的流程图如下 ](https://img-blog.csdnimg.cn/2019102916460653.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MDAxMzgxNw==,size_16,color_FFFFFF,t_70)  

## Router和route有什么区别?

Router是指整个路由对象，里面有一些跳转的方法比如：push、go、replace等

route是指当前的路由对象，里面有一些当前路由的信息比如query、params等



## Push、go、replace的区别

**push**：跳转到不同的url，但这个方法会向history栈添加一个记录，点击后退会返回到上一个页面。	

**replace**：同样是跳转到指定的url，但是这个方法不会向history里面添加新的记录，点击返回，会跳转到上上一个页面。上一个记录是不存在的

**go**：相对于当前页面向前或向后跳转多少个页面,类似 `window.history.go(n)`。n可为正数可为负数。正数返回上一个页面



## 如何配置重定向？

```js
//路径：
{ path: '/a', redirect: '/b' }
//命名的路由： 
{ path: '/a', redirect: {name:'/foo'} }
//动态重定向目标： 
{ path: '/a', redirect: to => {
const {
    query,
    params,
    hash
} = to
if (params.name) {
return /${params.name}
} else if (query.to && query.to === "bar") {
return /${query.to}
} else if (hash === '#baz') {
return '/baz'
}
}
}
```



## 如何配置404页面？

再路由的最后添加，如果所有的路由都不匹配会走这一条

```json
{
	path:*,
	component:NotFound,
	name:NotFound
}
```



## vue-router如何响应路由参数的变化？

问题：为什么要响应参数变化？

- 切换路由，路由参数发生了变化，但是页面数据并未及时更新，需要强制刷新后才会变化。
- 不同路由渲染相同的组件时（组件复用比销毁重新创建效率要高），在切换路由后，当前组件下的生命周期函数不会再被调用。

解决方案：

1. 使用 watch 监听

```js
watch: {
    $route(to, from){
        if(to != from) {
            console.log("监听到路由变化，做出相应的处理");
        }
    }
}
```

1. 向 router-view 组件中添加 key

   ```vue
   <router-view :key="$route.fullPath"></router-view>
   ```

   $route.fullPath 是完成后解析的URL，包含其查询参数信息和hash完整路径





## 如何获取路由参数？

如果使用`query`方式传入的参数使用`this.$route.query` 接收
如果使用`params`方式传入的参数使用`this.$router.params`接收



## 在vue组件中怎么获取到当前的路由信息？

如果是template中获取直接 `$route` 即可
如果是script中获取 `this.$route`
可以 `console.log(this.$route)` 查看其详细信息



## Vue中的sync修饰是干什么用的？

在`Vue`中，`props`属性是单向数据传输的,父级的prop的更新会向下流动到子组件中，但是反过来不行。可是有些情况，我们需要对prop进行“双向绑定”。我们提到了使用`v-model`实现双向绑定。但有时候我们希望一个组件可以实现多个数据的“双向绑定”，而`v-model`一个组件只能有一个(Vue3.0可以有多个)，这时候就需要使用到`.sync`。

#### `.sync`与`v-model`的异同

相同点：

- 两者的本质都是语法糖，目的都是实现组件与外部数据的双向绑定
- 两个都是通过属性+事件来实现的

不同点(个人观点，如有不对，麻烦下方评论指出，谢谢)：

- 一个组件只能定义一个`v-model`,但可以定义多个`.sync`
- `v-model`与`.sync`对于的事件名称不同，`v-model`默认事件为`input`,可以通过配置`model`来修改，`.sync`事件名称固定为`update:属性名`

#### 自定义`.sync`

在开发业务时，有时候需要使用一个遮罩层来阻止用户的行为（更多会使用遮罩层+loading动画），下面通过自定义`.sync`来实现一个遮罩层

![img](https://user-gold-cdn.xitu.io/2020/6/12/172a70e9a027bdc8?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

```vue
<!--调用方式-->
<template>
  <custom-overlay :visible.sync="visible" />
</template>

<script>
export default {
  data() {
    return {
      visible: false
    }
  }
}
</script>
```



# :meat_on_bone::meat_on_bone:VueX:meat_on_bone::meat_on_bone:

### Vuex中的action和mutation的区别？

mutations可以直接修改state，但只能包含同步操作，同时，只能通过提交commit调用(尽量通过Action或mapMutation调用而非直接在组件中通过this.$store.commit()提交)
actions是用来触发mutations的，它无法直接改变state，它可以包含异步操作，它只能通过store.dispatch触发



### 不使用vuex会带来什么问题？

1.传参数时对于多层嵌套的组件将会非常繁琐，对于兄弟组件更是无法传递（只能使用EventBus自定义事件，但是大型项目就很难了）
2.当不同视图的行为需要去修改数据时，无法追踪到数据的变更方向，导致无法维护代码



### vuex中的action中的context对象有什么？

里面包含了state、commit、getter、dispatch、rootState、rootGetters(后面两个是模块的时候)属性



### vuex中的getter包含哪些参数？mutation呢？

getter中包含两个参数，第一个是state、第二个是getters（getter对象）、如果有模块命名空间就新增rootState和rootGetter

mutaion有state和payload两个



**vuex示例**

```vue
// index.vue文件
<template>
  <div>
    {{username}}
    {{getJob}}
    <button @click="changeNameFromVuex">修改msg</button>
  </div>
</template>

<script>
import {mapState,mapActions, mapGetters} from 'vuex'
export default {
  name: 'HelloWorld',
  data(){
    return{
      // username:'你是傻子么?'
    }
  },
  computed:{
    ...mapGetters('Login',['getJob']),
    ...mapState('Login',{
      username:state => state.username,
      
    })
  },
  methods:{
    ...mapActions('Login',['changeName']),
    changeNameFromVuex(){
      this.$store.dispatch('Login/changeName','大笨蛋')
    }
  }
}
</script>
```



```js
import Vue from 'vue'
import Vuex from 'vuex'
import Login from './login/login'
Vue.use(Vuex)

export default new Vuex.Store({
  state: {
    job:'前端开发'
  },
  getters:{
    jobDev:(state)=>state.job + '工程师'
  },
  mutations: {
  },
  actions: {
  },
  modules: {
    Login
  }
})
```



```js
// store/login.js 文件 login模块
const state = {
    username: 'hyt',
    loginUserJob:""
}
const getters = {
    getJob(state,getters,rootState,rootGetters){
        console.log(rootState)
        return state.username + rootState.job
    }

}
const mutations = {
    change_name(state,payload) {
        // console.log(getters.Job(),'getter')
        // state.loginUserJob = getters.Job
        state.username = state.username + payload
    }
}
const actions = {
    changeName({commit},payload){
        commit('change_name',payload)
    }
}

export default {
    namespaced:true,
    state,
    getters,
    mutations,
    actions
}
```



# :fries::fries:React:fries::fries:



## 关于生命周期

**1、React 组件生命周期有哪些不同阶段？**

参考：https://zhuanlan.zhihu.com/p/30757059

参考：https://zhuanlan.zhihu.com/p/30971608

在组件生命周期中有四个不同的阶段：

1. **Initialization**：在这个阶段，组件准备设置初始化状态和默认属性。
2. **Mounting**：react 组件已经准备好挂载到浏览器 DOM 中。这个阶段包括`componentWillMount`和`componentDidMount`生命周期方法。
3. **Updating**：在这个阶段，组件以两种方式更新，发送新的 props 和 state 状态。此阶段包括`shouldComponentUpdate`、`componentWillUpdate`和`componentDidUpdate`生命周期方法。
4. **Unmounting**：在这个阶段，组件已经不再被需要了，它从浏览器 DOM 中卸载下来。这个阶段包含 `componentWillUnmount` 生命周期方法。

除以上四个常用生命周期外，还有一个错误处理的阶段：

**Error Handling**：在这个阶段，不论在渲染的过程中，还是在生命周期方法中或是在任何子组件的构造函数中发生错误，该组件都会被调用。这个阶段包含了 `componentDidCatch` 生命周期方法。

## 出生阶段

- `constructor`
- `getDefaultProps()` (React.createClass) or`MyComponent.defaultProps` (ES6 class)
- `getInitialState()` (React.createClass) or `this.state = ...` (ES6 constructor)
- `componentWillMount()`**（componentWillMount可以使用this.setState修改状态）**
- `render()`
- `componentDidMount()`

## 更新阶段

- `componentWillReceiveProps()`**（并不意味着props改变他会触发，即使不改变传入props也会触发）**
- `shouldComponentUpdate()`
- `componentWillUpdate()`**（componentWillUpdate不可以使用this.setState修改状态）**
- `render()`
- `componentDidUpdate()`

更新阶段触发的条件：1、更改props和state；2、触发forceUpdate

![img](https://user-gold-cdn.xitu.io/2019/11/6/16e3df8cee593053?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



**2、React 的生命周期方法有哪些？**

- `componentWillMount`:在渲染之前执行，用于根组件中的 App 级配置。

- ##### getInitialState和getDefaultProps：会发生在componentWillMount之后，只不过Es6会通过其他方式实现

  ```react
  class MyComponent extends React.Component() {
    //...
  }
  // getDefaultProps通過defaultProps來觸發
  MyComponent.defaultProps = { age: 'unknown' }
  // getInitialState通過this.state來實現
  class Person extends React.Component {
    constructor(props) {
      super(props);
        // 這裏
      this.state = { count: 0 };
    }
    //...
  }
  ```

  

- `componentDidMount`：在第一次渲染之后执行，可以在这里做AJAX请求，DOM 的操作或状态更新以及设置事件监听器。

- `componentWillReceiveProps`：**在初始化`render`的时候不会执行，它会在组件接受到新的状态(Props)时被触发，一般用于父组件状态更新时子组件的重新渲染 （并不意味着props改变他会触发，即使不改变传入props也会触发）**

- `shouldComponentUpdate`：确定是否更新组件。默认情况下，它返回`true`。如果确定在 `state` 或 `props` 更新后组件不需要在重新渲染，则可以返回`false`，这是一个提高性能的方法。

- `componentWillUpdate`：在`shouldComponentUpdate`返回 `true` 确定要更新组件之后执行。

- `componentDidUpdate`：它主要用于更新DOM以响应`props`或`state`更改。

- `componentWillUnmount`：它用于取消任何的网络请求，或删除与组件关联的所有事件监听器。、

- render：在出生階段和更新階段都会触发，但是需要注意的是不要尝试在render中更改组件的状态（使用this.setState）会循环触发render，也不应该在`render`中通过`ReactDOM.findDOMNode`方法访问原生的DOM元素（原生相对于虚拟DOM而言）。因为这么做存在两个风险：

  1. 此时虚拟元素还没有被渲染到页面上，所以你访问的元素并不存在
  2. 因为当前的`render`即将执行完毕返回新的DOM结构，你访问到的可能是旧的数据



**类组件和函数组件之间的区别是啥？**

- **类组件**可以使用其他特性，如状态 `state` 和生命周期钩子。
- 当组件只是接收 `props` 渲染到页面时，就是无状态组件，就属于函数组件，也被称为哑组件或展示组件。

函数组件和类组件当然是有区别的，而且函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。为了提高性能，尽量使用函数组件。

| 区别               | 函数组件 | 类组件 |
| ------------------ | -------- | ------ |
| 是否有 `this`      | 没有     | 有     |
| 是否有生命周期     | 没有     | 有     |
| 是否有状态 `state` | 没有     | 有     |



## **React 中 refs 干嘛用的？**

`Refs` 提供了一种访问在`render`方法中创建的 DOM 节点或者 React 元素的方法。在典型的数据流中，`props` 是父子组件交互的唯一方式，想要修改子组件，需要使用新的`pros`重新渲染它。凡事有例外，某些情况下咱们需要在典型数据流外，强制修改子代，这个时候可以使用 `Refs`。

咱们可以在组件添加一个 `ref` 属性来使用，该属性的值是一个回调函数，接收作为其第一个参数的底层 DOM 元素或组件的挂载实例。

```jsx
class UnControlledForm extends Component {
  handleSubmit = () => {
    console.log("Input Value: ", this.input.value)
  }
  render () {
    return (
      <form onSubmit={this.handleSubmit}>
        <input
          type='text'
          ref={(input) => this.input = input} />
        <button type='submit'>Submit</button>
      </form>
    )
  }
}
```

请注意，`input` 元素有一个`ref`属性，它的值是一个函数。该函数接收输入的实际 DOM 元素，然后将其放在实例上，这样就可以在 `handleSubmit` 函数内部访问它。

经常被误解的只有在类组件中才能使用 `refs`，但是`refs`也可以通过利用 JS 中的闭包与函数组件一起使用。

```jsx
function CustomForm ({handleSubmit}) {
  let inputElement
  return (
    <form onSubmit={() => handleSubmit(inputElement.value)}>
      <input
        type='text'
        ref={(input) => inputElement = input} />
      <button type='submit'>Submit</button>
    </form>
  )
}
```





## **在 React 中如何处理事件？**

**处理事件的三种方法：**https://www.cnblogs.com/weiqinl/p/10798437.html

为了解决跨浏览器的兼容性问题，`SyntheticEvent` 实例将被传递给你的事件处理函数，`SyntheticEvent`是 React 跨浏览器的浏览器原生事件包装器，它还拥有和浏览器原生事件相同的接口，包括 `stopPropagation()` 和 `preventDefault()`。

比较有趣的是，React 实际上并不将事件附加到子节点本身。React 使用单个事件侦听器侦听顶层的所有事件。这对性能有好处，也意味着 React 在更新 DOM 时不需要跟踪事件监听器。



## **state 和 props 区别是啥？**

`props`和`state`是普通的 JS 对象。虽然它们都包含影响渲染输出的信息，但是它们在组件方面的功能是不同的。即

- `state` 是组件自己管理数据，控制自己的状态，可变；
- `props` 是外部传入的数据参数，不可变；
- 没有`state`的叫做无状态组件，有`state`的叫做有状态组件；
- 多用 `props`，少用 `state`，也就是多写无状态组件。



## 如何创建 refs

Refs 是使用 `React.createRef()` 创建的，并通过 `ref` 属性附加到 React 元素。在构造组件时，通常将 `Refs` 分配给实例属性，以便可以在整个组件中引用它们。

```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    this.myRef = React.createRef();
  }
  render() {
    return <div ref={this.myRef} />;
  }
}
```

或者这样用：

```jsx
class UserForm extends Component {
  handleSubmit = () => {
    console.log("Input Value is: ", this.input.value)
  }
  render () {
    return (
      <form onSubmit={this.handleSubmit}>
        <input
          type='text'
          ref={(input) => this.input = input} /> // Access DOM input in handle submit
        <button type='submit'>Submit</button>
      </form>
    )
  }
}
```



## 在构造函数调用 `super` 并将 `props` 作为参数传入的作用是啥？

在调用 `super()` 方法之前，子类构造函数无法使用`this`引用，ES6 子类也是如此。**将 `props` 参数传递给 `super()` 调用的主要原因是在子构造函数中能够通过`this.props`来获取传入的 `props`。**

**传递 props**

```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super(props);
    console.log(this.props);  // { name: 'sudheer',age: 30 }
  }
}
```

**没传递 props**

```jsx
class MyComponent extends React.Component {
  constructor(props) {
    super();
    console.log(this.props); // undefined
    // 但是 Props 参数仍然可用
    console.log(props); // Prints { name: 'sudheer',age: 30 }
  }

  render() {
    // 构造函数外部不受影响
    console.log(this.props) // { name: 'sudheer',age: 30 }
  }
}
复制代码
```

上面示例揭示了一点。`props` 的行为只有在构造函数中是不同的，在构造函数之外也是一样的。



## 讲讲什么是 JSX ？

当 **Facebook** 第一次发布 React 时，他们还引入了一种新的 JS 方言 `JSX`，将原始 HTML 模板嵌入到 JS 代码中。JSX 代码本身不能被浏览器读取，必须使用`Babel`和`webpack`等工具将其转换为传统的JS。很多开发人员就能无意识使用 JSX，因为它已经与 React 结合在一直了。

```jsx
class MyComponent extends React.Component {
  render() {
    let props = this.props;  
    return (
      <div className="my-component">
      	<a href={props.url}>{props.name}</a>
      </div>
    );
  }
}
```



## **为什么不直接更新 `state` 呢 ?**

如果试图直接更新 `state` ，则不会重新渲染组件。

```jsx
 // 错误
 This.state.message = 'Hello world';
```

需要使用`setState()`方法来更新 `state`。它调度对组件`state`对象的更新。当`state`改变时，组件通过重新渲染来响应：

```jsx
// 正确做法
This.setState({message: ‘Hello World’});
```



## React 中的StrictMode(严格模式)是什么？？

React 的`StrictMode`是一种辅助组件，可以帮助咱们编写更好的 react 组件，可以使用`<StrictMode />`包装一组组件，并且可以帮咱们以下检查：

- 验证内部组件是否遵循某些推荐做法，如果没有，会在控制台给出警告。
- 验证是否使用的已经废弃的方法，如果有，会在控制台给出警告。
- 通过识别潜在的风险预防一些副作用。



## **为什么类方法需要绑定到类实例？**

在 JS 中，`this` 值会根据当前上下文变化。在 React 类组件方法中，开发人员通常希望 `this` 引用组件的当前实例，因此有必要将这些方法绑定到实例。通常这是在构造函数中完成的:

```jsx
class SubmitButton extends React.Component {
  constructor(props) {
    super(props);
    this.state = {
      isFormSubmitted: false
    };
    this.handleSubmit = this.handleSubmit.bind(this);
  }

  handleSubmit() {
    this.setState({
      isFormSubmitted: true
    });
  }

  render() {
    return (
      <button onClick={this.handleSubmit}>Submit</button>
    )
  }
}
```



## 什么是 prop drilling，如何避免？

在构建 React 应用程序时，在多层嵌套组件来使用另一个嵌套组件提供的数据。最简单的方法是将一个 `prop` 从每个组件一层层的传递下去，从源组件传递到深层嵌套组件，这叫做**prop drilling**。

`prop drilling`的主要缺点是原本不需要数据的组件变得不必要地复杂，并且难以维护。

为了避免`prop drilling`，一种常用的方法是使用**React Context**。通过定义提供数据的`Provider`组件，并允许嵌套的组件通过`Consumer`组件或`useContext` Hook 使用上下文数据。





## 如何在 ReactJS 的 Props上应用验证？

答：使用prop-types插件

```js
import PropsType from 'prop-types'

组件名.propTypes = {
	username:PropsType.string.isRequired,
	age:PropsType.number.isRequired
}
```



## 如何避免组件的重新渲染？

React 中最常见的问题之一是组件不必要地重新渲染。React 提供了两个方法，在这些情况下非常有用：

- `React.memo()`:这可以防止不必要地重新渲染函数组件
- `PureComponent`:这可以防止不必要地重新渲染类组件

这两种方法都依赖于对传递给组件的`props`的浅比较，如果 `props` 没有改变，那么组件将不会重新渲染。虽然这两种工具都非常有用，但是浅比较会带来额外的性能损失，因此如果使用不当，这两种方法都会对性能产生负面影响。



## 什么是纯函数

答：https://blog.csdn.net/c_kite/article/details/79138814

**一个函数的返回结果只依赖于它的参数，并且在执行过程里面没有副作用，我们就把这个函数叫做纯函数。**



## 关于Hoc高阶组件的写法

```jsx
const HocFunc = (Com) => {
    return class HocDemo extends Component{
        state = {x:0,y:0}

        handleMove = (event) => {
            this.setState({
                x:event.clientX,
                y:event.clientY
            })
        }
        render(){
            return (
                <div onMouseMove={this.handleMove}>
                    <Com state={this.state} />
                </div>
            )
        }
    }
}

class Demo extends Component{
    render(){
        const {x,y} = this.props.state
        return(
            <div>
                this is position {x} - {y}
            </div>
        )
    }
}

export default HocFunc(Demo)
```



## 关于富文本的写法（dangerouslySetInnerHTML）

```jsx
const rawHtml = "<span>我是富文本</span>"
const rawData = {
	__html:rawHtml
}

const rawHtmlElem = <div>
    // 这种就不会渲染成下面这种形式
	<p dangerouslySetInnerHTML={rawData}></p>
          
    // 这样会直接渲染成<span>我是富文本</span>
    <p>{rawData}</p>
</div>
```



## 关于setState的知识

**2.1、不可变值（不要直接修改state）：** 在使用setState的时候，不要去修改原先的值

**2.2、可能会异步更新：**在一般的情况会会是异步更新，但是在setTimeout和自定义DOM事件的时候是同步更新的

**2.3、可能会被合并成一个setState：**在使用对象时，



## 关于受控组件和非受控组件

- **受控组件**是 React 控制中的组件，并且是表单数据真实的唯一来源。
- **非受控组件**是由 DOM 处理表单数据的地方，而不是在 React 组件中。

**受控组件:**

```js
在React中，可变状态通常保存在组件的状态属性中，并且只能使用 setState() 进行更新，而呈现表单的React组件也控制着在后续用户输入时该表单中发生的情况，以这种由React控制的输入表单元素而改变其值的方式，称为受控组件。
```

```jsx
import React, { Component } from 'react'
export default class MyInput extends Component{
  constructor(props) {
    super(props);
    this.state = {
      value: 0
    }
  }
  handleChange = (event)=>{
    this.setState({
        value: event.target.value
    })
  }
  render(){
    return(
      <div>
          <input
              type="text"
              value={this.state.value}
              onChange={this.handleChange}
           />
      </div>
    )
  }
}
```



**非受控组件:**

```html
非受控组件指的是，表单数据由DOM本身处理。即不受setState()的控制，与传统的HTML表单输入相似，input输入值即显示最新值。
input、textArea这些默认都是非受控组件
```

```jsx
class NameForm extends React.Component {
  constructor(props) {
    super(props);
    this.handleSubmit = this.handleSubmit.bind(this);
  }
	
  
  handleSubmit(event) {
    console.log('A name was submitted: ' + this.input.value);
    event.preventDefault();
  }

  render() {
    // 通过ref获取DOM中的值
     return (
      <form onSubmit={this.handleSubmit}>
        <label>
          Name:
          <input type="text" ref={(input) => this.input = input} />
        </label>
        <input type="submit" value="Submit" />
      </form>
    );
  }
}
```

**两者区别**

 **1、受控组件**

 受控组件依赖于状态
 受控组件的修改会实时映射到状态值上，此时可以对输入的内容进行校验
 受控组件只有继承React.Component才会有状态
 受控组件必须要在表单上使用onChange事件来绑定对应的事件

**2、非受控组件** 

 非受控组件不受状态的控制
 非受控组件获取数据就是相当于操作DOM
 非受控组件可以很容易和第三方组件结合，更容易同时集成 React 和非 React 代码



## 关于Portals

原因：

**正常情况下组件会以既定层次嵌套渲染,但是有时候我们想让组件渲染到父组件之外**



描述：

**1、使得组件可以脱离父组件层级挂载在DOM树的任何位置。**

**2、组件的挂载点虽然可以脱离父组件。但是组件的事件冒泡机制仍可以传给父组件**



使用场景：

**1、overflow:hidden（当父组件设置了overflow：hidden属性的时候，子组件无法显示，可以通过portals将子组件逃离父组件）**

**2、父组件的z-index值太小**

**3、设置了fixed的子组件需要将自身逃离父组件，放在body的第一层**

使用：

```jsx
import React, { Component } from 'react'
import ReactDOM from 'react-dom'
import '../css/style.css'
export default class ProtalDemo extends Component {
    render() {

        // return (
        //     // 正常情况下组件会以既定层次嵌套渲染,但是有时候我们想让组件渲染到父组件之外
        //     // 比如下面的情况我们将这个div的position设置为fixed，想让他在body里面渲染
        //     // 就可以使用protal方法
        //     <div>
        //         <div className="modal">
        //             {/* {this.props.children} */}
        //             protalDemo
        //         </div>
        //     </div>
        // )

        // 这样就可以将这个元素挂载在body上面
        return ReactDOM.createPortal(
            <div className="modal">
                protalDemo
            </div>,
            document.body
        )
    }
}
```



## 关于React的异步组件加载

**步骤：使用React.lazy引入组件、使用React.Suspense加载组件**

**示例：**

```jsx
import React, { Component } from 'react'
import CotextDemo from './CotextDemo'

// 异步组件加载
// 通过React.lazy加载
const ContextDemo = React.lazy(()=>import('./CotextDemo'))
export default class AsyncDemo extends Component {
    render() {
        return (
            <div>
                <p>异步组件加载</p>
                {/*使用React.Suspense fallback加载时的html结构*/}
                <React.Suspense fallback={<div>....loading</div>}>
                    <ContextDemo></ContextDemo>
                </React.Suspense>
            </div>
        )
    }
}
```



## 关于SCU(shouldComponentUpdate生命周期)

介绍：

1、SCU默认返回true，即React默认渲染所有子组件

2、当父组件因为数据改变重新渲染时，无论该子组件是否有过数据更新都会更新

3、必须配合“不可变值”一起使用

4、在SCU中，不建议使用深度比较。使用PureCompoent是比较好的选择



**问：为什么要给一个SCU作为性能优化，react直接对比props和state帮你处理不行吗？**

答：因为有时候开发人员的业务书写不规范的，举个栗子：

```jsx
import React, { Component } from 'react'
import PropTypes from 'prop-types'
import _ from 'lodash'

export default class PropsDemo extends Component {

    sumbitTitle = (title) => {
        const newObj = {
            id:Math.random(),
            title:title
        }
        // 这个是正确的写法
        // this.setState({
        //     list:this.state.list.concat(newObj)
        // })

        // 如果react帮你在SCU中完全处理了,那么如果开发者开发不规范，就会引起这种错误
        // this.state.list push了之后就等于setState中的list了
        // 重要的地方*****请关注这里
        // 所以为什么react会开放SCU供开发者自行选择是否重新渲染UI
        this.state.list.push(newObj)
        this.setState({
            list:this.state.list
        })
    }

    state = {
        list:[
            {
                id:1,
                title:'标题1'
            },
            {
                id:2,
                title:'标题2'
            },
            {
                id:3,
                title:'标题3'
            }
        ],
        footer:'我是父组件底部文字'
    }

    render() {
        return (
            <div>
                <List list={this.state.list}/>
                <Input sumbitTitle={this.sumbitTitle} />
                <Footer footer={this.state.footer} length={this.state.list.length}></Footer>
            </div>
        )
    }
}

// Input组件
class Input extends Component{
    InputChange = (event) => {
        this.setState({
            title:event.target.value
        })
    }

    handleSumbit = () => {
        const { sumbitTitle } = this.props
        // 调用父组件的方法传值
        sumbitTitle(this.state.title)
        // 清空title
        // this.setState({
        //     title:''
        // })
    }

    render(){
        return (
            <div>
                <input type="text" onChange={this.InputChange}/>
                <button onClick={this.handleSumbit}>提交</button>
            </div>
        )
    }
}



class List extends Component{
    
    render(){
        const { list } = this.props
        return (
            <div>
                <ul>
                    {
                        list.map((item,index)=>{
                            // 每次遍历都必须加上key值，而且key值不能是random或者index
                            return <li key={item.id}>{index}----{item.title}</li>
                        })
                    }
                </ul>
            </div>
        )
    }

    //SCU使用方式，假设这里时进行深度比较，是react帮你处理的理想状态
    // 重要的地方*****请关注这里
    shouldComponentUpdate(nextProps,nextState){
        if(_.isEqual(nextProps.list,this.props.list)){
            return false
        }
        return true
    }
}
```



## 关于PureComponent和memo

**1、使用PureComponent：**首先PureComponent是在类组件使用的，当继承了PureCompoent之后，就不需要使用SCU生命周期了，直接帮你比较里面的数据是否变化

```jsx
class Footer extends PureComponent{
    // constructor(props){
    //     super(props)
    //     this.state = {
    //         footer:'底部文字'
    //     }
    // }
    render(){
        return (
            <div>
                {this.props.footer}
                {this.props.length}
            </div>
        )
    }



    // SCU的使用方式
    // shouldComponentUpdate(nextProps,nextState){
    //     // 如果下一个的props的footer和state中的footer相同那么没有必要渲染
    //     if(nextProps.footer !== this.props.footer || nextProps.length !== this.props.length){
    //         return true
    //     }
    //     // 否正重新渲染
    //     return false
    // }
    // shouldComponentUpdate(){}
    

    componentDidUpdate(){
        console.log('底部文字重新渲染')
    }
}
```



**2、使用memo：**memo是在函数组件中使用的，类似于PureComponents

```jsx
// 函数组件
function Footer(props) {
    return (
        <div>
            {props.footer}
            {props.length}
        </div>
    )
}

// 定义一个类似与SCU的方法
function areaEqual(prevProps,nextProps){
    if(prevProps.footer !== nextProps.footer && prevProps.length !== nextProps.length){
        return true
    }
    return false
}

// 使用memo方法
React.memo(Footer,areaEqual)
```



## 关于react中组件公共逻辑的抽离

**1、mixin，已经被react弃用**

**2、高阶组件HOC**

**3、Render Props** 





## 关于redux和react-redux的考点

**1、Redux的实现流程**

答：用户页面行为触发一个`Action`，然后，`Store `自动调用 `Reducer`，并且传入两个参数：当前 State 和收到的 Action。Reducer 会返回新的 State 。每当state更新之后，`view`会根据state触发重新渲染。



**2、react-redux的实现原理**

答：Redux作为一个通用模块，主要还是用来处理应用中state的变更，通过react-redux做连接，可以在React+Redux的项目中将两者结合的更好。
react-redux是一个轻量级的封装库，它主要通过两个核心方法实现：

```
Provider：从最外部封装了整个应用，并向connect模块传递store。
Connect： 
    1、包装原组件，将state和action通过props的方式传入到原组件内部。
    2、监听store tree变化，使其包装的原组件可以响应state变化	
```



**3、redux和react-redux的结合使用**

答：



## 关于React-router的考点

**1、路由传值的几种方式**

答：https://www.cnblogs.com/yuerdong/p/10605817.html

**2、React-Router 4中`<Router>`组件有几种类型**

答：

1、BrowserRouter 用于有服务器处理动态请求 ，HashRouter 用于处理静态资源网站

2、HashRouter 页面跳转原理是使用了location.hash、location.replace,并且路径中是包含/#

3、BrowerRouter页面跳转原理是使用了pushState、replaceState,路径不包含#直接定位到/目录下

4、BrowerRouter要与后端配合使用，BrowerRouter所跳转的url是真实的url，在测试的时候是可以跳转的，但是如果部署上去是会出现问题，而hashRouter是不会出现这种错误



**3、如何使用react-router写出一个后台管理的路由嵌套？**



**4、Switch有什么作用？**

答：Switch排他性路由，采用 `<Switch>`，只有**一个路由**会被渲染，并且总是渲染第一个匹配到的组件，更好进行路由匹配。而且匹配成功之后就不会再往下执行操作

# :oden::oden:Webpack:oden::oden:

## 什么是webpack？

答：webpack虽然是可以翻译模块导出语法，但实际上基于node环境的模块打包工具，

​		他的工作是：分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。



## filename和chunkname的区别？

filename 是对应entry入口的文件

chunkFilename 不在`output.entry`中的文件，但是需要单独打包的文件名 设置使用`require.ensure`或者`import`异步加载模块打包后的名称



## 什么是loader？

答：loader是对特定语言和文件的打包方案，能够让浏览器识别并且能运行起来



## css-loader和style-loader的功能？

答： css-loader会根据多个css文件之间的关系进行分析并且将其所有变成一个统一的css

​		style-loader会将这个统一的css文件挂载到html的head标签里面变成css样式





## url-loader和file-loader的区别？

答：1、url-loader依赖file-loader
       2、当使用url-loader加载图片，图片大小小于上限值，则将图片转base64字符串，；否则使用file-loader加载图片，      都是为了提高浏览器加载图片速度。
       3、使用url-loader加载图片比file-loader更优秀



## loader的相关配置

webpack.config.js文件

```js
// webpack 配置文件
// 通过命令行npx webpack 可以直接打包entry指定的文件
// 而不用使用npx webpack 文件名  的命令方式
// 如果webpack配置文件不是webpack.config.js的话 可以使用npx webpack --config (webpack配置文件名) 的方法打包
const path = require('path')
    // 使用loader打包样式、图片
module.exports = {
    // 入口文件
    entry: './src/index.js',
    output: {
        // 打包出口文件名
        filename: "bundle.js",
        path: path.resolve(__dirname, 'dist')
    },
    module: {
        rules: [{
                test: /\.(jpg|png|gif)$/,
                // loader: "file-loader",
                // 可以使用url-loader
                loader: "url-loader",
                options: {
                    // []中的值是占位符意思为按照原来的图片名和后缀打包
                    name: '[name].[ext]',
                    // 这是打包后的文件夹名/dist/images
                    outputPath: 'images/',
                    // limit是文件大小 大于这个值url-loader会按照file-loader打包
                    limit: 10240
                }
            },
            {
                test: /\.css$/,
                // loader 从右往左执行
                use: ['style-loader',
                    {
                        loader: 'css-loader',
                        options: {
                            modules: true,
                        }
                    }
                ],
            },
            {
                test: /\.scss$/,
                // loader 从右往左执行
                // postcss-loader它负责进一步处理 CSS 文件，比如添加浏览器前缀，压缩 CSS、兼容css样式等。
                loader: ['style-loader', 'css-loader', 'scss-loader', 'postcss-loader'],
            }
        ]
    }
}
```

postcss.config.js

```js
module.exports = {
    plugins: [
        // 对于css3的新特性会为其加入新前缀
        require('autoprefixer')
    ]
}
```

## 配置Es6转Es5语法的loader（重要）

1、安装babel-loader和 @babel/core

```js
npm install --save-dev babel-loader @babel/core @babel/preset-env @babel/polyfill 
```

**babel-loader的作用**：这个是babel和webpack连接的桥梁，当遇到js文件时需要使用loader处理

**@babel/core的作用**：这个时babel的核心，是将js文件转化成抽象语法树（ast）的关键，方便各个插件分析语法进行相应的处理

**注意！！：如果想要将ES6语法转化为ES5语法还是不够的，还要使用@babel/preset-env插件以及@babel/polyfill插件**

**@babel/preset-env的作用：** 将Es6语法转化成Es5语法这个才是最关键的转化语法插件（转换新的js语法，但是一些没有的新的api -——————> 比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如`Object.assign`）都不会转码。），**babel仅仅解析语法，但是是否ES5存在这个变量(比如promise.resolve这个语法es5但是promise并不是es5有的变量)他就不知道了**

**@babel/polyfill的作用：**这个插件的作用就是将一些新的api补充进去使得**@babel/preset-env能转码，是corejs和regenerator的集合

2、配置相关的loader语法

```js
    module: {
        rules: [{
            test: /\.js$/,
            exclude: /node_modules/,
            loader: "babel-loader",
            // 注意点1：option 这些选项存在与.babelrc文件中
            // options: {
            //     presets: [
            //         ["@babel/preset-env", {
            //             targets: {
            //                 chrome: 67
            //             },
            //             // 这个的作用就是当使用到新的js的api时才会通知进行@babel/preset-env转码
            //             useBuiltIns: 'usage'
            //         }]
            //     ]
            // }

            // 注意点2：@babel/preset-env仅仅适用于业务代码的转化
            // 当编写一些组件库或者自己写一些工具时，@babel/preset-env往往因为使用全局变量而污染了
            // 所以使用@babel/plugin-transform-runtime往往更合适(使用类似闭包特性 变量不会污染全局)
            // options在.babelrc文件
        }]
    },
```

.babelrc文件中配置optiions（主要时plugin和preset）

**注意!!：@babel/preset-env可以看作多个plugin的集合只不过是预设了而已**

```js
{
    // 使用@babel/preset-env业务
    "presets": [
        ["@babel/preset-env", {
            // 这个的作用就是当使用到新的js的api时才会通知进行@babel/preset-env转码
            // 而是用来"useBuiltIns": "usage"之后就没有必要再js文件中使用 import "@babel/polyfill" 这个语法 
            "useBuiltIns": "usage",
            "corejs": 3,  // corejs的版本
        }]
    ],
    "plugins": []
    
    //使用@babel/plugin-transform-runtime（编写组件库等）
    // "plugins": [
    //     [
    //         "@babel/plugin-transform-runtime",
    //         {
    //             "absoluteRuntime": false,
    //             "corejs": 2,  // corejs的版本
    //             "version": "^7.7.4"
    //         }
    //     ]
    // ]
}
```



## 什么是plugin？

**答：**plugin可以在webpack运行到某一时刻的时候帮我们做某一些事情



## module chunk bundle分别是什么意思，有何区别？

答：module是指任意的文件模块，等价于commonjs中的模块,相当于一个js文件

​       chunks是webpack处理过程中被分组了的modules，多个js文件经过打包后的dist目录下的js文件（有多个模块合成，一个依赖另一个），如代码分割时一个异步加载的chunk可能包含多个module

​       Bunldes是指打包出来的整个文件夹



## es6 module 和 commonJs的区别 ？

1、es module 属于静态引入，在编译时引入 （像import _ from 'lodash' 这种的没有定义变量const引入，也就是不需要代码执行时才去引入，而是在代码编译时就可以直接引入了）

2、commonJs 属于动态引入，在执行时引入（因为会定义变量 const a = require("lodash")，这种就是会在代码执行时才会去引入）

3、只有es module才能treeShaking 因为treeShaking就是在代码打包编译的时候执行的



## Devtools（source-map）是什么？

**介绍：**source-map是一种映射关系，通过这种映射关系在代码发生错误的时候可以定位的源代码错误的位置而不是打包后的代码的错误位置，可以给开发者更好的开发体验

**使用建议：**

​		1.当在开发模式下，建议使用cheap-module-eval-source-map

```js
    mode: 'development',
    devtool: 'cheap-module-eval-source-map',
```

​		2.当在生产模式下，建议使用cheap-module-source-map

```js
	mode: 'production',
    devtool: 'cheap-module-source-map',
```

​	

## 配置热更新要怎么做?

```js
// webpack.config.js文件
const webpack = require("webpack")
devServer:{
    hot:true // 配置hot为true
}
plugins:[
    new webpack.HotModuleReplacementPlugin()
]
```



## DevServer的配置？

 使用devServer配置(这样做的好处是对于服务器来说，可以发送ajax请求或者做其他处理，对于第1种用watch的方式是不可以的)

~~~js
// 1、需要先安装webpack-dev-server
// 2、在webpack.config.js文件下进行配置
    devServer: {
        contentBase: path.join(__dirname, "dist"), // 服务器运行的目录
        port: 9000
    },
        
// 3、运行脚本npm run server 脚本配置 "server":"webpack-dev-server"
```
~~~



## TreeShaking的配置？

**介绍**：treeShaking是一种按需引入功能的方式，它可以减少引入不必要或者没有引用的功能，增加代码的打包速度

**注意**：treeShaking只支持es6的模块引入方式

**配置步骤**（production模式下没必要配置因为已经配置好了，development模式下可以配置）

webpack.config.js文件下

```js
// mode为development
    // 在开发模式下配置treeShaking 但是在生产模式下已经配置好了没必要在配置
    optimization: {
        usedExports: true
    },
```

**注意：**如果遇到一些你不想去使用treeShaking（或者说仅仅是引入而不用去使用的比如一些css文件或者babel/pofill）可以在package.json文件下

```js
{	
    // 可以为false 或者写入你不想要去treeShaking的文件
  "sideEffects": [
    "./src/some-side-effectful-file.js"
  ]
}

```



## 代码分割（CodeSpliting）的配置？

webpack实现JS代码分割有两种方式：同步代码分割、异步代码分割

只需要配置

```js
optimization：{
	splitChunks:{
		chunks:"all"  // 代码分割的类型 async异步 initial同步 all全都分割，同步分割需要配合chcheGroups的vendors选项
}
```

splitChunks里面有多个参数，最主要的出来chunks之外还有一个cacheGroup的参数（当代码分割同步的时候）里面有两个vendors和default，分别对应的是第三方插件的代码分割和除了第三方插件的代码分割

```js
splitChunks: {
    // 代码分割的类型 async异步 initial同步 all全都分割，同步分割需要配合chcheGroups的vendors选项
    chunks: "async", 
    // 分割的最小占用内存
    minSize: 30000,
    // 当一个模块至少用了多少次才进行代码分割
    // 比如这里的意思是当有一个js文件需要引入目标分割文件时就需要被分割
    minChunks: 1,
    //按需加载时并行请求的最大数量 也就是最多进行5次
    maxAsyncRequests: 5,
    //入口点的最大并行请求数
    maxInitialRequests: 3,
    // 分割后文件名连接符
    automaticNameDelimiter: '~',
    name: true,
    // 分割同步代码时的走的方向
    cacheGroups: {
        // 同步分割
        vendors: {
            // 将所有node_modules的插件都打包在这个vendors里面
            // 符合node_modules模块里面的
            test: /[\\/]node_modules[\\/]/,
                // 优先级与vendors对比（都符合的情况下）
            priority: -10
            // 可以配置分割后的文件名 vendors.js
            // filename:'vendors.js'
        },
        // 如果不是第三方插件的情况下
    default: {
            minChunks: 2,
                // 优先级与vendors对比（都符合的情况下）
            priority: -20,
                // 如果一个模块已经被引入了，那么忽略这个模块
            reuseExistingChunk: true
        }
    }
}
```



## 讲一讲proxy的代理？

实现proxy请求转发

​	介绍：在开发环境中可以使用webpack内置的devServer可以便于我们构建一个服务器协助开发，而devServer中的配置proxy是帮助我们实现跨域代理转发请求，让我们可以访问到后台服务器的api

```js
        proxy: {
            // 这里的意思是当访问这个/api的时候事实上就是加上前缀http://www.hyt.com
            //请求到 /api/xxx 现在会被代理到请求 http://www.hyt.com/api/xxx, 例如 /api/user 现在会被代理到请求 http://www.hyt.com/api/user
            // '/api': 'http://www.hyt.com'
            '/api': {
                //如果你想要代码多个路径代理到同一个target下, 你可以使用由一个或多个「具有 context 属性的对象」构成的数组
                context: ['/auth', '/api'],
                target: 'http://www.hyt.com',
                // 这个意思是当访问路劲中有header.json改写成demo.json
                // 如果是 /api : '' 意思就是将这个改成空 
                changeOrigin:true,  // 解决跨域
                pathRewrite: {
                    "header.json": "demo.json",
                     // 这里的api请求发出去是会变成""
                     "/api" : ''
                }
            }
        }
```





# :stew::stew:Git:stew::stew:

## 常用命令

```js
git add . // 实际上就是把文件修改添加到暂存区；
git commit -m //'实际上就是把暂存区的所有内容提交到当前分支。
git status // 查看修改状态
git diff （文件名） // 查看文件名修改的不同地方位置
git log  // 查看日志版本改变
git reset --hard HEAD^ // 回退上个版本号 HEAD是当版本 HEAD^是上一个版本
git reset --hard 0754c9 // 回退上个版本号后 想要回到之前的版本 可以使用这个命令， 但前提是知道git log 后那个git版本的id好0754c9就是id号
git reflog // 用来记录你的每一次命令
git checkout -- 文件名 // 其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。

git checkout -b dev || git switch -c dev // 创建分支dev
git checkout -b dev origin/dev // 在本地创建和远程分支对应的分支，使用git checkout -b branch-name origin/branch-name，本地和远程分支的名称最好一致  这里是本地dev分支与远程dev分支关联
    
git branch --set-upstream-to=origin/dev dev //建立本地分支和远程分支的关联，使用git branch --set-upstream branch-name origin/branch-name；
    
git branch // 命令查看当前分支
git checkkout 分支名 || git switch 分支名// 切换分支
git branch -d dev // 删除分支
git branch -D dev // 强行删除分支

git merge 分支名 // 表示需要合并的分支名 
git merge --no--ff -m '内容' 分支名 // 合并分支和上面个一样 区别是--no--ff表示禁用Fast forward模式
 //加上--no-ff参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而fast forward合并就看不出来曾经做过合并。
```



**提交代码**

```js
git add . // 所有文件加入缓存区
git commit -m '补充' // 提交文件
git pull origin master // 拉去更新代码
git push origin master // 将自己的代码提交到远程分支
```



**合并本地分支**

```js
git switch -c dev // 创建本地分支dev
// 在dev分支里面提交文件到暂存区
git add .
git commit -m "补充"
// 切换会master分支
git switch master
// 合并dev
git merge dev
// 删除dev
git branch -d dev
```



**合并远程分支**

```js
// 1.首先创建一个本地的dev分支
git branch dev
// 2.切换dev分支，将远程dev分支拉取
git switch dev 
git pull origin origin/dev  // 拉取
// 3.切换master分支，合并dev分支，解决冲突，推送上去
git switch master
git merge dev
git commit -m "更新"
git push origin master
```



**解决冲突**

```js
// 在master分支中有一个叫做a.txt文件里面的文件内容是i am master branch
// 提交到暂存区
git add .
git commit -m "master提交"

// 切换会dev分支 在a.txt文件里改变内容：i am dev branch
// 提交到暂存区
git add .
git commit -m "dev分支"

// 回到master分支
git switch master
git merge dev
// 会发生冲突，因为master和dev都会修改了同个地方的内容

// 冲突位置如下 Head指的是当前分支也就是master，下面是dev分支的内容
<<<<<<< HEAD
i am master branch
=======
i am dev branch
>>>>>>> dev
    
// 只要修改冲突的内容就可以了
i am master and dev branch 
    
// 在提交代码
git add .
git commit -m '修改冲突'
```



# :pizza::pizza:微信小程序和公众号:pizza::pizza:

## 小程序的页面结构和四种文件类型

**四种不同类型的文件**

你可以留意到这个项目里边生成了不同类型的文件:

.json 后缀的 JSON 配置文件，用于页面或小程序的配置设置
.wxml 后缀的 WXML 模板文件，用于布局与内容
.wxss 后缀的 WXSS 样式文件，用于具体的样式
.js 后缀的 JS 脚本逻辑文件，用于逻辑处理



**目录结构**

小程序包含一个描述整体程序的 app 和多个描述各自页面的 page。

一个小程序主体部分由三个文件组成，必须放在项目的根目录，如下：

| 文件     | 必需 | 作用             |
| -------- | ---- | ---------------- |
| app.js   | 是   | 小程序逻辑       |
| app.json | 是   | 小程序公共配置   |
| app.wxss | 否   | 小程序公共样式表 |

一个小程序页面由四个文件组成，分别是：

| 文件类型 | 必需 | 作用       |
| -------- | ---- | ---------- |
| js       | 是   | 页面逻辑   |
| wxml     | 是   | 页面结构   |
| json     | 否   | 页面配置   |
| wxss     | 否   | 页面样式表 |

注意：为了方便开发者减少配置项，描述页面的四个文件必须具有相同的路径与文件名。



## 小程序常用的组件

### 1、view

**说明：类似与div标签，块级标签**



### 2、swiper

**说明：滑块视图容器，可以设置轮播效果**



### 3、scroll-view

参考：https://www.jianshu.com/p/0599cf0c44ce

**说明：scroll-view可以实现竖向滑动和横向滑动、可滚动视图区域**

**竖向滑动：**1、设置scroll-y，2、给scroll-view设置一个height高度

**横向滑动：**1、设置scroll-x，2、设置scroll-view的样式属性white-space为wrap，3、设置scroll-view里面的元素的display为inline-block



### 4、cover-view

**说明：覆盖在原生组件之上的文本视图。可覆盖的原生组件包括 [map](https://developers.weixin.qq.com/miniprogram/dev/component/map.html)、[video](https://developers.weixin.qq.com/miniprogram/dev/component/video.html)、[canvas](https://developers.weixin.qq.com/miniprogram/dev/component/canvas.html)、[camera](https://developers.weixin.qq.com/miniprogram/dev/component/camera.html)、[live-player](https://developers.weixin.qq.com/miniprogram/dev/component/live-player.html)**



### 5、cover-image

**说明：覆盖在原生组件之上的图片视图。可覆盖的原生组件同[cover-view](https://developers.weixin.qq.com/miniprogram/dev/component/cover-view.html)，支持嵌套在[cover-view](https://developers.weixin.qq.com/miniprogram/dev/component/cover-view.html)里。**



## 小程序的数据绑定、数据渲染、条件渲染

**数据绑定：**通过{{}}的方式对数据进行绑定

**数据渲染：**通过wx:for对数据进行渲染，同时使用 wx:for-item 可以指定数组当前元素的变量名,使用 wx:for-index 可以指定数组当前下标的变量名：

```html
<view wx:for="{{array}}" wx:for-index="idx" wx:for-item="itemName">
  {{idx}}: {{itemName.message}}
</view>
```

**条件渲染：**通过wx:if和wx:else进行条件渲染



## 小程序事件以及事件绑定

**事件类型：**

tap：点击事件；

longtap：长按事件；

touchstart：触摸开始；

touchend：触摸结束；

touchcansce：取消触摸；

**事件绑定：**bind绑定（不阻止事件冒泡）、catch绑定（阻止事件冒泡）



## 小程序转发分享功能

**小程序转发功能有两种：**一种是button触发，另外一种是触发顶部的转发按钮，这两种都会触发页面的生命周期函数onShareAppMessage

```js
// 第一种是通过button
<button open-type="share" bindtap="shareInfo">转发</button>
// 第二种是通过顶部直接触发生命周期


// js文件中，两种都会触发这个生命周期
  onShareAppMessage(res){
    if(res.from === 'button'){
      console.log('我是button')
    }
    return {
      title: '转发',
      path: '/pages/index/community/topic/topic',
      success: function (res) {
        console.log('成功', res)
      }
    }
  }
```



## 小程序唤醒客服聊天功能

```js
<button open-type="contact">客服聊天</button>
```



## 小程序的文件作用域

**定义：**在javaScript文件中声明的变量和函数只在该文件中有效;不同的文件中可以生命相同的名字的变量和函数，不会相互影响。

```js
//app.js
app({
    globalData：1
})
```



```js
// a.js
// The localValue can only be used in file a.js.
var localValue = 'a'
// Get the app instance.
var app = getApp()
// Get the global data and change it.
app.globalData++
```



```js
// b.js
// You can redefine localValue in file b.js, without interference with the localValue in a.js.
var localValue = 'b'
// If a.js it run before b.js, now the globalData shoule be 2.
console.log(getApp().globalData)
```



## 小程序image高度自适应及裁剪问题

image组件中有mode属性可以设置图片的如何展现，有4种缩放方式，9种裁剪方式

(一).使用mode：widthFix

widthFix：宽度不变，高度自动变化，保持原图宽高比不变。
首先我们先设置image的mode为widthFix，然后给图片加一个固定rpx的宽度，比如：730rpx。
这样图片也可以自适应了。。因为小程序的rpx本身就是一个自适应显示的单位

(二).使用bindload绑定函数动态自适应。
我们可以给image绑定一个函数，这个函数，如上面的bindload说明一样，我们可以获取到原图的宽度和高度。
然后计算他们的宽高比率。。然后设置一个宽度大小（rpx），最后通过style动态设置image的宽高。代码如下：

```html
<image src="../uploads/2.jpg" bindload="imageLoad"
style="width:{{imgwidth}}rpx; height:{{imgheight }}rpx;"></image>
```



```js
//获取应用实例 
var app = getApp()
Page({
	data: {
		screenWidth: 0,
		screenHeight:0,
		imgwidth:0,
		imgheight:0,
	},
	onLoad: function() {
		var _this = this;
		wx.getSystemInfo({
			success: function(res) {
				_this.setData({
					screenHeight: res.windowHeight,
					screenWidth: res.windowWidth,
				});
			}
		});
 
	},
  	imageLoad: function(e) {
  		var _this=this;
		var $width=e.detail.width,    //获取图片真实宽度
		    $height=e.detail.height,
		    ratio=$width/$height;   //图片的真实宽高比例
		var viewWidth=500,           //设置图片显示宽度，
            viewHeight=500/ratio;    //计算的高度值   
		this.setData({
			imgwidth:viewWidth,
		    imgheight:viewHeight
		})
  	}
})
```



## 微信小程序能长按识别二维码吗？

答：在image组件中的图片是不支持识别微信小程序的，但是在wx.previewImage点击图片之后可以长按识别二维码



## 微信小程序如何获取用户信息？

使用button组件中的open-type属性（getUserInfo），同时绑定getUserInfo方法，但是这种方法只是在前端里面获取用户的信息，后端并没有获取到用户的信息，所以需要使用wx.login获取code码换取openId存入后端

```js
<button open-type="getUserInfo" class='show-author' bindgetuserinfo="getUserInfo">
```

在js文件种

```js
  getUserInfo: function(e) {
    console.log(e)
    // 将用户信息保存在全局种
    app.globalData.userInfo = e.detail.userInfo
    this.setData({
      userInfo: e.detail.userInfo,
      hasUserInfo: true
    })
  }
```



## 微信小程序如何申请微信支付？

注意：以个人名义申请的小程序是没有微信支付的

登录微信后台找到微信支付，有两个选项：申请一个新的商户号和绑定一个原有的商户号，如果是绑定一个商户号那么根据流程填写相关信息即可，如果是申请一个新的那么需要填写申请信息，查收邮件才能申请一个商户号



## 如何给微信小程序的背景填充颜色?

在page里面直接填充颜色就好了

```
page{
	background:red
}
```



## 微信jsApi和jsSdk的区别是什么？



**jssdk是h5支付，h5页面不在微信客户端内的支付接口，比如在其他App中使用微信支付；**

**jsapi是h5页面在微信客户端中使用的支付接口，比如微信公众号支付。**



## 微信支付相关(个人理解，如果后续有相关经验修改)

官方文档：https://pay.weixin.qq.com/wiki/doc/api/index.html

**微信支付有三种：jsApi支付、引入js-sdk支付、最后就是小程序的支付（wx.requestPayment）**

**支付方式有多种，如：付款码支付、jsApi支付、人脸支付、Native支付、h5支付、小程序支付等等**



### **1、js-sdk支付方式流程及步骤（使用步骤）**

**步骤一：绑定域名**

先登录微信公众平台进入“公众号设置”的“功能设置”里填写“JS接口安全域名”

**步骤二：引入JS文件**

在需要调用JS接口的页面引入如下JS文件，（支持https）：http://res.wx.qq.com/open/js/jweixin-1.6.0.js

如需进一步提升服务稳定性，当上述资源不可访问时，可改访问：http://res2.wx.qq.com/open/js/jweixin-1.6.0.js （支持https）。

备注：支持使用 AMD/CMD 标准模块加载方法加载

**步骤三：通过config接口注入权限验证配置**

```js
wx.config({
  debug: true, // 开启调试模式,调用的所有api的返回值会在客户端alert出来，若要查看传入的参数，可以在pc端打开，参数信息会通过log打出，仅在pc端时才会打印。
  appId: '', // 必填，公众号的唯一标识
  timestamp: , // 必填，生成签名的时间戳
  nonceStr: '', // 必填，生成签名的随机串
  signature: '',// 必填，签名
  jsApiList: [] // 必填，需要使用的JS接口列表
});
```

**步骤四：通过ready接口处理成功验证**

```js
wx.ready(function(){
  // config信息验证后会执行ready方法，所有接口调用都必须在config接口获得结果之后，config是一个客户端的异步操作，所以如果需要在页面加载时就调用相关接口，则须把相关接口放在ready函数中调用来确保正确执行。对于用户触发时才调用的接口，则可以直接调用，不需要放在ready函数中。
 		   // 例如：分享到朋友圈
            wx.onMenuShareTimeline({
                title,
                link,
                imgUrl,
                success() {
                    success && success();
                },
                cancel() {
                    cancel && cancel();
                },
                fail() {
                    fail && fail();
                },
            });
});
```

**步骤五：通过error接口处理失败验证**

```js
wx.error(function(res){
  // config信息验证失败会执行error函数，如签名过期导致验证失败，具体错误信息可以打开config的debug模式查看，也可以在返回的res参数中查看，对于SPA可以在这里更新签名。
});
```



##### **2、js-api支付方式及步骤**

```js
function onBridgeReady(){
   WeixinJSBridge.invoke(
      'getBrandWCPayRequest', {
         "appId":"wx2421b1c4370ec43b",     //公众号名称，由商户传入     
         "timeStamp":"1395712654",         //时间戳，自1970年以来的秒数     
         "nonceStr":"e61463f8efa94090b1f366cccfbbb444", //随机串     
         "package":"prepay_id=u802345jgfjsdfgsdg888",     
         "signType":"MD5",         //微信签名方式：     
         "paySign":"70EA570631E4BB79628FBCA90534C63FF7FADD89" //微信签名 
      },
      function(res){
      if(res.err_msg == "get_brand_wcpay_request:ok" ){
      // 使用以上方式判断前端返回,微信团队郑重提示：
            //res.err_msg将在用户支付成功后返回ok，但并不保证它绝对可靠。
      } 
   }); 
}
// 这里是判断是否存在这个内置对象
if (typeof WeixinJSBridge == "undefined"){
  // 判断Ie浏览器
   if( document.addEventListener ){
       document.addEventListener('WeixinJSBridgeReady', onBridgeReady, false);
   }else if (document.attachEvent){
       document.attachEvent('WeixinJSBridgeReady', onBridgeReady); 
       document.attachEvent('onWeixinJSBridgeReady', onBridgeReady);
   }
}else{
   onBridgeReady();
}
```



#### 3、小程序支付步骤（使用wx.requestPayment）

![小程序支付时序图](https://pay.weixin.qq.com/wiki/doc/api/img/wxa-7-2.jpg)

参考：https://www.cnblogs.com/catcher1994/p/6664404.html

**第一步首先通过wx.login拿到需要的code，拿到这个code了之后在成功的回调（回调里面有后端返回的数据）里面调用wx.requestPayment方法，然后传入requestPayment所需要的参数，小程序端的任务就完成了**

```js
Page({
    data: {
        txtOrderCode: ''
    },
    pay: function () {
        var ordercode = this.data.txtOrderCode;
        wx.login({
          success: function (res) {
            if (res.code) {
              wx.request({
                url: 'https://www.yourdomain.com/pay',
                data: {
                  code: res.code,//要去换取openid的登录凭证
                  ordercode: ordercode
                },
                method: 'GET',
                  // 成功的回调里面的res里面有requestPayment的所需要参数
                success: function (res) {
                  console.log(res.data)
                  wx.requestPayment({
                    timeStamp: res.data.timeStamp,
                    nonceStr: res.data.nonceStr,
                    package: res.data.package,
                    signType: 'MD5',
                    paySign: res.data.paySign,
                    success: function (res) {
                      // success
                      console.log(res);
                    },
                    fail: function (res) {
                      // fail
                      console.log(res);
                    },
                    complete: function (res) {
                      // complete
                      console.log(res);
                    }
                  })
                }
              })
            } else {
              console.log('获取用户登录态失败！' + res.errMsg)
            }
          }
        });
    },
    getOrderCode: function (event) {
        this.setData({
          txtOrderCode: event.detail.value
        });
    }
})
```



### 2、h5支付流程



**1、用户下单时选择微信支付**

**2、商户进行业务逻辑处理并调用微信统一下单接口，微信H5交易类型为`trade_type=MWEB`。**

**3、调用下单接口成功时，微信会返回包含支付跳转URL等相关参数，商户通过参数`mweb_url`调起支付中间页。**

**4、在中间页微信会进行H5权限的校验**

**5、支付成功，微信会向商户发送异步结果通知。**





## 微信小程序的生命周期有哪些（全局5种、页面8种、组件生命周期6种、组件所在页面生命周期3种）

**全局App生命周期**

```js
App({
  onLaunch (options) {
    // 
    console.log('小程序初始化')
 
  },
  onShow(options) {
    console.log('监听小程序启动或切前台')
  },
  onHide() {
    console.log('监听小程序切后台')
  },
 
  onError(msg) {
    console.log('错误监听函数')
  },
  onPageNotFound(res) {
    console.log('小程序要打开的页面不存在时触发');
    wx.redirectTo({ // 重定向
      url: 'pages/...'
    }) // 如果是 tabbar 页面，请使用 wx.switchTab
  }
})
```

**页面内生命周期**

```js
Page({
 
  /**
   * 页面的初始数据
   */
  data: {
 
  },
 
  /**
   * 生命周期函数--监听页面加载
   * 一个页面只会调用一次，可以在onLoad中获取当前页面从上一级页面带过来的参数
   */
  onLoad: function (options) {
 
  },
 
  /**
   * 生命周期函数--监听页面初次渲染完成
   * 一个页面只会调用一次，代表当前页面已经准备妥当，可以和视图层进行交互
   */
  onReady: function () {
 
  },
 
  /**
   * 生命周期函数--监听页面显示
   * 每次打开页面都会调用一次，如果需要每次进入页面时刷新数据，可在此方法中实现
   */
  onShow: function () {
 
  },
 
  /**
   * 生命周期函数--监听页面隐藏
   * 当navigateTo或底部tab切换时调用
   */
  onHide: function () {
 
  },
 
  /**
   * 生命周期函数--监听页面卸载
   * 当redirectTo或navigateBack的时候调用
   */
  onUnload: function () {
 
  },
 
  /**
   * 页面相关事件处理函数--监听用户下拉动作
   */
  onPullDownRefresh: function () {
 
  },
 
  /**
   * 页面上拉触底事件的处理函数
   */
  onReachBottom: function () {
 
  },
 
  /**
   * 用户点击右上角分享
   */
  onShareAppMessage: function () {
 
  }
})
```

组件生命周期

```js
// pages/myComponent.js
Component({
  /**
   * 组件的属性列表
   */
  properties: {
 
  },
 
  /**
   * 组件的初始数据
   */
  data: {
 
  },
 
  /**
   * 组件的方法列表
   */
  methods: {
 
  },
 
  /*组件生命周期*/ 
  lifetimes: {
    created() {
      console.log("在组件实例刚刚被创建时执行")
    },
    attached() { 
      console.log("在组件实例进入页面节点树时执行")
    },
    ready() {
      console.log("在组件在视图层布局完成后执行")
    },
    moved() {
      console.log("在组件实例被移动到节点树另一个位置时执行")
    },
    detached() {
      console.log("在组件实例被从页面节点树移除时执行")
    },
    error() {
      console.log("每当组件方法抛出错误时执行")
    },
    /*组件所在页面的生命周期 */
    pageLifetimes: {
      show: function () {
        // 页面被展示
        console.log("页面被展示")
      },
      hide: function () {
        // 页面被隐藏
        console.log("页面被隐藏")
      },
      resize: function (size) {
        // 页面尺寸变化
        console.log("页面尺寸变化")
      }
    }
  }
})
```





## OpenId和UnionId的区别

**openid同一用户同一应用唯一，unionid同一用户不同应用唯一。**

这里的不同应用是指在同一微信开发平台下的不同应用

为了识别用户，每个用户针对每个公众号会产生一个安全的openid。

如果需要在多公众号、移动应用之间做用户共通，则需要前往微信开放平台，将这些公众号和应用绑定到一个开放平台账号下，绑定后，一个用户虽然对多个公众号和应用有多个不同的openid，但他对所有这些同一开放平台账号下的公众号和应用，只有一个unionid。一个微信开放平台只可以绑定10个公众号。

**总结：**

`OpenId` 是一个用户对于一个小程序／公众号的标识，开发者可以通过这个标识识别出用户。

`UnionId` 是一个用户对于同主体微信小程序／公众号／APP的标识，开发者需要在微信开放平台下绑定相同账号的主体。开发者可通过UnionId，实现多个小程序、公众号、甚至APP 之间的数据互通了。

**获取用户的openid是无需用户同意的，获取用户的基本信息则需要用户同意**



## 微信小程序的关键api有哪些？

- [`wx.login`](https://developers.weixin.qq.com/miniprogram/dev/api/api-login.html) 官方提供的登录能力

- [`wx.checkSession`](https://developers.weixin.qq.com/miniprogram/dev/api/signature.html#wxchecksessionobject) 校验用户当前的session_key是否有效

- [`wx.authorize`](https://developers.weixin.qq.com/miniprogram/dev/api/authorize.html) 提前向用户发起授权请求

  ```js
  // 可以通过 wx.getSetting 先查询一下用户是否授权了 "scope.record" 这个 scope
  wx.getSetting({
    success(res) {
      if (!res.authSetting['scope.record']) {
        wx.authorize({
          scope: 'scope.record',
          success () {
            // 用户已经同意小程序使用录音功能，后续调用 wx.startRecord 接口不会弹窗询问
            wx.startRecord()
          }
        })
      }
    }
  })
  ```

  

- [`wx.getUserInfo`](https://developers.weixin.qq.com/miniprogram/dev/api/api-login.html) 获取用户基本信息

- **wx.previewImage**   在新页面中全屏预览图片。预览的过程中用户可以进行保存图片、发送给朋友等操作。



## 小程序的渲染逻辑

在渲染层将 `WXML` 先转换为 `js` 对象也就是虚拟 `DOM`

在逻辑层将虚拟 `DOM` 对象生成真实 `DOM` 树，交给渲染层渲染

当视图有数据需更新时，逻辑层调用小程序宿主环境提供的 `setData` 方法将数据从逻辑层传递到渲染层

经过对比前后差异 ( diff算法 )，把差异应用在真实的 `Dom` 树上，渲染出正确的 UI 界面完成视图更新



## 小程序和H5的区别

参考：https://juejin.im/post/5e7e2cd86fb9a03c7d3ceb0c#heading-9

**运行环境方面**

**运行机制**

**系统权限**

**渲染机制**



## 微信小程序 session_key 的作用是什么

A.session_key 有两个作用：

1. 校验用户信息(wx.getUserInfo(OBJECT)返回的signature);
2. 解密(wx.getUserInfo(OBJECT)返回的encryptedData);

B.按照官方的说法，wx.checksession是用来检查 wx.login(OBJECT) 的时效性，判断登录是否过期;

疑惑的是（openid，unionid ）都是用户唯一标识，不会因为wx.login(OBJECT)的过期而改变，所以要是没有使用wx.getUserInfo(OBJECT)获得的用户信息，确实没必要使用wx.checksession()来检查wx.login(OBJECT) 是否过期；

如果使用了wx.getUserInfo(OBJECT)获得的用户信息，还是有必要使用wx.checksession()来检查wx.login(OBJECT) 是否过期的，因为用户有可能修改了头像、昵称、城市，省份等信息，可以通过检查wx.login(OBJECT) 是否过期来更新着些信息；





## 小程序的传值方式有什么？

参考：https://www.jianshu.com/p/287ab6081153

1、url传值

2、全局传值

3、页面自定义传值

4、form表单传值

5、页面路由栈中直接获取和操作目标Page对象传值

## 小程序的wxss和css有什么不同？

1、像素单位的不同rpx 以iphone6为例 750rpx = 325px 

2、可以通过@import方式导入外部样式



## 微信小程序与vue区别

**生命周期不一样**，微信小程序生命周期比较简单

**数据绑定也不同**，微信小程序数据绑定需要使用`{{}}，vue` 直接使用v-bind（或者：）

**控制元素的显示和隐藏**，小程序中，使用`wx-if`和`hidden` 控制元素的显示和隐藏，vue`中，使用 `v-if`和 `v-show`

**事件处理不同**，小程序中，全用  `bindtap(bind+event)`，或者  `catchtap(catch+event)`绑定事件,vue：使用`v-on:event` 绑定事件，或者使用`@event`绑定事件

**数据双向绑定**也不一样在 `vue`中,只需要再表单元素上加上 `v-model`,然后再绑定 `data`中对应的一个值，当表单元素内容发生变化时，`data`中对应的值也会相应改变，这是 `vue`非常 `nice` 的一点。微信小程序必须获取到表单元素，改变的值，然后再把值赋给一个 `data`中声明的变量。



## 怎么解决小程序的异步请求问题

小程序里面的api有很多是异步请求的比如：wx.request方法，当我们去网络请求的时候，如果网络请求太慢就直接执行下一段代码，会发生错误，那么就要使用promise来控制，当然也可以使用async和await，这样就可以确保网络请求完成在执行后面的代码



## 如何实现下拉刷新

首先在全局 `config` 中的 `window`配置 `enablePullDownRefresh` ，在 `Page` 中定义`onPullDownRefresh` 钩子函数,到达下拉刷新条件后，该钩子函数执行，发起请求方法 请求返回后，调用`wx.stopPullDownRefresh`停止下拉刷新



## bindtap和catchtap的区别是什么

他们的不同点主要是`bindtap`是不会阻止冒泡事件的，`catchtap`是阻值冒泡的



## 小程序wxml与标准的html的异同？

```
相同：
```

- 都是用来描述页面的结构；
- 都由标签、属性等构成；

```
不同：
```

- 标签名字不一样，且小程序标签更少，单一标签更多；
- 多了一些`wx:if` 这样的属性以及 `{{ }}`这样的表达式
- WXML仅能在微信小程序开发者工具中预览，而`HTML`可以在浏览器内预览；
- 组件封装不同， `WXML`对组件进行了重新封装，
- 小程序运行在`JS Core`内，没有`DOM树`和`window`对象，小程序中无法使用`window`对象和`document`对象。



## 小程序对wx:if 和 hidden使用的理解？

- `wx:if`有更高的切换消耗。
- `hidden` 有更高的初始渲染消耗。
- 因此，如果需要频繁切换的情景下，用 `hidden` 更好，如果在运行时条件不大可能改变则`wx:if` 较好。



## app.json 是对当前小程序的全局配置，讲述三个配置各个项的含义？

- \```pages字段`` —— 用于描述当前小程序所有页面路径，这是为了让微信客户端知道当前你的小程序页面定义在哪个目录。
- `window字段` —— 小程序所有页面的顶部背景颜色，文字颜色定义在这里的
- `tab字段`—小程序全局顶部或底部`tab`



## 小程序onPageScroll方法的使用注意什么？

由于此方法调用频繁，不需要时，可以去掉，不要保留空方法，并且使用`onPageScroll`时，尽量避免使用`setData()`，尽量减少`setData()`的使用频次。



## 小程序同步API和异步API使用时注意事项？

`wx.setStorageSync`是以Sync结尾的API为同步API，使用时使用`try-catch`来查看异常，如果判定API为异步，可以在其回调方法`success、fail、complete`中进行下一步操作。



## 简述下 `wx.navigateTo(), wx.redirectTo(), wx.switchTab(), wx.navigateBack(), wx.reLaunch()`的区别

- `wx.navigateTo()：`保留当前页面，跳转到应用内的某个页面。但是不能跳到 `tabbar` 页面
- `wx.redirectTo()：`关闭当前页面，跳转到应用内的某个页面。但是不允许跳转到 `tabbar` 页面
- `wx.switchTab()：`跳转到 `abBar` 页面，并关闭其他所有非 `tabBar` 页面
- `wx.navigateBack()：`关闭当前页面，返回上一页面或多级页面。可通过`getCurrentPages()` 获取当前的页面栈，决定需要返回几层
- `wx.reLaunch()：`关闭所有页面，打开到应用内的某个页面



# :bento::bento:http协议:bento::bento:

## **content-type的常见类型：**

参考：https://blog.csdn.net/wahaha13168/article/details/81236090

 application/x-www-form-urlencoded ： <form encType="">中默认的encType，form表单数据被编码为key/value格式发送到服务器（表单默认的提交数据的格式）

 multipart/form-data ： 需要在表单中进行文件上传时，就需要使用该格式

 application/json  ： JSON数据格式

 text/plain ：纯文本格式

 text/html ： HTML格式

​	

## http的特点

**(1) 简单快速**
 每个资源得到URI是固定的，想访问某个资源，只需要输入这个资源对应的URI就可以了。
 (URL(Uniform Resource Location)统一资源定位符，URI(Uniform Resource Identifier)统一资源标识符。URL是URI的子集，URL就是用定位的方式实现的URI。)

**(2) 灵活**
 每个HTTP头部有个`Content-Type`，一个HTTP协议通过设置不同的`Content-Type`值，可以完成不同类型的资源的传输。

**(3) 无连接**
 限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接。采用这种方式可以节省传输时间。

**(4) 无状态**
 HTTP协议对于事务处理没有记忆能力。知乎一句简单回单很好：就是第二次来你无法识别它曾经来过。(人生若只如初见)
 但是，在通过增加cookie和session机制的前提下，现在的网络请求其实是有状态的



## HTTP报文

HTTP报文分为**请求报文**和**响应报文**

- **(1) 请求报文：由 请求行、请求头、空行和请求体组成**

  ① 

  请求行：包含HTTP方法，页面地址、HTTP协议和版本

  ② 

  请求头：包含一些key: value值来告诉服务端需要哪些内容，要注意哪些类型

  ③ 

  空行： 最后一个请求头之后是一个空行，发送回车符和换行符，通知服务器以下不再有请求头。

  ④ 

  请求体：即请求正文。

  如下是一个HTTP请求报文示例：

  ![img](https:////upload-images.jianshu.io/upload_images/3735432-9567848162bcf631.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/897/format/webp)

  HTTP请求报文

- **(2) 响应报文：由 状态行、响应头、空行和响应体组成**

  ① 

  状态行：由3部分组成，分别为：协议版本，状态码，状态码描述，之间由空格分隔

  ② 

  响应头：与请求头部类似，为响应报文添加了一些附加信息

  ③ 

  空行： 最后一个响应头之后是一个空行，发送回车符和换行符，通知客户端以下不再有响应头。

  ④ 

  响应体：即响应正文。

  如下是一个HTTP响应报文示例：

  ![img](https:////upload-images.jianshu.io/upload_images/3735432-9fc4834b92a23164.jpg?imageMogr2/auto-orient/strip|imageView2/2/w/629/format/webp)



## POST和GET的区别

主要的区别有如下几点：

- ① GET在浏览器**回退**是无害的，而POST会再次提交请求
- ② GET产生的URL地址可以被**收藏**，而POST不可以
- ③ GET请求会被浏览器主动**缓存**，而POST不会，除非手动设置
- ④ GET请求参数会被完整保留在**浏览器历史记录**里，而POST中的参数不会被保留
- ⑤ GET请求在URL中传送的参数长度是有限制的，基本为**2Kb**，所以传送参数不要太长，否则会被浏览器截断，而POST没有限制
- ⑥ GET**参数**通过URL传递，而POST放在Request body中
- ⑦ POST比GET**安全**，因为GET请求参数直接暴露在URL上，所以不能用来传递敏感信息
- 

## HTTP状态码

- ① **1xx**：指示信息。表示请求已经接受，继续处理
- ② **2xx**：成功。表示请求已被成功接受
- ③ **3xx**：重定向。要完成请求必须进行更进一步的操作
- ④ **4xx**：客户端错误。请求有有语法错误或请求无法实现
- ⑤ **5xx**：服务器错误。服务器未能实现合法的请求

**常用HTTP状态码：**
 200 OK：客户端请求成功
 206 Partual Content：客户发送了一个带有Range头的GET请求，服务器完成了它
 301 Moved Permanently：所有请求的页面已经转移至新的URL（**永久重定向**）
 302 Found：所有请求的页面已经临时转移到新的URL（**临时重定向**）
 304 Not Modifiled：客户端有缓冲的文档并发出了一个条件性的请求，服务器告诉客户，原来缓冲的文档还可以继续使用
 400 Bad Request：客户端请求有语法错误，不能被服务器所理解
 401 Unauthorized：请求未经授权，这个状态码必须和WWW-Authenticate报头域一起使用
 403 Forbidden：请求页面禁止被访问，一般某个地址只允许服务端访问，客服端访问时就会给出403
 404 Not Found：请求资源不存在
 500 Internal Server Error：服务器错误
 503 Server Unavailable：请求未完成，服务器临时过载或宕机，一段时间后可能恢复正常



## 什么是管线化？

在**持久连接**(Keep-Alive)的情况下，某个连接上消息的传递类似于：
 **请求1 —> 响应1 —> 请求2 —> 响应2 —> 请求3 —> 响应3**

这个过程中请求一直没有断开的

HTTP管线化(HTTP pipelining) 连接上的消息变成了这样：
 **请求1 —> 请求2 —> 请求3 —> 响应1 —> 响应2 —> 响应3**

请求通道是持久建立的，但并不是请求一次，响应一次，而是将所有请求一次**打包**过去，然后响应也一次打包回来。

##### (2) 管线化特点

- 管线化通过持久连接完成，仅HTTP/ 1.1支持此技术
- 只有GET和HEAD请求可以进行管线化，而POST则有所限制
- 初次创建连接时，不应启动管线机制，因为对方(服务器)不一定支持HTTP/1.1版本协议
- 管线化不会影响响应到来的顺序，如上面箭头所示，响应返回的顺序并未改变。
- 开启管线化很可能并不会带来性能上的大幅度提升，而且很多服务端和代理程序对管线化支持并不好，因此现代浏览器像 Chrome 和 Firefox 默认并未开启管线化支持。





## 什么是三次握手协议  (tcp/ip建立连接的过程)

三次握手协议指的是在发送数据的准备阶段，服务器与客户端之间需要进行三次交互。

具体过程如下：

第一次握手：建立连接时，客户端向服务器发送一个SYN包(握手信号)，并计入SYN_SENT状态，等待服务器确认。

第二层握手：服务器收到SYN包，必须确认客户端的SYN，同时自己也发送一个SYN包，即SYN+ACK包(接收到消息并响应)，此           时服务器进入SYN_SENT状态。

第三次握手：客户端收到服务器的SYN+ACK包，并向服务器发送确认包ACK，此包发送完毕，客户端和服务器进入                    Established(已建立的，确认的)状态。即TCP连接成功，完成三次握手。

此后，服务器和客户端就可以开始传送数据。在上述三次握手协议中，服务器还在维护一个未连接队列，等待其他客户端的连接请求，若能顺利完成三次握手协议，则服务器也可以与该客户端进行数据的传输。

二：三次握手的核心思想

1：TCP作为一种可靠传输控制协议，其核心思想是：既要保证数据可靠传输，又要提高传输效率，而用三次恰恰可以满足以上两个方面的要求。

2：三次是保证双方互相明确对方能收，能发的最低值。理论上讲不论握手多少次都不能确认一条消息是“可靠”的，但通过三次握手后，至少可以确认tcp/ip协议是“可用”的。在此基础上，继续提高握手次数，不过是提高“它是可用的”这个结论的可信程度。

3：可以将三次握手过程形象的归纳如下：

​                  1：A发，B收，B知道A能发；

​                  2：B发，A收，A知道B能发能收；

​                  3：A发，B收，B知道A能收。

4：“三次握手”的本质是：信道是不可靠的，但是通信双方需要就某个协议达成一致，而要解决这个问题，无论你在消息中包含什么信息，三次通信是理论上的最小值。因为三次握手不是TCP本身的要求，而是为了满足“在不可靠的信道上可靠的传输信息”这一需要导致的。



## 三次握手四次挥手的简单描述

**三次握手：**首先客户端发送一个syn包给服务端，服务端收到了客户端的syn包后发送一个syn+ack确认包给客户端表示已经收到客户端的消息，最后客户端发送ack确认表示确认，建立连接

**四次挥手：**客户端发送FIN包向服务端提出断开连接请求，服务器收到发送ACK确认，判断数据是否已经传输完全，如果没有等数据传输完成，而后发送FIN给客户端，客户端收到发送ACK给服务端，断开连接

# :spaghetti::spaghetti:webSocket:spaghetti::spaghetti:

## 什么是webSocket？

允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输



# :custard::custard:浏览器:custard::custard:



## 浏览器的渲染

## 浏览器的跨域

跨域的方法有：

- 1)jsonp
- 2)iframe
- 3)postMessage
- 4)CORS
- 5)webscoket
- 6)反向代理服务器



**CORS请求又分为简单请求和非简单请求**



#### 浏览器的内存

浏览器（通常指）的内存分配，64位系统下大约为1.4GB，在32位系统下大约为0.7G。

我们通常定义变量时候就完成了分配内存，使用时候是对内存的读写操作，内存的释放依赖于浏览器的垃圾回收机制。

**造成内存泄露**

- 1.意外的全局变量引起的内存泄漏。
- 2.闭包引起的内存泄漏
- 3.没有清理的DOM元素引用
- 4.被遗忘的定时器或者回调
- 5.监听事件



#### 浏览器的执行机制

javascript是一门单线程语言， Event Loop是javascript的执行机制libuv

需明白什么叫事件循环事件，微任务，宏任务。以及如何运行。

# @@简单介绍一下登录流程有什么？@@



cookie和session登录方式

token登录方式

sso单点登录

**oAuth第三方登录方式（重点）**

具体可以参考阮一峰老师的oAuth登录方式

oAuth的登录方式有四种







# @@源码



## vue相关

### 1、diff算法

**为什么加key会提高diff计算速度。**

  经过旧头新头、旧尾新尾、旧头新尾、旧尾新头四次交叉比对后，都没有匹配到值得比对的节点，这时如果新节点有key的话。可以通过map直接获得值得对比的旧节点的下标，如果没有key的话，就要通过循环旧节点数组用sameVnode方法判断新节点和该旧节点是否值得比较，值得就返回该旧节点的下标。显然通过map比通过循环数组的计算速度来的快。

**什么是diff算法？**

  对于渲染watcher触发时会执行`vm._update(vm._render(), hydrating)`，在`vm._undata`方法中会调用`vm.__patch__`，而`vm.__patch__`指向patch方法，diff计算是指在调用patch方法开始，用sameVnode方法判断节点是否值得比较，若不值得直接新节点替换旧节点后结束。值得对比进入patchVnode方法，分别处理一下几种情况，若新旧节点都有文本节点，新节点下的文本节点直接替换旧节点下的文本节点，如果新节点有子节点，旧节点没有子节点，那么直接把新节点查到旧节点的父级中，如果新节点没有子节点，旧节点有子节点，那么旧节点的父级下的子节点都删了。如果新旧节点都有子节点，进入updateChildren方法，通过旧头新头、旧尾新尾、旧头新尾、旧尾新头四次交叉比对，如果值得对比再进入patchVnode方法，如果都不值得对比，有key用map获得值得对比的旧节点，没有key通过循环旧节点获得值得对比的旧节点。当新节点都对比完，旧节点还没对比完，将还没对比完的旧节点删掉。当旧节点都对比完，新节点还没对比完，将新节点添加到最后一个对比过的新节点后面，完成diff计算。







# @@编译@@

## babel:

参考：https://zhuanlan.zhihu.com/p/31096468




