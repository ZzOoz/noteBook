# JS&Es6知识总结

# JS知识体系

### js基础知识（ECMA262标准）

##### 知识：变量类型和计算（知识点：1.值类型和引用类型，堆栈模型、深拷贝、2.typeof运算符、3.truely和falsely变量）

###### 	0.引用类型和值类型

https://www.cnblogs.com/myps/p/6903285.html

​	**答：计算机存放变量会使用堆和栈两种数据结构，栈存放值类型、堆存放引用类型、存放引用类型时，会给某一个变量在栈中存放一个引用指针，这个引用指针会指向堆中的内部变量**



###### 	1.typeof运算符

​	typof运算符能判断那些类型？ 

**（undefined、string、number、boolean、symbol、function、object）**

​	**答：能判断所有的值类型、识别函数、判断是否为引用类型（引用类型中有array和obj、null不能细分）**



###### 	**2.写一个深拷贝函数**

```js
let obj1 = {
    name: '里斯',
    age: 12,
    class: ['a', 'b', 'c'],
    deee: {
        beijing: 'a'
    }
}

function deepClone(obj = {}) {
    // 1 如果不是对象或这没有值直接返回那样就是相等的了
    if (typeof obj !== 'object' ||  obj == null) {
        return obj
    }

    // 2.创建一个空的变量进行返回
    let result
    if (obj instanceof Array) {
        result = []
    } else {
        result = {}
    }
	
    // 会遍历原型链上的属性
    for (let key in obj) {
        if (obj.hasOwnProperty(key)) {
            // 3.obj[key] 是值的话会走第一条直接返回
            // 不是值的话会继续走后面
            result[key] = deepClone(obj[key])
        }
    }

    return result
}

let obj2 = deepClone(obj1)
obj2.deee.beijing = 'b'
obj2.class[0] = 'aaaa'
obj2.name = '黄雨腾'
console.log(obj1)
console.log(obj2)
```



###### 3.==和===运算符

​	答：==能够进行数据类型的转换，如：（除了==null之外 ，其他尽量用===）

```js
100 == '100' // true
0 == '' // true
0 == false // true
false == '' // true
null == undefined // true
// 相当于
// obj.a === null || obj.a === undefined
obj.a == null 
```



###### 4.truely变量和falsely变量

truely变量：!!a === true 的变量

falsely变量：!!a === false 的变量

```js
// 以下是falsely变量 除此以外都是truely变量
!!0 === false
!!NaN === false
!!'' === false
!!null === false
!! undefined === false
!! false === false

// 在if语句中判断的是否为truely变量，所有用在if语句中
const a = true
if(a){ // 判断是否为truely变量
    // 是 执行
}

const b = ''
if(b){ // 判断是否为falsely变量
    // 否 不执行 
}

// 在逻辑中判断的是否为truely变量或falsely变量
(10 && 0) // 0 有truely变量
('' || 'abc') // abc 有truely变量
(!window.abc) // true 原本是falsely变量 取反为true
```



##### 知识：原型和原型链（知识点：1.class的继承、结合手写jquery理解、2.instanceof、3.原型和原型链：图示执行规则）

###### 5.原型和原型链

1.每个class类都会有一个显示原型prototype，每个被实例化出来的实例都会有一个隐式原始proto，他们两个是相等的，实例的proto指向prototype

参考：https://www.jianshu.com/p/be7c95714586

###### 6.手写一个jquery例子

```js
class Jquery {
    constructor(selector) {
        const result = document.querySelectorAll(selector)
        const length = result.length
        for (let i = 0; i < length; i++) {
            this[i] = result[i]
        }
        this.selector = selector
        this.length = length
    }
    // get方法
    get(index) {
        return this[index]
    }

    // 遍历
    each(fn) {
        for (let i = 0; i < this.length; i++) {
            fn(this[i])
        }
    }

    // 监听事件
    on(type, fn) {
        return this.each(elem => {
            elem.addEventListener(type, fn)
        })
    }
}
```



###### 7.创建10个a标签,点击时弹出对应的序号

```js
// 7.创建10个a标签,点击时弹出对应的序号
let a

for (let i = 0; i < 10; i++) {
    a = document.createElement('a')
    a.innerHTML = i + '<br/>'
    a.addEventListener('click', function(e) {
        e.preventDefault()
        console.log(i)
    })
    document.body.appendChild(a)
}
```



##### 知识：作用域和闭包（知识点：1.作用域和自由变量、2.闭包：两种常见形式&&自由变量查找规则、3.this指向）

###### 8.自由变量和闭包 

8.1一个变量在当前作用域没有被定义，但是被使用了会在**定义的地方向上级作用域**一层一层依次寻找，如果到全局作用域都没有被找到，会报undefined（注意是定义的地方）

8.2闭包示例（作为函数返回和令函数作为参数传递）

```js
// 函数作为返回值
function print() {
    const a = 100
    return function() {
        console.log(a)
    }
}

const fn = print()
const a = 200
fn() // 100

// 函数作为参数传递
function print(fn) {
    const a = 100
    fn()
}

const a = 200
// 自由变量会在定义的地方一级一级网上寻找
// 自由变量会在创建函数的地方寻找对应的值
function fn() {
    console.log(a)
}

print(fn) // 200
```

8.3闭包的应用（隐藏数据只提供api）

```js
// 闭包的应用 隐藏变量 只提供api
function closure() {
    let data = {} // 已经隐藏 要操作必须通过closure返回的函数
    return {
        set: function(key, val) {
            data[key] = val
            return 'ok'
        },
        get: function(key) {
            return data[key]
        }
    }
}

const c = closure()
console.log(c.set('c', 3)) // 必须通过函数设置  如果直接data.c是会报错
console.log(c.get('c'))
```



###### 9.this指向问题

9.1、this的指向是在函数执行的时候被确定的，不是在定义的时候被确定的（与自由变量不同）

9.2、this用于普通函数、对象引用、call和apply和bind、箭头函数、class中的this

9.3、以下是一些示例：

```js
// 关于this指向问题（window普通函数调用、call、apply、bind显示调用）

let x = 100

function fn() {
    console.log(this.x)
}

fn() // 作为普通函数被调用指向window x是100


fn.call({ x: 200 }) // 被显示调用（call、apply、bind）指向调用对象 x是200

let fn2 = fn.bind({ x: 300 })
fn2() // 被显示调用（call、apply、bind）指向调用对象 x是300
```

```js
// 关于this指向问题（对象隐式调用、箭头函数）
var name = 'hyt' // 如果是let name = 'hyt' sayName2()的值是undefined 因为let只对当前作用域生效
let obj = {
    name: 'jjj',
    // 作为对象隐式调用 this指向执行时候的对象
    sayName() {
        console.log(this.name, '111') 
    },
    // 实际执行的函数是setTimeout里面的函数，执行时（this指向是执行时候确定的）
    // 函数并没有对象调用，因此作为普通函数调用，指向window
    sayName2() {
        setTimeout(function() {
            console.log(this.name, '222') 
        })
    },
    // 箭头函数this的指向他的上一级作用域的this，因为自身并没有this指向
    // 他的上级作用域是sayName3的作用域，sayName3的tihs指向obj 因此未jjj
    sayName3() {
        setTimeout(() => {
            console.log(this.name, '333') 
        })
    }
}

obj.sayName()// jjj
obj.sayName2()// hyt
obj.sayName3()// jjj
```

**9.4手写一个bind函数（重要）**

```js
// 手写bind函数
Function.prototype.bind1 = function() {
    // 将参数变成一个数组
    const arg = Array.prototype.slice.call(arguments)

    // bind函数的第一个参数也就是要调用的对象,同时去掉数组第一个
    const that = arg.shift()

    // 拿到需要使用的函数 因为Function可以看作一个类
    // 而fn1可以看作是Funtion的实例化对象 所以this指向fn1
    const self = this

    // 返回一个函数
    return function() {
        // 这里的arg是去掉之前数组第一个之后的
        return self.apply(that, arg)
    }
}

function fn1(a, b) {
    console.log("this", this)
    console.log(a, b)
    return 'bind function'
}

const fn2 = fn1.bind1({ x: 100 }, 200, 300)
console.log(fn2())
```



##### 知识：异步和单线程（知识点：1.单线程和异步：异步和同步区别、2.前端异步的应用场景、3.promise解决回调）

###### 10.异步和单线程

**10.1单线程***

​		Js是单线程，同一时间只能做一件事，Js和DOM渲染共用一个线程，js可以修改DOM结构，两者其中之一开始，另一个就要停止

**10.2异步和同步区别**

​		基于js单线程的本质，异步不会阻塞代码的执行，同步会阻塞代码的执行

**10.3异步的应用场景**

​		网络请求、加载图片、定时任务（setTimeout等）、nodejs中的读写操作等

### js-web-api（w3c标准）

###### 1.DOM

**DOM题目**

​	1.1、DOM是哪种数据结构？

​	1.2、DOM操作的常用api

​	***1.3、attr和property的区别***

​	答：property：修改对象属性，不会体现在html结构上，而property 则使用  打点符. 或 [] 的方式获取即可

​			attribute：修改html属性，体现在html结构上，attribute的获取设置修改一般使用 setAttribute()和getAttribute()  比较方便

​			**两者都可能引起DOM重新渲染**

​	**总结一下：**

​		**1.没有非常明确的区别，只是有某些规律可遵循**

​        **2.attributes是和每个Property是在同一父级（可以这样认为吧）的，而每个Attribute的父级就是attributes**

​       **3.Attribute可以理解为特性（就是说可以有自定义的属性），property可以理解为属性（即html最基本提供的属性）**

​       **4.一般来说，无论开始还是任何时候，Attribute的变化会引起Property的变化, 而property的变化也会同步给Attribute进行变化（value除外）**

​	1.4、一次性插入多个DOM节点考虑性能

**DOM知识点**

​	***1.1、DOM本质(一种树状数据结构DOM树)***

​		**答：“DOM可以理解为:浏览器把拿到的HTML代码,结构化为一个浏览器可识别并且js可操作的一个模型而已（DOM结构是HTML语言从浏览器中解析出来的一种树结构）***

​	1.2、DOM节点操作

​	***1.3、DOM结构操作***

​	**答：新增/插入节点、获取子元素和父元素、删除节点等等**

​	***1.4、DOM性能***

​	**答：方式：1.对DOM查询做缓存、2、将频繁操作改为一次性操作**

```js
// 1.对DOM查询做缓存

// 这里每次循环都要去计算节点的长度，消耗性能
for(let i = 0; i < document.getElementsByClassName('p1').length;i++){ 
    // 操作 
}

// 这里会将节点的长度进行存储，不会消耗额外的性能
const pList = document.getElementsByClassName('p1')
const length = pList.length
for(let i = 0; i < length;i++){ 
    // 操作 
}


// 2.将频繁操作改为一次性操作
const listNode = document.getElementsByClassName("liList")

// 创建文件片段
const frag = document.createDocumentFragment()

for(let i = 0; i<10; i++){
    const li = document.createElement('li')
    li.innerHTML = `item ${li}`
    // 将每次循环插入文件片段中，此时还没有被渲染
    frag.appendChild(li)
}
// 将文件片段插入到实体DOM中
listNode.appendChild(frag)
```



###### 2.BOM

​	2.1、BOM题目

​		1.如何识别浏览器的类型

```js
const ua = navigatior.userAgent // 判断是否谷歌浏览器
const isChrome = ua.indexOf('Chrome')
console.log(isChrome) 
```

​		2.分析拆解url各个部分

```js
// location
location.href // 完整网址
location.protocol // 协议名
location.pathname // 路径
location.search // 查询参数
location.hash // 哈希值

//history
history.back() // 后退
history.forward() // 前进
```

​	2.2、BOM知识点

​		1.navigator

​		2.screen

​		3.location

​		4.history

###### 3.事件绑定

​	3.1、描述事件冒泡过程

​				1.基于DOM树形结构

​				2.事件会顺着触发元素往上冒泡

​				3.应用场景：代理

​	3.2、编写一个通用的事件绑定函数（普通绑定、事件代理）

```js
// 通用的事件绑定函数
function bindEvent(elem, EventType, selector, fn) {
    // 判断是否只传了三个参数（普通绑定）
    if (fn == null) {
        fn = selector
        selector = null
    }

    elem.addEventListener(EventType, function(event) {
        const target = event.target // 拿到该元素
            // 如果元素被指定的字符串选择器选择
        if (selector) {
            if (target.matches(selector)) {
                fn.call(target, event)
            }
        } else {
            fn.call(target, event)
        }

    })
}
```

###### 4.ajax

知识点：

​	1.XMLHttpRequest

​	最基础的ajax手写

```js
var xhr = new XMLHttpRequest()
xhr.open('GET', './demo.html', true) // true为异步请求    
xhr.onreadystatechange = function() {
    if (xhr.readyState === 4) {
        if (xhr.status === 200) {
            alert(xhr.responseText)
        }
    }
}

xhr.send(null)
xhr.send(JSON.stringify(data)) // post请求时
```

​	2.状态码

​	3.同源策略、跨域解决方案

​		3.0、同源策略

​		答：ajax请求时，浏览器要求当前网页和server必须同源（协议、域名、端口一致），但是加载图片、css、js可以无视同源策略

```js
<img src="跨域图片地址" />
<link src="跨域css地址" /> // 用于使用cdn等
<script src="跨域js地址" /> // 用于使用cdn以及使用jsonp
```

​		3.1、什么是跨域

​		3.2、JSONP

​		3.3、服务器端支持跨域





###### 5.存储

### 开发环境

###### git常用命令（情景）

**0.提交代码和拉取代码**

```js
// 提交代码
git add .  // 加入暂存
git commit -m 'first-commit'  // 提交注释
git push origin master // 将代码推到远程仓库

// 拉去代码
git pull origin master 
```

**1.合并分支（merge-branch为合并分支、login-branch、register-branch为用来合并到merge-branch的分支）**

```js
git checkout -b merge-branch // 新建分支
git checkout -b login-branch // 新建分支
git checkout -b register-branch // 新建分支
git branch // 查看所有分支
git checkout merge-branch // 切换到merge-branch分支
git fetch // 拉取分支

// 合并分支
git merge login-branch
git merge register-branch
```

**2.新建分支、查看分支、切换分支**

```js
git checkout -b 分支名   // 新建分支
git branch // 查看分支
git checkout 分支名 // 切换分支
```



###### git操作出现的错误

1.在执行git pull origin master时出现（原因是本地分支和远程分支断开连接）

　　**fatal: 'origin' does not appear to be a git repository**

　　**fatal: Could not read from remote repository.**

　　**Please make sure you have the correct access rights and the repository exists**

解决方法：

​		**git remote add origin ssh://git@gitlab\**\**\**\**\**\**\**\**\**\**\**\**\**\**\**\**\*.git**(地址)  （加上关联）



###### webpack和babel

使用原因：ES6模块化 浏览器暂时不支持（所以使用webpack）、ES6语法或更高级的ES语法浏览器暂时不支持（所以使用babel支持）、压缩整合代码，让网页更快

### 运行环境

###### 浏览器端：

**1.网页加载过程**

​	**问题：**

​	1.从输入url到渲染出页面的整个过程

​	2.window.onload和DOMCotentLoaded的区别

```js
window.onload // 页面全部资源加载完成才会执行，包括图片视频
DOMContentLoaded // DOM渲染完成就立刻执行，此时图片，视频还可能没有加载完成
```

​	**知识点：**

​	1.加载资源的形式：1.HTML代码、2.媒体文件、图片、视频等、3.JavaScript、css等

​	2.加载资源的过程：

​	3.渲染页面的过程：

```js
// 1.根据html代码生成dom tree
// 2.根据css代码生成cssom
// 3.将dom tree 和 cssom 整合生成render tree 
// 4.根据render tree渲染页面
// 5.遇到script标签暂停渲染，优先加载js代码，执行完继续
// 6.直至render tree渲染完成

思考：为何要把css文件放在head标签中?
回答：因为我们想要在dom tree生成之前先将cssom加载出来，在dom tree完成之后立刻将cssom将其一起整合，那么卡顿的时候用户就不会开始只看到HTML结构，会看到完成的渲染结构

思考：为何要把js文件放在body标签最后?
回答：因为我们希望先把render tree一并渲染出来，如果碰到script标签会先执行js，停止渲染render tree，而我们希望先把render tree渲染出来，最后才一并执行js代码，提高渲染速度
```

2.性能优化

A、原则：多使用内存、缓存等方法

B、使用示例：节流、防抖、图片懒加载、缓存、减少dom操作等

C、方向：

​	1.让加载更快

​			1.1、减少资源体积：压缩代码（webpack打包压缩）

​			1.2、减少访问次数：合并代码（webpack打包）、SSR服务端渲染（减少ajax请求）、缓存

​			1.3、使用CDN

​	2.让渲染更快

​			2.1、CSS放在head中、js放在body最后

​			2.2、尽早执行js用DOMContentLoaded触发

​			2.3、懒加载

​			2.4、对DOM查询进行缓存、减少dom操作（合并到一起最后插入，使用文档片段）

​			2.5、节流防抖

D、防抖（debounce）和节流

​			1.防抖（在用户结束输入的最后一刻执行操作）

使用场景（例子）：监听一个输入框时，文字变化后触发change事件，但是如果直接用keyup事件，则会频繁触发change，用户体验不好，而防抖就可以在用户输入结束或暂停时，才会触发change事件

**基本示例**

```js
// 关于防抖
let input1 = document.getElementById('input1')

// 设置定时器timer
// 每次触发keyup事件如果没有超过500ms都会清空timer重新计时
// 输入1 没有超过500ms就输入2 会重新清空timer直到超过500ms才会打印
let timer = null
input1.addEventListener('keyup', function() {
    if (timer) {
        clearTimeout(timer)
    }
    timer = setTimeout(() => {
        console.log(input1.value)
        timer = null
    }, 500)
})
```

**对以上的代码将进行进一步的封装**

```js
// 进行封装
function debounce(fn, delay = 500) {
    let timer = null
        // 返回一个函数（闭包）,将timer放入闭包内,使其无法在外部被修改
    return function() {
        if (timer) {
            clearTimeout(timer) // 存在即清空
        }
        timer = setTimeout(() => {
            console.log(this, 'input1')
            fn.apply(this, arguments) // 传参调用回调
            timer = null
        }, delay)
    }
}

const input1 = document.getElementById('input1')

input1.addEventListener('keyup', debounce(() => {
    console.log(this, '我是里面的')
    console.log(input1.value)
}, 1000))
```

2.节流（在用户 频繁操作的时候保持一定的频率触发）

使用场景：拖拽一个元素要随时拿到该元素被拖拽的位置，直接使用drag事件会频繁触发、很容易导致卡顿，使用节流无论拖拽速度有多快，都会每间隔100ms触发一次

示例代码：

```js
// 节流相关
let div1 = document.getElementById("div1")

let timer = null // 定义一个定时器 但是这个定时器可以被任意修改
div1.addEventListener('drag', function(e) {
    if (timer) {
        // 如果定时器存在返回，与防抖不同，防抖是结束触发，而节流是在间隔一个时间有规律触发
        return
    }

    timer = setTimeout(() => {
        console.log(e.offsetX, e.offsetY)
        timer = null // 重新定义定时器
    }, 100)
})
```

进一步封装throttle函数

```js
// 节流工具函数进一步封装
function throttle(fn, delay = 100) {
    let timer = null // 闭包变量无法外部修改
    return function() {
        if (timer) {
            return
        }
        timer = setTimeout(() => {
            fn.apply(this, arguments)
            timer = null
        }, delay)
    }
}

div1.addEventListener('drag', throttle(function(e) {
    console.log(e.offsetX, e.offsetY)
}))
```

###### 安全方面

1.常见的web安全攻击有哪些？

答：1.XSS跨站请求攻击、2.XSRF跨站请求伪造

**XSS跨站请求攻击（场景）：**

1.在一个博客网站中，我发表了一篇博客，其中嵌入了script标签

2.脚本的内容是获取cookie信息，同时发送到我的服务器（因为script标签可以跨域同时服务端配合跨域）

3.发布这篇博客，如果有人查看我就可以轻松获取访问者他的cookie

预防：替换特殊字符 如<变为&lt  >变为&gt，直接显示不会当作脚本执行

**2..XSRF跨站请求伪造（场景）**

1.客户正在购物，看中某个商品，id是100，付费接口是xxx.com/pay?id=100,没有任何的验证就可以付费

2.我是攻击者，看中id是200的商品，向客户发一份邮件，用户点击正文隐藏一个img标签 src属性里面是xxx.com/pay?id=200 因为没有任何的验证以及用户是登录之后点击，那么会将信息带过去直接购买

**预防：** 1.post接口、2.进行付费验证

# Vue

### 1.vue自定义组件(通过Vue.use()来使用)即install的使用

在vue项目中，我们可以自定义组件，像element-ui一样使用Vue.use（）方法来使用，具体实现方法：

1.首先新建一个Cmponent.vue文件

```js
// Cmponent.vue
<template>
    <div>
        我是组件
    </div>
</template>
 
<script>
    export default {
 
    }
</script>
 
<style scoped>
    div{
        font-size:40px;
        color:#fbb;
        text-align:center;
    }
</style>

```

2.其次在同一目录下建立index.js文件,在这个文件中使用install方法来全局注册该组件

```js
import component from './Cmponent.vue'
const component = {
    install:function(Vue){
        Vue.component('component-name',component)
    }  //'component-name'这就是后面可以使用的组件的名字，install是默认的一个方法
    
}
// 导出该组件
export default component
```

3.使用

```js

// 只要在index.js里规定了install方法，就可以向其他ui组件库那样，使用Vue.use()来全局使用
import loading from './index.js'
 
Vue.use(loading)
 
<template>
   <div>
      <component-name></component-name>
   </div>    
</template>
```



### 2.v-model语法糖

![这里写图片描述](https://img-blog.csdn.net/20170717002255462?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcmlkZGxlMTk4MQ==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)



也就是说v-model实质上是绑定了value和input事件，那么触发input事件的同时会触发value的变化	

- something即是实时的value值，每一次value值得更改都会触发something改变
- 如果有别的控件绑定something那么input的value值改变改控件的值显示，因此实现了双向绑定



# 关于Vue的SSR渲染（未）

参考文档：https://github.com/youngwind/blog/issues/112（详细）

参考文档：https://blog.csdn.net/sinat_36263705/article/details/95865410





# 关于Nuxt.js使用（未）

参考文档：https://www.jianshu.com/p/b0626ba924c9（后面按照简述走一遍）



# 关于NodeJs相关

## 1.常用api

### 1.1path模块

- ```js
  //2.1.3.path.join([...paths])
  
  // 接收一组路径，并拼接为一个路径，../表示返回上一级目录，./表示同级目录
  console.log(path.join('/a/b/c/d','../','./','index.html'))
  // 输出 \a\b\c\index.html
  
  
  //2.1.4 path.parse(path)
  
  // 将路径字符串转换为路径对象
  const pathObj = path.parse('E:\\a\\b\\c\\d\\index.html')
  console.log(pathObj)
  /* 输出
   * { 
   *  root: 'E:\\', // 文件根目录
   *  dir: 'E:\\a\\b\\c\\d', // 不带文件名的文件路径
   *  base: 'index.html', // 文件名
   *  ext: '.html', // 文件后缀
   *  name: 'index' // 不带后缀的文件名
   * }
   */
  
  
  //2.1.8 path.relative(from, to)
  
  // 接收两个路径，返回第一个路径到第二个路径的相对路径
  const to = 'C:\\orandea\\test\\aaa'
  const from = 'C:\\orandea\\impl\\bbb'
  console.log(path.relative(to, from))
  // 输出 ..\..\impl\bbb
  
  
  //2.1.9 path.resolve 路径拼接
  var path = require("path")     //引入node的path模块
  
  path.resolve('/foo/bar', './baz')   // returns '/foo/bar/baz'
  path.resolve('/foo/bar', 'baz')   // returns '/foo/bar/baz'
  path.resolve('/foo/bar', '/baz')   // returns '/baz'
  path.resolve('/foo/bar', '../baz')   // returns '/foo/baz'
  path.resolve('home','/foo/bar', '../baz')   // returns '/foo/baz'
  path.resolve('home','./foo/bar', '../baz')   // returns '/home/foo/baz'
  path.resolve('home','foo/bar', '../baz')   // returns '/home/foo/baz'
  ```





# 关于Promise相关

## 1.以下这些代码的运行结果

## 第一题

```js
const promise = new Promise((resolve, reject) => {
  console.log(1)
  resolve()
  console.log(2)
})
promise.then(() => {
  console.log(3)
})
console.log(4)
```

## 第二题

```js
const promise = new Promise((resolve, reject) => {
  resolve('success1')
  reject('error')
  resolve('success2')
})

promise
  .then((res) => {
    console.log('then: ', res)
  })
  .catch((err) => {
    console.log('catch: ', err)
  })
```

## 第三题

```js
Promise.resolve()
  .then(() => {
    return new Error('error!!!')
  })
  .then((res) => {
    console.log('then: ', res)
  })
  .catch((err) => {
    console.log('catch: ', err)
  })
```

## 第四题

```js
Promise.resolve(1)
  .then((res) => {
    console.log(res)
    return 2
  })
  .catch((err) => {
    return 3
  })
  .then((res) => {
    console.log(res)
  })
```

## 第五题：

```js
const promise = Promise.resolve()
  .then(() => {
    return promise
  })
promise.catch(console.error)
```

## 第六题

```js
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)
```

## 第七题

```js
Promise.resolve()
  .then(function success (res) {
    throw new Error('error')
  }, function fail1 (e) {
    console.error('fail1: ', e)
  })
  .catch(function fail2 (e) {
    console.error('fail2: ', e)
  })
```

## 第八题

```js
process.nextTick(() => {
  console.log('nextTick')
})
Promise.resolve()
  .then(() => {
    console.log('then')
  })
setImmediate(() => {
  console.log('setImmediate')
})
console.log('end')
```

### 答案:		

1.结果：1243

​    解释：Promise 构造函数是同步执行的，promise.then 中的函数是异步执行的。



2.结果：then: success1

​	解释：构造函数中的 resolve 或 reject 只有第一次执行有效，多次调用没有任何作用，呼应代码二结论：promise 状态一旦改变则不能再变。



3.结果：

```text
then: Error: error!!!
    at Promise.resolve.then (...)
    at ...
```

​	解释：.then 或者 .catch 中 return 一个 error 对象并不会抛出错误，所以不会被后续的 .catch 捕获



4.结果：12

​	解释：promise 可以链式调用。提起链式调用我们通常会想到通过 return this 实现，不过 Promise 并不是这样实现的。promise 每次调用 .then 或者 .catch 都会返回一个新的 promise，从而实现了链式调用。



5.结果：

```text
TypeError: Chaining cycle detected for promise #<Promise>
    at <anonymous>
    at process._tickCallback (internal/process/next_tick.js:188:7)
    at Function.Module.runMain (module.js:667:11)
    at startup (bootstrap_node.js:187:16)
    at bootstrap_node.js:607:3
```

解释：.then 或 .catch 返回的值不能是 promise 本身，否则会造成死循环



6.运行结果：

```text
1
```

解释：.then 或者 .catch 的参数期望是函数，传入非函数则会发生值穿透。



7.运行结果：

```text
fail2: Error: error
    at success (...)
    at ...
```

解释：.then 可以接收两个参数，第一个是处理成功的函数，第二个是处理错误的函数。.catch 是 .then 第二个参数的简便写法，但是它们用法上有一点需要注意：.then 的第二个处理错误的函数捕获不了第一个处理成功的函数抛出的错误，而后续的 .catch 可以捕获之前的错误。



8.运行结果：

```text
end
nextTick
then
setImmediate
```

解释：process.nextTick 和 promise.then 都属于 microtask，而 setImmediate 属于 macrotask，在事件循环的 check 阶段执行。事件循环的每个阶段（macrotask）之间都会执行 microtask，事件循环的开始会先执行一次 microtask。





# 关于Event Loop（事件循环）的相关（分成浏览器和node环境）

参考文章：https://juejin.im/post/5df631afe51d45581269a7b5#heading-15  面试经典：Event Loop

​					https://juejin.im/post/5c337ae06fb9a049bc4cd218 浏览器与Node的事件循环(Event Loop)有何区别?

## 首先介绍：js运行机制

1.所有同步任务都在主线程上执行，形成一个 **“执行栈”**（execution context stack）。

2.主线程之外，存在一个 **“任务队列”**（task queue），在走主流程的时候，如果碰到异步任务，那么就在 **“任务队列”** 中放置这个异步任务。

3.一旦 **“执行栈”** 中所有同步任务执行完毕，系统就会读取 **“任务队列”**，看看里面存在哪些事件。那些对应的异步任务，结束等待状态，进入执行栈，开始执行。

主线程不断重复上面三个步骤。




## 1.浏览器的event loop

结论：微任务在事件循环的红任务执行完之后执行（js标签本身也是一个宏任务）

### 1.Micro-Task 与 Macro-Task

浏览器端事件循环中的异步队列有两种：macro（宏任务）队列和 micro（微任务）队列。**宏任务队列可以有多个，微任务队列只有一个**。

- 常见的 macro-task 比如：setTimeout、setInterval、script（整体代码）、 I/O 操作、UI 渲染等。
- 常见的 micro-task 比如: new Promise().then(回调)、MutationObserver(html5新特性) 等。

### 2.Event Loop 过程解析

一个完整的 Event Loop 过程，可以概括为以下阶段：



![img](https://user-gold-cdn.xitu.io/2019/1/10/1683863633586974?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



- 一开始执行栈空,我们可以把**执行栈认为是一个存储函数调用的栈结构，遵循先进后出的原则**。micro 队列空，macro 队列里有且只有一个 script 脚本（整体代码）。
- 全局上下文（script 标签）被推入执行栈，同步代码执行。在执行的过程中，会判断是同步任务还是异步任务，通过对一些接口的调用，可以产生新的 macro-task 与 micro-task，它们会分别被推入各自的任务队列里。同步代码执行完了，script 脚本会被移出 macro 队列，这个过程本质上是队列的 macro-task 的执行和出队的过程。（可以说js标签执行就是一个macro-task）
- 上一步我们出队的是一个 macro-task，这一步我们处理的是 micro-task。但需要注意的是：当 macro-task 出队时，任务是**一个一个**执行的；而 micro-task 出队时，任务是**一队一队**执行的。因此，我们处理 micro 队列这一步，会逐个执行队列中的任务并把它出队，直到队列被清空。
- **执行渲染操作，更新界面**
- 检查是否存在 Web worker 任务，如果有，则对其进行处理
- 上述过程循环往复，直到两个队列都清空

我们总结一下，每一次循环都是一个这样的过程：



![img](https://user-gold-cdn.xitu.io/2019/1/10/1683877ba9aab056?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



**结论：当某个宏任务执行完后,会查看是否有微任务队列。如果有，先执行微任务队列中的所有任务，如果没有，会读取宏任务队列中排在最前的任务，执行宏任务的过程中，遇到微任务，依次加入微任务队列。栈空后，再次读取微任务队列里的任务，依次类推。**



### 例子①：

```js
// 位置 1
setTimeout(function () {
  console.log('timeout1');
}, 1000);

// 位置 2
console.log('start');

// 位置 3
Promise.resolve().then(function () {
  // 位置 5
  console.log('promise1');
  // 位置 6
  Promise.resolve().then(function () {
    console.log('promise2');
  });
  // 位置 7
  setTimeout(function () {
    // 位置 8
    Promise.resolve().then(function () {
      console.log('promise3');
    });
    // 位置 9
    console.log('timeout2')
  }, 0);
});

// 位置 4
console.log('done');

作者：jsliang
链接：https://juejin.im/post/5df631afe51d45581269a7b5
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

**提问**：请指出上面代码的输出结果？



**回答**：

这是经典的面试题型，所以咱们看到不用慌，先拿我们上面的点，区分下分宏任务和微任务：

- **宏任务（Macrotask）**：`script`（整体代码）、`setTimeout`、`setInterval`、`XMLHttpRequest.prototype.onload`、`I/O`、UI 渲染
- **微任务（Microtask）**：`Promise`、`MutationObserver`

OK，开始走流程：

> **如果你觉得文字不好理解，请往下翻，有 GIF 图演示！！！**

1. 首先碰到的是 `script`（整体代码），先看【位置 1】，属于宏任务 `setTimeout` 下的，所以做个标记，待会回来执行。
2. 接着碰到【位置 2】，这是 `script`（整体代码）下的无阻碍代码，直接执行即可。
3. 再来碰到【位置 3】，它现在是 `script`（整体代码）下的微任务，所以咱们做个标记，走完文件所有代码后，优先执行微任务，再执行宏任务。
4. 最后碰到【位置 4】，它是 `script`（整体代码）下的无阻碍代码，直接执行即可。

这样，第一波步骤，我们输出的是【位置 2】的 `start` 和【位置 4】的 `done`。

我们接着走：

1. 上面我们走完了第一遍代码，然后现在这一步先走 

   ```
   script
   ```

   （整体代码）下的微任务，即【位置 3】

   1. 先碰到【位置 5】，这是无阻碍代码，直接执行。
   2. 再碰到【位置 6】，这是微任务，标记一下，等下执行完【位置 3】内所有代码后，优先执行它。
   3. 最后碰到【位置 7】，这是宏任务，丢入任务队列，看它和【位置 1】谁先走了。

2. 走完一遍【位置 3】后，发现还有微任务【位置 6】，所以执行【位置 6】，进行打印输出。

到这一步，我们就走完了 `script`（整体代码）及之下的所有微任务了。

这时候，我们会说，【位置 1】和【位置 7】都被丢到任务队列了，是不是【位置 1】先走呢？

答案为：不是的。

同样的 `setTimeout`，**jsliang** 在测试的时候，就发现它们的输出结果在各个环境都有自己的流程，有时候先走【位置 7】，再走【位置 1】；而有时候先走【位置 1】，再走【位置 7】。

当然，如果你指定是在 `Chrome` 的控制台输出一下上面的代码，那就是先【位置 7】，再【位置 1】~

- **point：不要主观臆断某个代码会怎么走，最好还是直接实况运行走一波！**

1. 先走【位置 7】。碰到【位置 8】，将其添加到【位置 7】的微任务中，等【位置 7】所有代码执行完毕回来优先走微任务；碰到【位置 9】，这是无阻碍代码，直接输出即可。
2. 执行【位置 7】的微任务【位置 8】，输出对应文本。
3. 最后走【位置 1】，输出对应文本。

所以答案是：

```js
start
done
promise1
promise2
timeout2
promise3
timeout1。
```



### 例子②

```js
Promise.resolve().then(()=>{
  console.log('Promise1')  
  setTimeout(()=>{
    console.log('setTimeout2')
  },0)
})
setTimeout(()=>{
  console.log('setTimeout1')
  Promise.resolve().then(()=>{
    console.log('Promise2')    
  })
},0)

作者：浪里行舟
链接：https://juejin.im/post/5c337ae06fb9a049bc4cd218
来源：掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```





最后输出结果是Promise1，setTimeout1，Promise2，setTimeout2

- 一开始执行栈的同步任务（这属于宏任务）执行完毕，会去查看是否有微任务队列，上题中存在(有且只有一个)，然后执行微任务队列中的所有任务输出Promise1，同时会生成一个宏任务 setTimeout2
- 然后去查看宏任务队列，宏任务 setTimeout1 在 setTimeout2 之前，先执行宏任务 setTimeout1，输出 setTimeout1
- 在执行宏任务setTimeout1时会生成微任务Promise2 ，放入微任务队列中，接着先去清空微任务队列中的所有任务，输出 Promise2
- 清空完微任务队列中的所有任务后，就又会去宏任务队列取一个，这回执行的是 setTimeout2




## 2.node的event Loop

结论：Node端，microtask 在事件循环的各个阶段之间执行

### 1.Node简介

Node 中的 Event Loop 和浏览器中的是完全不相同的东西。Node.js采用V8作为js的解析引擎，而I/O处理方面使用了自己设计的libuv，libuv是一个基于事件驱动的跨平台抽象层，封装了不同操作系统一些底层特性，对外提供统一的API，事件循环机制也是它里面的实现（下文会详细介绍）。



![img](https://user-gold-cdn.xitu.io/2019/1/11/1683d81674f076eb?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

Node.js的运行机制如下:



- V8引擎解析JavaScript脚本。
- 解析后的代码，调用Node API。
- libuv库负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。
- V8引擎再将结果返回给用户。

### 2.六个阶段

其中libuv引擎中的事件循环分为 6 个阶段，它们会按照顺序反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。



![img](https://user-gold-cdn.xitu.io/2019/1/12/16841bd9860c1ee9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



从上图中，大致看出node中的事件循环的顺序：

外部输入数据-->轮询阶段(poll)-->检查阶段(check)-->关闭事件回调阶段(close callback)-->定时器检测阶段(timer)-->I/O事件回调阶段(I/O callbacks)-->闲置阶段(idle, prepare)-->轮询阶段（按照该顺序反复运行）...

- timers 阶段：这个阶段执行timer（setTimeout、setInterval）的回调
- I/O callbacks 阶段：处理一些上一轮循环中的少数未执行的 I/O 回调
- idle, prepare 阶段：仅node内部使用
- poll 阶段：获取新的I/O事件, 适当的条件下node将阻塞在这里
- check 阶段：执行 setImmediate() 的回调
- close callbacks 阶段：执行 socket 的 close 事件回调

注意：**上面六个阶段都不包括 process.nextTick()**(下文会介绍)

接下去我们详细介绍`timers`、`poll`、`check`这3个阶段，因为日常开发中的绝大部分异步任务都是在这3个阶段处理的。

#### (1) timer

timers 阶段会执行 setTimeout 和 setInterval 回调，并且是由 poll 阶段控制的。 同样，**在 Node 中定时器指定的时间也不是准确时间，只能是尽快执行**。

#### (2) poll

poll 是一个至关重要的阶段，这一阶段中，系统会做两件事情

1.回到 timer 阶段执行回调

2.执行 I/O 回调

并且在进入该阶段时如果没有设定了 timer 的话，会发生以下两件事情

- 如果 poll 队列不为空，会遍历回调队列并同步执行，直到队列为空或者达到系统限制
- 如果 poll 队列为空时，会有两件事发生
  - 如果有 setImmediate 回调需要执行，poll 阶段会停止并且进入到 check 阶段执行回调
  - 如果没有 setImmediate 回调需要执行，会等待回调被加入到队列中并立即执行回调，这里同样会有个超时时间设置防止一直等待下去

当然设定了 timer 的话且 poll 队列为空，则会判断是否有 timer 超时，如果有的话会回到 timer 阶段执行回调。

#### (3) check阶段

setImmediate()的回调会被加入check队列中，从event loop的阶段图可以知道，check阶段的执行顺序在poll阶段之后。 我们先来看个例子:

```
console.log('start')
setTimeout(() => {
  console.log('timer1')
  Promise.resolve().then(function() {
    console.log('promise1')
  })
}, 0)
setTimeout(() => {
  console.log('timer2')
  Promise.resolve().then(function() {
    console.log('promise2')
  })
}, 0)
Promise.resolve().then(function() {
  console.log('promise3')
})
console.log('end')
//start=>end=>promise3=>timer1=>timer2=>promise1=>promise2
复制代码
```

- 一开始执行栈的同步任务（这属于宏任务）执行完毕后（依次打印出start end，并将2个timer依次放入timer队列）,会先去执行微任务（**这点跟浏览器端的一样**），所以打印出promise3
- 然后进入timers阶段，执行timer1的回调函数，打印timer1，并将promise.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；这点跟浏览器端相差比较大，**timers阶段有几个setTimeout/setInterval都会依次执行**，并不像浏览器端，每执行一个宏任务后就去执行一个微任务（关于Node与浏览器的 Event Loop 差异，下文还会详细介绍）。

### 3.Micro-Task 与 Macro-Task

Node端事件循环中的异步队列也是这两种：macro（宏任务）队列和 micro（微任务）队列。

- 常见的 macro-task 比如：setTimeout、setInterval、 setImmediate、script（整体代码）、 I/O 操作等。
- 常见的 micro-task 比如: process.nextTick、new Promise().then(回调)等。

### 4.注意点

#### (1) setTimeout 和 setImmediate

二者非常相似，区别主要在于调用时机不同。

- setImmediate 设计在poll阶段完成时执行，即check阶段；
- setTimeout 设计在poll阶段为空闲时，且设定时间到达后执行，但它在timer阶段执行

```
setTimeout(function timeout () {
  console.log('timeout');
},0);
setImmediate(function immediate () {
  console.log('immediate');
});
复制代码
```

- 对于以上代码来说，setTimeout 可能执行在前，也可能执行在后。
- 首先 setTimeout(fn, 0) === setTimeout(fn, 1)，这是由源码决定的 进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 setTimeout 回调
- 如果准备时间花费小于 1ms，那么就是 setImmediate 回调先执行了

但当二者在异步i/o callback内部调用时，总是先执行setImmediate，再执行setTimeout

```
const fs = require('fs')
fs.readFile(__filename, () => {
    setTimeout(() => {
        console.log('timeout');
    }, 0)
    setImmediate(() => {
        console.log('immediate')
    })
})
// immediate
// timeout
复制代码
```

在上述代码中，setImmediate 永远先执行。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 setImmediate 回调，所以就直接跳转到 check 阶段去执行回调了。

#### (2) process.nextTick

这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会清空队列中的所有回调函数，并且优先于其他 microtask 执行。

```
setTimeout(() => {
 console.log('timer1')
 Promise.resolve().then(function() {
   console.log('promise1')
 })
}, 0)
process.nextTick(() => {
 console.log('nextTick')
 process.nextTick(() => {
   console.log('nextTick')
   process.nextTick(() => {
     console.log('nextTick')
     process.nextTick(() => {
       console.log('nextTick')
     })
   })
 })
})
// nextTick=>nextTick=>nextTick=>nextTick=>timer1=>promise1
复制代码
```

## 3.Node与浏览器的 Event Loop 差异

**浏览器环境下，microtask的任务队列是每个macrotask执行完之后执行。而在Node.js中，microtask会在事件循环的各个阶段之间执行，也就是一个阶段执行完毕，就会去执行microtask队列的任务**。

![img](https://user-gold-cdn.xitu.io/2019/1/12/16841bad1cda741f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



接下我们通过一个例子来说明两者区别：

```
setTimeout(()=>{
    console.log('timer1')
    Promise.resolve().then(function() {
        console.log('promise1')
    })
}, 0)
setTimeout(()=>{
    console.log('timer2')
    Promise.resolve().then(function() {
        console.log('promise2')
    })
}, 0)
复制代码
```

浏览器端运行结果：`timer1=>promise1=>timer2=>promise2`

浏览器端的处理过程如下：



![img](https://user-gold-cdn.xitu.io/2019/1/12/16841d6392e8f537?imageslim)



Node端运行结果分两种情况：

- 如果是node11版本一旦执行一个阶段里的一个宏任务(setTimeout,setInterval和setImmediate)就立刻执行微任务队列，这就跟浏览器端运行一致，最后的结果为`timer1=>promise1=>timer2=>promise2`
- 如果是node10及其之前版本：要看第一个定时器执行完，第二个定时器是否在完成队列中。
  - 如果是第二个定时器还未在完成队列中，最后的结果为`timer1=>promise1=>timer2=>promise2`
  - 如果是第二个定时器已经在完成队列中，则最后的结果为`timer1=>timer2=>promise1=>promise2`(下文过程解释基于这种情况下)

1.全局脚本（main()）执行，将2个timer依次放入timer队列，main()执行完毕，调用栈空闲，任务队列开始执行；

2.首先进入timers阶段，执行timer1的回调函数，打印timer1，并将promise1.then回调放入microtask队列，同样的步骤执行timer2，打印timer2；

3.至此，timer阶段执行结束，event loop进入下一个阶段之前，执行microtask队列的所有任务，依次打印promise1、promise2

Node端的处理过程如下：

![img](https://user-gold-cdn.xitu.io/2019/1/12/16841d5f85468047?imageslim)

## 4.总结

浏览器和Node 环境下，microtask 任务队列的执行时机不同

- Node端，microtask 在事件循环的各个阶段之间执行
- 浏览器端，microtask 在事件循环的 macrotask 执行完之后执行











# 关于工作实习相关知识

## 和码实习（微信公众号，微信小程序，落地页）

### 配置相关

postcss.config.js 作用&配置
给postcss用的
postcss 是帮我们后处理css ，css已经编译完成了，在stylus-loader编译成css之后，在通过postcss优化css，通过一系列组件去优化，比如以下，通过autoprefixer 添加css前缀

```js
const autoprefixer = require('autoprefixer')

module.exports = {
  plugins: [
    autoprefixer()
  ]
}
```

###### 

###### postcss-px-to-viewport将px转换为vw单位

在postcss.config.js中配置https://blog.csdn.net/Cookysurongbin/article/details/99671673

```js
module.exports = {
  plugins: {
    autoprefixer: {},
    'postcss-px-to-viewport': {
      viewportWidth: 750,   // 视窗的宽度，对应的是我们设计稿的宽度，一般是750
      landscapeWidth: 750, // 视窗的高度，根据750设备的宽度来指定，一般指定1334，也可以不配置
      selectorBlackList: ['van-'], // 指定不转换为视窗单位的类，可以自定义，可以无限添加,建议定义一至两个通用的类名
    },
  },
};

```



###### babel.config.js的设置（详细1：https://www.cnblogs.com/dfzc/p/11061569.html，详细2：https://segmentfault.com/a/1190000018721165）

###### （vant的使用：https://blog.csdn.net/webfront/article/details/80277844）

```js
module.exports = {
  presets: ['@vue/app'], // vue-cli 默认预设
  plugins: [ // 引入vant模块 
    [
      'import',
      {
        libraryName: 'vant',
        libraryDirectory: 'es',
        style: true,
      },
      'vant',
    ],
  ],
};

```



### 创建多路由引用在vue-cli中

在utils文件中新建pages.js

```js
const pageConfig = require('./pages.config');

const defaultTitle = '和码编程'; // html默认title

const pages = {};
pageConfig.forEach(({ name, title = defaultTitle }) => {
  pages[name] = {
    entry: `src/pages/${name}/main.js`,
    template: 'util/template/index.html',
    title,
    chunks: ['chunk-vendors', 'chunk-common', name],
  };
});

module.exports = pages;

```

pages.config.js文件中（相当于路由）

```js
module.exports = [
  { name: 'ldy' },
  { name: 'ldy-result' },
  { name: 'ldy-wx' },
  { name: 'custom-ldy' },
  { name: 'custom-ldy-wx' },
  { name: 'ldy-new' },
  { name: 'ldyv3-wx' }
];
```



最后在vue.config.js中的配置选项中

```js
const pages = require('./util/pages');

module.exports = {
  publicPath: './',
  outputDir: process.env.VUE_APP_OUTPUTDIR,
  devServer: {},
  pages,
  productionSourceMap: false,
};

```



### 微信js-sdk应用

​		1.1引入微信特定的js文件https://res.wx.qq.com/open/js/jweixin-1.4.0.js以及封装网络请求函数

```html
// html页面模板
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta
      name="viewport"
      content="width=device-width,initial-scale=1.0,user-scalable=no"
    />
    <meta name="format-detection" content="telephone=no" />
    <title><%= htmlWebpackPlugin.options.title %></title>
  </head>
  <body>
    <noscript>
      <strong>Please enable JavaScript to continue.</strong>
    </noscript>
    <div id="app"></div>
    // 引入微信js-sdk文件
    <script src="https://res.wx.qq.com/open/js/jweixin-1.4.0.js"></script>
    // 新浪的IP地址查询接口 利用JS获取用户当前ip地址
    <script src="https://pv.sohu.com/cityjson?ie=utf-8"></script>
  </body>
</html>

```

封装网络请求ajax.js

```js
import axios from 'axios';
import { Toast, Notify } from 'vant';
Toast.allowMultiple(); // 同一时间可以弹出多个toast

const request = config => {
    let { method, data } = config;

    // 处理method参数
    method = (method && method.toLowerCase()) || 'get';
    config['method'] = method;

    // 根据method传参
    if (method === 'get') {
        config['params'] = data;
        delete config.data;
    }

    return axios(config);
};

export default config => {
    const { showLoading = false, loadingMsg = '加载中...' } = config;
    const toast =
        showLoading &&
        Toast.loading({
            mask: true,
            duration: 0,
            message: loadingMsg,
        });
    return new Promise((resolve, reject) => {
        request(config)
            .then(res => {
                resolve(res.data);
                console.log(res.data, '微信jsdk')
            })
            .catch(error => {
                console.error('request got error:', error, 'request config:', config);
                Notify(error.message);
                reject();
            })
            .finally(() => {
                toast && toast.clear();
            });
    });
};
```

1.2新建设置微信js-sdk.js文件（再此处调用wx.config,jsapiList等）

```js
/**
 * 微信sdk相关方法
 */
import $ajax from './ajax';
import { URL_wxJsConfig } from './api';

class Wxsdk {
    constructor() {
        this.shareCache = {};
        this.debug = false;
        this.jsApiList = [
            'onMenuShareTimeline', // 分享到朋友圈
            'onMenuShareAppMessage', // 分享给朋友
            'closeWindow', // 关闭当前网页窗口
            'chooseWXPay',
        ];
        this.initConfig();
    }

    /**
     * 初始化sdk配置
     */
    async initConfig() {
        const { errorCode, returnObject } = await $ajax({
            url: URL_wxJsConfig,
            method: 'post',
            data: {
                pageUrl: location.href.split('#')[0],
            },
        });
        if (errorCode !== '00') {
            console.error('获取wxsdk配置发生错误');
            return;
        }
        const { appId, timestamp, nonceStr, signature } = returnObject;
        const { debug, jsApiList } = this;
        wx.config({ debug, appId, timestamp, nonceStr, signature, jsApiList });
    }

    /**
     * 设置微信分享内容
     * @param {Object} options 分享配置
     */
    resetShare(options) {
        this.shareCache = {...this.shareCache, ...options };
        const {
            title,
            desc,
            link,
            imgUrl,
            success,
            cancel,
            fail,
        } = this.shareCache;
        wx.ready(() => {
            // 分享到朋友圈
            wx.onMenuShareTimeline({
                title,
                link,
                imgUrl,
                success() {
                    success && success();
                },
                cancel() {
                    cancel && cancel();
                },
                fail() {
                    fail && fail();
                },
            });
            // 分享给朋友
            wx.onMenuShareAppMessage({
                title,
                desc,
                link,
                imgUrl,
                success() {
                    success && success();
                },
                cancel() {
                    cancel && cancel();
                },
                fail() {
                    fail && fail();
                },
            });
        });
    }
}

export default new Wxsdk();
```



**微信sdk的使用（分享朋友圈）**

```js
initShareConfig() {
   var link = this.makeJumpLink();
   var title =
      '和码编程特惠，' +
       this.payAmount +
       '元抢' +
       this.originPrice +
       '元' +
       this.showCourseName;
   var desc = '数学与编程的结合，基于美国CSTA教学标准及国内数学教材自主研发';
   var imgUrl = URL_hemaQrcodeImgPath2 + '?1.12';

    wxsdk.resetShare({ title, desc, link, imgUrl });
},
```

**微信sdk的使用（选择支付方式，调用微信支付接口）**

```js
    /**
     * 处理微信支付
     * @param {Object} orderInfo 平台支付订单信息
     * @param {Object} jsapiPayInfo 调起微信支付的配置信息
     */
    handleWxChoosePay: function(jsapiPayInfo) {
      console.log('处理预支付');
      Toast.loading({
        mask: true,
        duration: 0,
        message: '支付处理中...',
      });

      var that = this;
      wx.chooseWXPay({
        // appId: jsapiPayInfo.appId,
        timestamp: jsapiPayInfo.timeStamp,
        nonceStr: jsapiPayInfo.nonceStr,
        package: jsapiPayInfo.package,
        signType: jsapiPayInfo.signType, // 注意：新版支付接口使用 MD5 加密
        paySign: jsapiPayInfo.paySign,
        success: res => {
          //支付成功，返回这个页面，方法回调到这里，但是前端页面并不会刷新
          console.log('chooseWXPay.res');
          console.log(res);
          if (res.errMsg == 'chooseWXPay:ok') {
            // 支付成功
            // console.log('更新状态为：处理中');
            //that.doWhenPayOk();
          } else {
            // 微信支付失败
            console.log('更新状态为：付款失败');
            Toast.clear();
            that.updateOrderStatus('fail');
          }
        },
        cancel: res => {
          // 取消付款
          console.log('===cancel===');
          console.log(res);
          console.log('更新状态为：取消付款');
          Toast.clear();
          t.showMessage('您取消了微信付款！');
          this.updateOrderStatus('cancel');
        },
        fail: res => {
          // 微信支付失败
          console.log('===fail===');
          console.log(res);
          console.log('更新状态为：付款失败');
          Toast.clear();
          t.showMessage('非常抱歉，微信支付遇到异常！');
          this.updateOrderStatus('fail');
          Toast.clear();
        },
      });
    },
```

**微信sdk的使用（调用微信H5支付接口）**

```js
    /**
     * 处理H5支付
     * @param {Object} jsInfo
     */
    handleH5PayEvent: function(jsInfo) {
      var mwebUrl = jsInfo.mwebUrl;
      console.log('mwebUrl===>' + mwebUrl);

      // var backUrl = dxrV2BackLink;
      let backUrl = location.href;
      // if (backUrl.indexOf('.html?') != -1) {
      if (backUrl.includes('?')) {
        backUrl += '&ibh5=1';
      } else {
        backUrl += '?ibh5=1';
      }
      console.log('backUrl=' + backUrl);
      backUrl = encodeURIComponent(backUrl);

      mwebUrl += '&redirect_url=' + backUrl;
      console.log('mwebUrl=' + mwebUrl);
	  // 直接跳转微信商户后台的url调起h5支付
      location.href = mwebUrl;
    },
```



### 创建websocket轮询来定时获取支付结果

创建ws.js文件

```js
/**
 * websocket
 * @returns {Function}
 */
export default opt => {
  const { wsUrl, onOpenCbFun, onCloseCbFun, onMessageCbFun } = opt;
  const ws = new WebSocket(wsUrl);
  ws.addEventListener('open', ev => {
    onOpenCbFun && onOpenCbFun(ev);
    ws.send('2333');
  });
  ws.addEventListener('close', ev => {
    onCloseCbFun && onCloseCbFun(ev);
  });
  ws.addEventListener('message', ev => {
    onMessageCbFun && onMessageCbFun(JSON.parse(ev.data));
  });
};

```



提交支付时调用方法，来回轮询请求支付结果（在custom-ldy-wx文件中）

```js
    /**
     * 创建webSocket
     */
    createWebSocket: function(token) {
      // 注册websocket对象
      var that = this;

      console.log('创建WebSocket');
      var WSURL =
        'wss://' +
        URL_domain +
        '/webSocketApi/subProg/weixin/wxPayStatus' +
        '?id=' +
        token;
      this.WSURL = WSURL;
      console.log('WebSocket  ==> url :' + WSURL);

      ws({
        wsUrl: WSURL,
        onOpenCbFun: function(openData) {
          console.log(new Date(), 'websocket --- openData === ', openData);
        },
        onCloseCbFun: function() {
          console.log('websocket关闭，重新连接连接并且定时查询订单');
          setTimeout(function() {
            console.error(new Date(), '关闭后3秒重新连接');
            that.createWebSocket(token);
          }, 3000);
        },
        onMessageCbFun: that.onMessageCbFun,
      });
    },
        
    // 在预支付函数中调用创建webSocket函数
            /**
     * 调起微信预支付
     */
    makePreparePay: function() {
      console.log('微信预支付...');

      // 产生平台支付流水号
      this.isHadShowTeacher = false;
      var platformCode = this.getRandomPlatformCode();
      this.outTradeNo = platformCode;
      this.createWebSocket(platformCode); // 创建WS

      var that = this;
      var url = URL_wxPay;
      var openId = this.enrollOpenId;
      var courseId = this.courseId;
      var couponCode = this.couponCode;
      var registerOrigin = this.registerOrigin;
      var pageOrigin = this.pageOrigin;
      var mobile = this.mobile;
      var nickName = this.studentName;
      var isCourseHelper = this.isCourseHelper;

      var teacherId = this.teacherId;
      var consultId = this.consultId;
      var workingWechatId = this.workingWeChatId;
      var enrollNickName = this.enrollNickName;
      var wxNickName = this.enrollNickName;
      var grade = this.grade || 'grade1';

      var isFission = this.isFission;
      var fissionType = this.fissionType;
      var fissionSpo = this.fissionSpo;
      var fissionWorkingWechatId = this.fissionWorkingWechatId;

      const hadPc = this.hadPc;
      const { isPreview } = this.pageConfig;

      var extInfoJsonbObj = {
        mobile: mobile,
        enrollNickName: enrollNickName,
        registerOrigin: registerOrigin,
        teacherId: teacherId,
        consultId: consultId,
        workingWechatId: workingWechatId,
        grade: grade,
        isCourseHelper: isCourseHelper,
        isFission: isFission,
        fissionType: fissionType,
        fissionSpo: fissionSpo,
        fissionWorkingWechatId: fissionWorkingWechatId,
        hadPc,
        isPreview,
        pageType: 1,
      };
      var extInfoJsonb = JSON.stringify(extInfoJsonbObj);

      var params = {
        openId: openId,
        courseId: courseId,
        couponCode: couponCode,
        registerOrigin: registerOrigin,
        pageOrigin: pageOrigin,
        mobile: mobile,
        nickName: nickName,
        platformCode: platformCode,
        extInfoJsonb: extInfoJsonb,
        wxNickName: wxNickName,
        grade: grade,
      };

      var option = {
        type: 'POST',
        data: params,
        url: url,
        // handleError: true,
        // isShowLoader: true,
        // loaderText: '处理中，请稍后...',
        showLoading: true,
        loadingMsg: '处理中，请稍后...',
        headers: { 'Content-Type': 'application/json;charset=UTF-8' },
      };

      t.ajax(option, function(resp) {
        console.log('发起预支付结果');
        console.log(resp);
        var errorCode = resp.errorCode;
        var errorMsg = resp.errorMsg;
        if (errorCode == '01') {
          t.showMessage(errorMsg);
          Toast.clear();
          return;
        }

        var result = resp.returnObject;
        var isZeroPay = result.izp;
        var lastPayFee = result.lastPayFee;
        that.lastAmount = lastPayFee;
        console.log('最终实际支付的金额为：' + that.lastAmount);
        that.outTradeNo = result.outTradeNo;

        if (isZeroPay) {
          console.log('0元支付');
          that.lastAmount = 0;
          that.handleZeroPayResult();
        } else {
          console.log('非0元支付');
          var jsapiPayInfo = result.jsInfo;
          // 选择支付方式
          that.handleWxChoosePay(jsapiPayInfo);
        }
      });
    },
```



### 表单组件封装

1.FormField.vue组件的封装（单个控件多种类型）

```vue
<template>
  <div class="form-field">
    <div class="form-field-icon">
      <img :class="icon | iconClass" :src="icon | iconPath" />
    </div>
    <input
      class="form-field-input"
      :type="type"
      :placeholder="label"
      :disabled="disabled"
      v-model.trim="model"
    />
  </div>
</template>

<script>
export default {
  filters: {
    iconPath(val) {
      return require(`../img/${val}.png`);
    },
    iconClass(val) {
      return `form-field-icon-${val}`;
    },
  },
  props: {
    type: {
      type: String,
      default: 'text',
    },
    icon: String,
    label: String,
    value: String,
    disabled: Boolean,
  },
  computed: {
    model: {
      get() {
        return this.value;
      },
      set(val) {
        this.$emit('input', val);
      },
    },
  },
};
</script>

<style lang="less" scoped>
.form-field {
  display: flex;
  border-radius: 10px;
  box-sizing: border-box;
  border: 1px solid #fea275;
  width: 100%;
  height: 80px;
  background-color: #fff;
  &-icon {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 80px;
    height: 80px;
    &-phone {
      width: 33px;
      height: 58px;
    }
    &-message {
      width: 48px;
      height: 32px;
    }
    &-nickname {
      width: 39px;
      height: 54px;
    }
    &-grade {
      width: 53px;
      height: 46px;
    }
  }
  &-input {
    flex: 1;
    border: none;
    font-size: 28px;
    background: none;
  }
}
</style>

```



FormSignUp.vue组件封装

```vue
<template>
  <div class="form-sign-up">
    <div class="header"></div>
    <div class="form">
      <!-- 手机号 -->
      <FormField
        class="form-row"
        type="tel"
        icon="phone"
        label="请输入您的手机号"
        v-model="formData.mobile"
      />
      <!-- 验证码 -->
      <div class="form-row">
        <FormField
          class="form-row-left"
          icon="message"
          label="请输入短信验证码"
          v-model="formData.code"
        />
        <ButtonGetCode :phone="formData.mobile" />
      </div>
      <!-- 昵称 -->
      <FormField
        v-if="config.isNickname"
        class="form-row"
        icon="nickname"
        label="请输入您孩子的昵称"
        v-model="formData.name"
      />
      <!-- 年级 -->
      <FormField
        v-if="config.isGrade"
        class="form-row"
        disabled
        icon="grade"
        label="请选择您孩子所在年级"
        v-model="formData.gradeText"
        @click.native="isShowPickerGrade = true"
      />
      <!-- 是否有电脑 -->
      <div v-if="config.isComputer" class="form-row form-pc">
        <div>请问您是否有电脑</div>
        <div class="form-pc-options">
          <FormRadio :name="1" v-model="formData.hadPc">有电脑</FormRadio>
          <FormRadio :name="2" v-model="formData.hadPc">无电脑</FormRadio>
        </div>
      </div>
      <!-- 协议 -->
      <div class="form-row form-protocol">
        <FormCheckbox v-model="formData.isProtocol" />
        <span class="form-protocol-text">我已阅读并同意</span>
        <span class="form-protocol-link" @click="onProtocolLink">
          《和码编程用户注册协议》
        </span>
      </div>
      <!-- 提示 -->
      <div class="form-row form-tips">
        <div class="form-tips-icon">
          <div class="form-tips-icon-img"></div>
        </div>
        <div class="form-tips-text">
          家长们请注意：暂时仅支持电脑上课哦~
        </div>
      </div>
      <!-- 报 名 -->
      <div class="form-submit" :class="submitClassObject" @click="onFormSubmit">
        立 即 报 名
      </div>
    </div>
    <div class="footer"></div>
    <PopupPicker
      :columns="gradeList"
      :show.sync="isShowPickerGrade"
      @confirm="onPickerGradeConfirm"
    />
  </div>
</template>

<script>
import FormField from '../../ldy/components/FormField';
import FormCheckbox from '../../ldy/components/FormCheckbox';
import FormRadio from '../../ldy/components/FormRadio';
import ButtonGetCode from '../../ldy/components/ButtonGetCode';
import PopupPicker from '../../ldy/components/PopupPicker';
import { Dialog } from 'vant';
import { checkCode } from '@/assets/js/service/msg-code';
import { URL_LINK_protocal } from '@/assets/js/api';

export default {
  components: {
    FormField,
    FormCheckbox,
    FormRadio,
    ButtonGetCode,
    PopupPicker,
    [Dialog.name]: Dialog,
  },
  props: {
    formData: Object,
    config: Object,
  },
  data() {
    return {
      isShowPickerGrade: false,
      gradeList: [
        { value: 'kindergarten', text: '幼儿园' },
        { value: 'grade1', text: '1年级' },
        { value: 'grade2', text: '2年级' },
        { value: 'grade3', text: '3年级' },
        { value: 'grade4', text: '4年级' },
        { value: 'grade5', text: '5年级' },
        { value: 'grade6', text: '6年级' },
      ],
    };
  },
  computed: {
    submitClassObject() {
      return {
        'form-submit-disabled': !this.formData.isProtocol,
      };
    },
  },
  methods: {
    onPickerGradeConfirm(item) {
      const { value, text } = item;
      this.formData.grade = value;
      this.formData.gradeText = text;
    },
    async onFormSubmit() {
      const { formData, config } = this;
      const { mobile, name, grade, hadPc, code, isProtocol } = formData;
      const { isGrade, isNickname, isComputer } = config;
      if (!mobile || mobile.length !== 11) {
        Dialog.alert({ message: '请输入正确的手机号' });
        return;
      }
      if (isNickname && !name) {
        Dialog.alert({ message: '请输入您孩子的昵称' });
        return;
      }
      if (isGrade && !grade) {
        Dialog.alert({ message: '请选择您孩子所在年级' });
        return;
      }
      if (isComputer && !hadPc) {
        Dialog.alert({ message: '请选择您是否有电脑' });
        return;
      }
      if (!code) {
        Dialog.alert({ message: '请输入短信验证码' });
        return;
      }
      if (!isProtocol) {
        Dialog.alert({ message: '请同意并勾选《和码编程用户注册协议》' });
        return;
      }
      await checkCode(mobile, code);
      this.$emit('on-submit');
    },
    onProtocolLink() {
      location.href = URL_LINK_protocal;
    },
  },
};
</script>

<style lang="less" scoped>
.form-sign-up {
  .header {
    width: 750px;
    height: 60px;
    background-size: 100%;
    background-image: url('../../ldy/img/form-header.png');
  }
  .footer {
    width: 750px;
    height: 132px;
    background-size: 100%;
    background-image: url('../../ldy/img/form-footer.png');
  }
  .form {
    display: flex;
    flex-direction: column;
    align-items: center;
    box-sizing: border-box;
    padding: 0 64px;
    background-size: 100%;
    background-image: url('../../ldy/img/form-body.png');
    background-repeat: repeat-y;
    &-row {
      display: flex;
      width: 100%;
      &:not(:first-child) {
        margin-top: 20px;
      }
      &-left {
        flex: 1;
        margin-right: 12px;
      }
    }
    &-pc {
      box-sizing: border-box;
      padding: 12px;
      font-size: 28px;
      &-options {
        flex: 1;
        display: flex;
        justify-content: space-evenly;
      }
    }
    &-protocol {
      box-sizing: border-box;
      padding: 6px 12px 0;
      font-size: 26px;
      color: #666;
      &-text {
        padding-left: 6px;
      }
      &-link {
        color: #f6804e;
      }
    }
    &-tips {
      box-sizing: border-box;
      padding: 0 12px;
      font-size: 24px;
      color: #666;
      &-icon {
        display: flex;
        justify-content: center;
        width: 30px;
        &-img {
          width: 24px;
          height: 22px;
          background-size: 100%;
          background-image: url('../../ldy/img/star.png');
        }
      }
      &-text {
        padding-left: 6px;
      }
    }
    &-submit {
      border-radius: 48px;
      margin-top: 32px;
      width: 490px;
      height: 80px;
      line-height: 80px;
      font-size: 54px;
      text-align: center;
      color: #fff;
      background-color: #f6804e;
      transition: 0.2s;
      &-disabled {
        filter: grayscale(1);
      }
    }
  }
}
</style>
```



App.vue调用

```vue
      <FormSignUp
        ref="form"
        :config="pageConfig"
        :form-data="formData"
        @on-submit="onFormSubmit"
      />
```



### 短信验证码组件封装

```VUE
<template>
  <div class="button-get-code" :class="classObject" @click="onClick">
    <span v-if="disabled">{{ second }}s重新获取</span>
    <span v-else>获取验证码</span>
  </div>
</template>

<script>
import { Dialog } from 'vant';
import { sendCode } from '@/assets/js/service/msg-code';

export default {
  components: {
    [Dialog.name]: Dialog,
  },
  props: {
    phone: String,
  },
  data() {
    return {
      disabled: false,
      second: 0,
      COUNT: 60,
    };
  },
  computed: {
    classObject() {
      return {
        'button-get-code-disabled': this.disabled,
      };
    },
  },
  methods: {
    async onClick() {
      if (this.disabled) {
        return;
      }
      if (!this.phone || this.phone.length !== 11) {
        Dialog.alert({ message: '请输入正确的手机号' });
        return;
      }
      await sendCode(this.phone);
      this.disabled = true;
      this.second = this.COUNT;
        // 设置定时器 60秒
      const itv = setInterval(() => {
        this.second--;
        if (this.second === 0) {
          this.disabled = false;
          clearInterval(itv);
        }
      }, 1000);
    },
  },
};
</script>

<style lang="less" scoped>
.button-get-code {
  border-radius: 10px;
  padding: 0 10px;
  height: 82px;
  font-size: 28px;
  line-height: 82px;
  text-align: center;
  color: #fff;
  background-color: #ff822e;
  &-disabled {
    filter: grayscale(1);
  }
}
</style>

```



网络请求

```js
import $ajax from '../ajax';
import { URL_sendSms, URL_verifySmsCode } from '../api';
import { Dialog } from 'vant';

/**
 * 发送验证码
 * @param {String} mobile 手机号
 * @param {String} flag 验证码类型
 */
export const sendCode = (mobile, flag = 'verifyCode') => {
  return new Promise(resolve => {
    if (!mobile || !mobile.trim().length) {
      Dialog.alert({ message: '请输入电话号码' });
      return;
    } else {
      if (mobile.length != 11 || mobile.indexOf('1') != 0) {
        Dialog.alert({ message: '请输入正确的11位手机号码' });
        return;
      }
    }

    // 访问发送短信接口
    var smsUrl = URL_sendSms;
    var param = {
      phoneNum: mobile,
      flag: flag,
    };
    var option = {
      url: smsUrl,
      method: 'GET',
      data: param,
      showLoading: true,
    };
    $ajax(option).then(function(resp) {
      console.log('发送短信结果');
      console.log(resp);
      var { errorCode, errorMsg } = resp;
      if (errorCode === '00') {
        console.info('获取验证码成功，mobile=' + mobile);
        Dialog.alert({ message: '发送验证码成功，请注意查收手机短信！' });
        resolve();
      } else {
        console.error('获取短信验证码失败，发生了其他错误');
        Dialog.alert({ message: errorMsg });
      }
    });
  });
};

/**
 * 检验 验证码
 * @param {String} mobile 手机号
 * @param {String} code 验证码
 * @param {String} flag 验证码类型
 */
export const checkCode = (mobile, code, flag = 'verifyCode') => {
  return new Promise(resolve => {
    var url = URL_verifySmsCode;
    var params = {
      phoneNum: mobile,
      checkCode: code,
      flag: flag,
    };
    var option = {
      url: url,
      method: 'GET',
      data: params,
      showLoading: true,
    };

    $ajax(option).then(function(resp) {
      console.log('验证短信验证码结果');
      console.log(resp);
      var { errorCode, errorMsg } = resp;
      if (errorCode === '00') {
        resolve();
      } else {
        console.warn('校验验证码发生了其他错误');
        Dialog.alert({ message: errorMsg });
      }
    });
  });
};

```

